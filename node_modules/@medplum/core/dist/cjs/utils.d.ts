import { CodeableConcept, ObservationDefinition, ObservationDefinitionQualifiedInterval, Patient, Practitioner, QuestionnaireResponse, QuestionnaireResponseItemAnswer, Range, Reference, RelatedPerson, Resource } from '@medplum/fhirtypes';
/**
 * @internal
 */
export type ProfileResource = Patient | Practitioner | RelatedPerson;
/**
 * Creates a reference resource.
 * @param resource The FHIR reesource.
 * @returns A reference resource.
 */
export declare function createReference<T extends Resource>(resource: T): Reference<T>;
/**
 * Returns a reference string for a resource.
 * @param resource The FHIR resource.
 * @returns A reference string of the form resourceType/id.
 */
export declare function getReferenceString(resource: Resource): string;
/**
 * Returns the ID portion of a reference.
 * @param reference A FHIR reference.
 * @returns The ID portion of a reference.
 */
export declare function resolveId(reference: Reference | undefined): string | undefined;
/**
 * Returns true if the resource is a "ProfileResource".
 * @param resource The FHIR resource.
 * @returns True if the resource is a "ProfileResource".
 */
export declare function isProfileResource(resource: Resource): resource is ProfileResource;
/**
 * Returns a display string for the resource.
 * @param resource The input resource.
 * @return Human friendly display string.
 */
export declare function getDisplayString(resource: Resource): string;
/**
 * Returns an image URL for the resource, if one is available.
 * @param resource The input resource.
 * @returns The image URL for the resource or undefined.
 */
export declare function getImageSrc(resource: Resource): string | undefined;
/**
 * Returns a Date property as a Date.
 * When working with JSON objects, Dates are often serialized as ISO-8601 strings.
 * When that happens, we need to safely convert to a proper Date object.
 * @param date The date property value, which could be a string or a Date object.
 * @returns A Date object.
 */
export declare function getDateProperty(date: string | undefined): Date | undefined;
/**
 * Calculates the age in years from the birth date.
 * @param birthDateStr The birth date or start date in ISO-8601 format YYYY-MM-DD.
 * @param endDateStr Optional end date in ISO-8601 format YYYY-MM-DD. Default value is today.
 * @returns The age in years, months, and days.
 */
export declare function calculateAge(birthDateStr: string, endDateStr?: string): {
    years: number;
    months: number;
    days: number;
};
/**
 * Calculates the age string for display using the age appropriate units.
 * If the age is greater than or equal to 2 years, then the age is displayed in years.
 * If the age is greater than or equal to 1 month, then the age is displayed in months.
 * Otherwise, the age is displayed in days.
 * @param birthDateStr The birth date or start date in ISO-8601 format YYYY-MM-DD.
 * @param endDateStr Optional end date in ISO-8601 format YYYY-MM-DD. Default value is today.
 * @returns The age string.
 */
export declare function calculateAgeString(birthDateStr: string, endDateStr?: string): string | undefined;
/**
 * Returns all questionnaire answers as a map by link ID.
 * @param response The questionnaire response resource.
 * @returns Questionnaire answers mapped by link ID.
 */
export declare function getQuestionnaireAnswers(response: QuestionnaireResponse): Record<string, QuestionnaireResponseItemAnswer>;
/**
 * Returns the resource identifier for the given system.
 *
 * If multiple identifiers exist with the same system, the first one is returned.
 *
 * If the system is not found, then returns undefined.
 *
 * @param resource The resource to check.
 * @param system The identifier system.
 * @returns The identifier value if found; otherwise undefined.
 */
export declare function getIdentifier(resource: Resource, system: string): string | undefined;
/**
 * Returns an extension value by extension URLs.
 * @param resource The base resource.
 * @param urls Array of extension URLs.  Each entry represents a nested extension.
 * @returns The extension value if found; undefined otherwise.
 */
export declare function getExtensionValue(resource: any, ...urls: string[]): string | undefined;
/**
 * FHIR JSON stringify.
 * Removes properties with empty string values.
 * Removes objects with zero properties.
 * See: https://www.hl7.org/fhir/json.html
 * @param value The input value.
 * @param pretty Optional flag to pretty-print the JSON.
 * @returns The resulting JSON string.
 */
export declare function stringify(value: any, pretty?: boolean): string;
/**
 * Returns true if the value is empty (null, undefined, empty string, or empty object).
 * @param v Any value.
 * @returns True if the value is an empty string or an empty object.
 */
export declare function isEmpty(v: any): boolean;
/**
 * Resource equality.
 * Ignores meta.versionId and meta.lastUpdated.
 * @param object1 The first object.
 * @param object2 The second object.
 * @returns True if the objects are equal.
 */
export declare function deepEquals(object1: unknown, object2: unknown, path?: string): boolean;
/**
 * Creates a deep clone of the input value.
 *
 * Limitations:
 *  - Only supports JSON primitives and arrays.
 *  - Does not support Functions, lambdas, etc.
 *  - Does not support circular references.
 *
 * See: https://web.dev/structured-clone/
 * See: https://stackoverflow.com/questions/40488190/how-is-structured-clone-algorithm-different-from-deep-copy
 *
 * @param input The input to clone.
 * @returns A deep clone of the input.
 */
export declare function deepClone<T>(input: T): T;
/**
 * Returns true if the input string is a UUID.
 * @param input The input string.
 * @returns True if the input string matches the UUID format.
 */
export declare function isUUID(input: string): boolean;
/**
 * Returns true if the input is an object.
 * @param object The candidate object.
 * @returns True if the input is a non-null non-undefined object.
 */
export declare function isObject(obj: unknown): obj is Record<string, unknown>;
/**
 * Returns true if the input array is an array of strings.
 * @param arr Input array.
 * @returns True if the input array is an array of strings.
 */
export declare function isStringArray(arr: any[]): arr is string[];
/**
 * Converts an ArrayBuffer to hex string.
 * See: https://stackoverflow.com/a/55200387
 * @param arrayBuffer The input array buffer.
 * @returns The resulting hex string.
 */
export declare function arrayBufferToHex(arrayBuffer: ArrayBuffer): string;
/**
 * Converts an ArrayBuffer to a base-64 encoded string.
 * @param arrayBuffer The input array buffer.
 * @returns The base-64 encoded string.
 */
export declare function arrayBufferToBase64(arrayBuffer: ArrayBuffer): string;
export declare function capitalize(word: string): string;
export declare function isLowerCase(c: string): boolean;
/**
 * Tries to find a code string for a given system within a given codeable concept.
 * @param concept The codeable concept.
 * @param system The system string.
 * @returns The code if found; otherwise undefined.
 */
export declare function getCodeBySystem(concept: CodeableConcept, system: string): string | undefined;
/**
 * Sets a code for a given system within a given codeable concept.
 * @param concept The codeable concept.
 * @param system The system string.
 * @param code The code value.
 */
export declare function setCodeBySystem(concept: CodeableConcept, system: string, code: string): void;
/**
 * Tries to find an observation interval for the given patient and value.
 * @param definition The observation definition.
 * @param patient The patient.
 * @param value The observation value.
 * @returns The observation interval if found; otherwise undefined.
 */
export declare function findObservationInterval(definition: ObservationDefinition, patient: Patient, value: number, category?: 'reference' | 'critical' | 'absolute'): ObservationDefinitionQualifiedInterval | undefined;
/**
 * Tries to find an observation reference range for the given patient and condition names.
 * @param definition The observation definition.
 * @param patient The patient.
 * @param names The condition names.
 * @returns The observation interval if found; otherwise undefined.
 */
export declare function findObservationReferenceRange(definition: ObservationDefinition, patient: Patient, names: string[]): ObservationDefinitionQualifiedInterval | undefined;
/**
 * Returns true if the value is in the range accounting for precision.
 * @param value The numeric value.
 * @param range The numeric range.
 * @param precision Optional precision in number of digits.
 * @returns True if the value is within the range.
 */
export declare function matchesRange(value: number, range: Range, precision?: number): boolean;
/**
 * Returns the input number rounded to the specified number of digits.
 * @param a The input number.
 * @param precision The precision in number of digits.
 * @returns The number rounded to the specified number of digits.
 */
export declare function preciseRound(a: number, precision: number): number;
/**
 * Returns true if the two numbers are equal to the given precision.
 * @param a The first number.
 * @param b The second number.
 * @param precision Optional precision in number of digits.
 * @returns True if the two numbers are equal to the given precision.
 */
export declare function preciseEquals(a: number, b: number, precision?: number): boolean;
/**
 * Returns true if the first number is less than the second number to the given precision.
 * @param a The first number.
 * @param b The second number.
 * @param precision Optional precision in number of digits.
 * @returns True if the first number is less than the second number to the given precision.
 */
export declare function preciseLessThan(a: number, b: number, precision?: number): boolean;
/**
 * Returns true if the first number is greater than the second number to the given precision.
 * @param a The first number.
 * @param b The second number.
 * @param precision Optional precision in number of digits.
 * @returns True if the first number is greater than the second number to the given precision.
 */
export declare function preciseGreaterThan(a: number, b: number, precision?: number): boolean;
/**
 * Returns true if the first number is less than or equal to the second number to the given precision.
 * @param a The first number.
 * @param b The second number.
 * @param precision Optional precision in number of digits.
 * @returns True if the first number is less than or equal to the second number to the given precision.
 */
export declare function preciseLessThanOrEquals(a: number, b: number, precision?: number): boolean;
/**
 * Returns true if the first number is greater than or equal to the second number to the given precision.
 * @param a The first number.
 * @param b The second number.
 * @param precision Optional precision in number of digits.
 * @returns True if the first number is greater than or equal to the second number to the given precision.
 */
export declare function preciseGreaterThanOrEquals(a: number, b: number, precision?: number): boolean;
