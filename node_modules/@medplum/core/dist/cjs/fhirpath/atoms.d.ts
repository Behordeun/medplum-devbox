import { Atom, InfixOperatorAtom, PrefixOperatorAtom } from '../fhirlexer';
import { TypedValue } from '../types';
export declare class FhirPathAtom implements Atom {
    readonly original: string;
    readonly child: Atom;
    constructor(original: string, child: Atom);
    eval(context: TypedValue[]): TypedValue[];
    toString(): string;
}
export declare class LiteralAtom implements Atom {
    readonly value: TypedValue;
    constructor(value: TypedValue);
    eval(): TypedValue[];
    toString(): string;
}
export declare class SymbolAtom implements Atom {
    #private;
    readonly name: string;
    constructor(name: string);
    eval(context: TypedValue[]): TypedValue[];
    toString(): string;
}
export declare class EmptySetAtom implements Atom {
    eval(): [];
    toString(): string;
}
export declare class UnaryOperatorAtom extends PrefixOperatorAtom {
    readonly impl: (x: TypedValue[]) => TypedValue[];
    constructor(operator: string, child: Atom, impl: (x: TypedValue[]) => TypedValue[]);
    eval(context: TypedValue[]): TypedValue[];
    toString(): string;
}
export declare class AsAtom extends InfixOperatorAtom {
    constructor(left: Atom, right: Atom);
    eval(context: TypedValue[]): TypedValue[];
}
export declare class ArithemticOperatorAtom extends InfixOperatorAtom {
    readonly impl: (x: number, y: number) => number | boolean;
    constructor(operator: string, left: Atom, right: Atom, impl: (x: number, y: number) => number | boolean);
    eval(context: TypedValue[]): TypedValue[];
}
export declare class ConcatAtom extends InfixOperatorAtom {
    constructor(left: Atom, right: Atom);
    eval(context: TypedValue[]): TypedValue[];
}
export declare class ContainsAtom extends InfixOperatorAtom {
    constructor(left: Atom, right: Atom);
    eval(context: TypedValue[]): TypedValue[];
}
export declare class InAtom extends InfixOperatorAtom {
    constructor(left: Atom, right: Atom);
    eval(context: TypedValue[]): TypedValue[];
}
export declare class DotAtom extends InfixOperatorAtom {
    constructor(left: Atom, right: Atom);
    eval(context: TypedValue[]): TypedValue[];
    toString(): string;
}
export declare class UnionAtom extends InfixOperatorAtom {
    constructor(left: Atom, right: Atom);
    eval(context: TypedValue[]): TypedValue[];
}
export declare class EqualsAtom extends InfixOperatorAtom {
    constructor(left: Atom, right: Atom);
    eval(context: TypedValue[]): TypedValue[];
}
export declare class NotEqualsAtom extends InfixOperatorAtom {
    constructor(left: Atom, right: Atom);
    eval(context: TypedValue[]): TypedValue[];
}
export declare class EquivalentAtom extends InfixOperatorAtom {
    constructor(left: Atom, right: Atom);
    eval(context: TypedValue[]): TypedValue[];
}
export declare class NotEquivalentAtom extends InfixOperatorAtom {
    constructor(left: Atom, right: Atom);
    eval(context: TypedValue[]): TypedValue[];
}
export declare class IsAtom extends InfixOperatorAtom {
    constructor(left: Atom, right: Atom);
    eval(context: TypedValue[]): TypedValue[];
}
/**
 * 6.5.1. and
 * Returns true if both operands evaluate to true,
 * false if either operand evaluates to false,
 * and the empty collection otherwise.
 */
export declare class AndAtom extends InfixOperatorAtom {
    constructor(left: Atom, right: Atom);
    eval(context: TypedValue[]): TypedValue[];
}
export declare class OrAtom extends InfixOperatorAtom {
    constructor(left: Atom, right: Atom);
    eval(context: TypedValue[]): TypedValue[];
}
/**
 * 6.5.4. xor
 * Returns true if exactly one of the operands evaluates to true,
 * false if either both operands evaluate to true or both operands evaluate to false,
 * and the empty collection otherwise.
 */
export declare class XorAtom extends InfixOperatorAtom {
    constructor(left: Atom, right: Atom);
    eval(context: TypedValue[]): TypedValue[];
}
export declare class FunctionAtom implements Atom {
    readonly name: string;
    readonly args: Atom[];
    constructor(name: string, args: Atom[]);
    eval(context: TypedValue[]): TypedValue[];
    toString(): string;
}
export declare class IndexerAtom implements Atom {
    readonly left: Atom;
    readonly expr: Atom;
    constructor(left: Atom, expr: Atom);
    eval(context: TypedValue[]): TypedValue[];
    toString(): string;
}
