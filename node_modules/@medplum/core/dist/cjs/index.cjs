(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.medplum = global.medplum || {}, global.medplum.core = {})));
})(this, (function (exports) { 'use strict';

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }

    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    var _LRUCache_instances, _LRUCache_max, _LRUCache_cache, _LRUCache_first;
    /**
     * LRU cache (least recently used)
     * Source: https://stackoverflow.com/a/46432113
     */
    class LRUCache {
        constructor(max = 10) {
            _LRUCache_instances.add(this);
            _LRUCache_max.set(this, void 0);
            _LRUCache_cache.set(this, void 0);
            __classPrivateFieldSet(this, _LRUCache_max, max, "f");
            __classPrivateFieldSet(this, _LRUCache_cache, new Map(), "f");
        }
        /**
         * Deletes all values from the cache.
         */
        clear() {
            __classPrivateFieldGet(this, _LRUCache_cache, "f").clear();
        }
        /**
         * Returns the value for the given key.
         * @param key The key to retrieve.
         * @returns The value if found; undefined otherwise.
         */
        get(key) {
            const item = __classPrivateFieldGet(this, _LRUCache_cache, "f").get(key);
            if (item) {
                __classPrivateFieldGet(this, _LRUCache_cache, "f").delete(key);
                __classPrivateFieldGet(this, _LRUCache_cache, "f").set(key, item);
            }
            return item;
        }
        /**
         * Sets the value for the given key.
         * @param key The key to set.
         * @param val The value to set.
         */
        set(key, val) {
            if (__classPrivateFieldGet(this, _LRUCache_cache, "f").has(key)) {
                __classPrivateFieldGet(this, _LRUCache_cache, "f").delete(key);
            }
            else if (__classPrivateFieldGet(this, _LRUCache_cache, "f").size >= __classPrivateFieldGet(this, _LRUCache_max, "f")) {
                __classPrivateFieldGet(this, _LRUCache_cache, "f").delete(__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_first).call(this));
            }
            __classPrivateFieldGet(this, _LRUCache_cache, "f").set(key, val);
        }
        /**
         * Deletes the value for the given key.
         * @param key The key to delete.
         */
        delete(key) {
            __classPrivateFieldGet(this, _LRUCache_cache, "f").delete(key);
        }
        /**
         * Returns the list of all keys in the cache.
         * @returns The array of keys in the cache.
         */
        keys() {
            return __classPrivateFieldGet(this, _LRUCache_cache, "f").keys();
        }
    }
    _LRUCache_max = new WeakMap(), _LRUCache_cache = new WeakMap(), _LRUCache_instances = new WeakSet(), _LRUCache_first = function _LRUCache_first() {
        // This works because the Map class maintains ordered keys.
        return __classPrivateFieldGet(this, _LRUCache_cache, "f").keys().next().value;
    };

    /**
     * Formats a FHIR Address as a string.
     * @param address The address to format.
     * @param options Optional address format options.
     * @returns The formatted address string.
     */
    function formatAddress(address, options) {
        const builder = [];
        if (address.line) {
            builder.push(...address.line);
        }
        if (address.city || address.state || address.postalCode) {
            const cityStateZip = [];
            if (address.city) {
                cityStateZip.push(address.city);
            }
            if (address.state) {
                cityStateZip.push(address.state);
            }
            if (address.postalCode) {
                cityStateZip.push(address.postalCode);
            }
            builder.push(cityStateZip.join(', '));
        }
        if (address.use && (options?.all || options?.use)) {
            builder.push('[' + address.use + ']');
        }
        return builder.join(options?.lineSeparator || ', ').trim();
    }
    /**
     * Formats a FHIR HumanName as a string.
     * @param name The name to format.
     * @param options Optional name format options.
     * @returns The formatted name string.
     */
    function formatHumanName(name, options) {
        const builder = [];
        if (name.prefix && options?.prefix !== false) {
            builder.push(...name.prefix);
        }
        if (name.given) {
            builder.push(...name.given);
        }
        if (name.family) {
            builder.push(name.family);
        }
        if (name.suffix && options?.suffix !== false) {
            builder.push(...name.suffix);
        }
        if (name.use && (options?.all || options?.use)) {
            builder.push('[' + name.use + ']');
        }
        return builder.join(' ').trim();
    }
    /**
     * Formats the given name portion of a FHIR HumanName element.
     * @param name The name to format.
     * @returns The formatted given name string.
     */
    function formatGivenName(name) {
        const builder = [];
        if (name.given) {
            builder.push(...name.given);
        }
        return builder.join(' ').trim();
    }
    /**
     * Formats the family name portion of a FHIR HumanName element.
     * @param name The name to format.
     * @returns The formatted family name string.
     */
    function formatFamilyName(name) {
        return name.family || '';
    }
    /**
     * Returns true if the given date object is a valid date.
     * Dates can be invalid if created by parsing an invalid string.
     * @param date A date object.
     * @returns Returns true if the date is a valid date.
     */
    function isValidDate(date) {
        return date instanceof Date && !isNaN(date.getTime());
    }
    /**
     * Formats a FHIR date string as a human readable string.
     * Handles missing values and invalid dates.
     * @param date The date to format.
     * @param locales Optional locales.
     * @param options Optional date format options.
     * @returns The formatted date string.
     */
    function formatDate(date, locales, options) {
        if (!date) {
            return '';
        }
        const d = new Date(date);
        if (!isValidDate(d)) {
            return '';
        }
        d.setUTCHours(0, 0, 0, 0);
        return d.toLocaleDateString(locales, { timeZone: 'UTC', ...options });
    }
    /**
     * Formats a FHIR time string as a human readable string.
     * Handles missing values and invalid dates.
     * @param time The date to format.
     * @param locales Optional locales.
     * @param options Optional time format options.
     * @returns The formatted time string.
     */
    function formatTime(time, locales, options) {
        if (!time) {
            return '';
        }
        const d = new Date('2000-01-01T' + time + 'Z');
        if (!isValidDate(d)) {
            return '';
        }
        return d.toLocaleTimeString(locales, options);
    }
    /**
     * Formats a FHIR dateTime string as a human readable string.
     * Handles missing values and invalid dates.
     * @param dateTime The dateTime to format.
     * @param locales Optional locales.
     * @param options Optional dateTime format options.
     * @returns The formatted dateTime string.
     */
    function formatDateTime(dateTime, locales, options) {
        if (!dateTime) {
            return '';
        }
        const d = new Date(dateTime);
        if (!isValidDate(d)) {
            return '';
        }
        return d.toLocaleString(locales, options);
    }
    /**
     * Formats a FHIR Period as a human readable string.
     * @param period The period to format.
     * @param locales Optional locales.
     * @param options Optional period format options.
     * @returns The formatted period string.
     */
    function formatPeriod(period, locales, options) {
        if (!period || (!period.start && !period.end)) {
            return '';
        }
        return formatDateTime(period.start, locales, options) + ' - ' + formatDateTime(period.end, locales, options);
    }
    const unitAdverbForm = {
        s: 'every second',
        min: 'every minute',
        h: 'hourly',
        d: 'daily',
        wk: 'weekly',
        mo: 'monthly',
        a: 'annually',
    };
    const singularUnits = {
        s: 'second',
        min: 'minute',
        h: 'hour',
        d: 'day',
        wk: 'week',
        mo: 'month',
        a: 'year',
    };
    const pluralUnits = {
        s: 'seconds',
        min: 'minutes',
        h: 'hours',
        d: 'days',
        wk: 'weeks',
        mo: 'months',
        a: 'years',
    };
    /**
     * Formats a FHIR Timing as a human readable string.
     * @param timing The timing to format.
     * @returns The formatted timing string.
     */
    function formatTiming(timing) {
        if (!timing) {
            return '';
        }
        const builder = [];
        if (timing.repeat?.periodUnit) {
            const frequency = timing.repeat.frequency || 1;
            const period = timing.repeat.period || 1;
            const periodUnit = timing.repeat.periodUnit;
            if (frequency === 1 && period === 1) {
                builder.push(unitAdverbForm[periodUnit]);
            }
            else {
                if (frequency === 1) {
                    builder.push('once');
                }
                else {
                    builder.push(frequency + ' times');
                }
                if (period === 1) {
                    builder.push('per ' + singularUnits[periodUnit]);
                }
                else {
                    builder.push('per ' + period + ' ' + pluralUnits[periodUnit]);
                }
            }
            if (timing.repeat.dayOfWeek) {
                builder.push('on ' + timing.repeat.dayOfWeek.map(capitalize).join(', '));
            }
            if (timing.repeat.timeOfDay) {
                builder.push('at ' + timing.repeat.timeOfDay.map((t) => formatTime(t)).join(', '));
            }
        }
        if (timing.event) {
            builder.push(timing.event.map((d) => formatDateTime(d)).join(', '));
        }
        return capitalize(builder.join(' ').trim());
    }
    /**
     * Returns a human-readable string for a FHIR Range datatype, taking into account comparators and one-sided ranges
     * @param range A FHIR Range element
     * @param exclusive If true, one-sided ranges will be rendered with the '>' or '<' bounds rather than '>=' or '<='
     * @returns A human-readable string representation of the Range
     */
    function formatRange(range, precision, exclusive = false) {
        if (exclusive && precision === undefined) {
            throw new Error('Precision must be specified for exclusive ranges');
        }
        const low = range?.low && { ...range.low };
        const high = range?.high && { ...range.high };
        if (!range || (low?.value === undefined && high?.value === undefined)) {
            return '';
        }
        if (range.low?.value !== undefined && range.high?.value === undefined) {
            if (exclusive && precision !== undefined) {
                range.low.value = preciseDecrement(range.low.value, precision);
                return `> ${formatQuantity(range.low, precision)}`;
            }
            return `>= ${formatQuantity(range.low, precision)}`;
        }
        if (range.low?.value === undefined && range.high?.value !== undefined) {
            if (exclusive && precision !== undefined) {
                range.high.value = preciseIncrement(range.high.value, precision);
                return `< ${formatQuantity(range.high, precision)}`;
            }
            return `<= ${formatQuantity(range.high, precision)}`;
        }
        if (low?.unit === high?.unit) {
            delete low?.unit;
        }
        return `${formatQuantity(low, precision)} - ${formatQuantity(high, precision)}`;
    }
    /**
     * Returns a human-readable string for a FHIR Quantity datatype, taking into account units and comparators
     * @param quantity A FHIR Quantity element
     * @returns A human-readable string representation of the Quantity
     */
    function formatQuantity(quantity, precision) {
        if (!quantity) {
            return '';
        }
        const result = [];
        if (quantity.comparator) {
            result.push(quantity.comparator);
            result.push(' ');
        }
        if (quantity.value !== undefined) {
            if (precision !== undefined) {
                result.push(quantity.value.toFixed(precision));
            }
            else {
                result.push(quantity.value);
            }
        }
        if (quantity.unit) {
            if (quantity.unit !== '%' && result[result.length - 1] !== ' ') {
                result.push(' ');
            }
            result.push(quantity.unit);
        }
        return result.join('').trim();
    }
    function formatMoney(money) {
        if (money?.value === undefined) {
            return '';
        }
        return money.value.toLocaleString(undefined, {
            style: 'currency',
            currency: money.currency || 'USD',
            currencyDisplay: 'narrowSymbol',
        });
    }
    /**
     * Formats a CodeableConcept element as a string.
     * @param codeableConcept A FHIR CodeableConcept element
     * @returns The codeable concept as a string.
     */
    function formatCodeableConcept(codeableConcept) {
        if (!codeableConcept) {
            return '';
        }
        if (codeableConcept.text) {
            return codeableConcept.text;
        }
        if (codeableConcept.coding) {
            return codeableConcept.coding.map((c) => formatCoding(c)).join(', ');
        }
        return '';
    }
    /**
     * Formats a Coding element as a string.
     * @param coding A FHIR Coding element
     * @returns The coding as a string.
     */
    function formatCoding(coding) {
        return coding?.display || coding?.code || '';
    }
    /**
     * Formats a FHIR Observation resource value as a string.
     * @param obs A FHIR Observation resource.
     * @returns A human-readable string representation of the Observation.
     */
    function formatObservationValue(obs) {
        if (!obs) {
            return '';
        }
        if ('component' in obs) {
            return obs.component.map((c) => formatObservationValue(c)).join(' / ');
        }
        if (obs?.valueQuantity) {
            return formatQuantity(obs.valueQuantity);
        }
        if (obs.valueCodeableConcept) {
            return formatCodeableConcept(obs.valueCodeableConcept);
        }
        if (obs.valueString) {
            return obs.valueString;
        }
        return '';
    }
    /**
     * Returns the input number increased by the `n` units of the specified precision
     * @param a The input number
     * @param precision The precision in number of digits.
     * @param n (default 1) The number of units to add
     */
    function preciseIncrement(a, precision, n = 1) {
        return (toPreciseInteger$1(a, precision) + n) * Math.pow(10, -precision);
    }
    /**
     * Returns the input number decreased by the `n` units of the specified precision
     * @param a The input number
     * @param precision The precision in number of digits.
     * @param n (default 1) The number of units to subtract
     */
    function preciseDecrement(a, precision, n = 1) {
        return (toPreciseInteger$1(a, precision) - n) * Math.pow(10, -precision);
    }
    /**
     * Returns an integer representation of the number with the given precision.
     * For example, if precision is 2, then 1.2345 will be returned as 123.
     * @param a The number.
     * @param precision Optional precision in number of digits.
     * @returns The integer with the given precision.
     */
    function toPreciseInteger$1(a, precision) {
        if (precision === undefined) {
            return a;
        }
        return Math.round(a * Math.pow(10, precision));
    }

    /**
     * Creates a reference resource.
     * @param resource The FHIR reesource.
     * @returns A reference resource.
     */
    function createReference(resource) {
        const reference = getReferenceString(resource);
        const display = getDisplayString(resource);
        return display === reference ? { reference } : { reference, display };
    }
    /**
     * Returns a reference string for a resource.
     * @param resource The FHIR resource.
     * @returns A reference string of the form resourceType/id.
     */
    function getReferenceString(resource) {
        return resource.resourceType + '/' + resource.id;
    }
    /**
     * Returns the ID portion of a reference.
     * @param reference A FHIR reference.
     * @returns The ID portion of a reference.
     */
    function resolveId(reference) {
        return reference?.reference?.split('/')[1];
    }
    /**
     * Returns true if the resource is a "ProfileResource".
     * @param resource The FHIR resource.
     * @returns True if the resource is a "ProfileResource".
     */
    function isProfileResource(resource) {
        return (resource.resourceType === 'Patient' ||
            resource.resourceType === 'Practitioner' ||
            resource.resourceType === 'RelatedPerson');
    }
    /**
     * Returns a display string for the resource.
     * @param resource The input resource.
     * @return Human friendly display string.
     */
    function getDisplayString(resource) {
        if (isProfileResource(resource)) {
            const profileName = getProfileResourceDisplayString(resource);
            if (profileName) {
                return profileName;
            }
        }
        if (resource.resourceType === 'Device') {
            const deviceName = getDeviceDisplayString(resource);
            if (deviceName) {
                return deviceName;
            }
        }
        if (resource.resourceType === 'Observation') {
            if ('code' in resource && resource.code?.text) {
                return resource.code.text;
            }
        }
        if (resource.resourceType === 'User') {
            if (resource.email) {
                return resource.email;
            }
        }
        if ('name' in resource && resource.name && typeof resource.name === 'string') {
            return resource.name;
        }
        return getReferenceString(resource);
    }
    /**
     * Returns a display string for a profile resource if one is found.
     * @param resource The profile resource.
     * @returns The display name if one is found.
     */
    function getProfileResourceDisplayString(resource) {
        const names = resource.name;
        if (names && names.length > 0) {
            return formatHumanName(names[0]);
        }
        return undefined;
    }
    /**
     * Returns a display string for a device resource if one is found.
     * @param device The device resource.
     * @returns The display name if one is found.
     */
    function getDeviceDisplayString(device) {
        const names = device.deviceName;
        if (names && names.length > 0) {
            return names[0].name;
        }
        return undefined;
    }
    /**
     * Returns an image URL for the resource, if one is available.
     * @param resource The input resource.
     * @returns The image URL for the resource or undefined.
     */
    function getImageSrc(resource) {
        if (!('photo' in resource)) {
            return undefined;
        }
        const photo = resource.photo;
        if (!photo) {
            return undefined;
        }
        if (Array.isArray(photo)) {
            for (const p of photo) {
                const url = getPhotoImageSrc(p);
                if (url) {
                    return url;
                }
            }
        }
        else {
            return getPhotoImageSrc(photo);
        }
        return undefined;
    }
    function getPhotoImageSrc(photo) {
        if (photo.url && photo.contentType && photo.contentType.startsWith('image/')) {
            return photo.url;
        }
        return undefined;
    }
    /**
     * Returns a Date property as a Date.
     * When working with JSON objects, Dates are often serialized as ISO-8601 strings.
     * When that happens, we need to safely convert to a proper Date object.
     * @param date The date property value, which could be a string or a Date object.
     * @returns A Date object.
     */
    function getDateProperty(date) {
        return date ? new Date(date) : undefined;
    }
    /**
     * Calculates the age in years from the birth date.
     * @param birthDateStr The birth date or start date in ISO-8601 format YYYY-MM-DD.
     * @param endDateStr Optional end date in ISO-8601 format YYYY-MM-DD. Default value is today.
     * @returns The age in years, months, and days.
     */
    function calculateAge(birthDateStr, endDateStr) {
        const startDate = new Date(birthDateStr);
        startDate.setUTCHours(0, 0, 0, 0);
        const endDate = endDateStr ? new Date(endDateStr) : new Date();
        endDate.setUTCHours(0, 0, 0, 0);
        const startYear = startDate.getUTCFullYear();
        const startMonth = startDate.getUTCMonth();
        const startDay = startDate.getUTCDate();
        const endYear = endDate.getUTCFullYear();
        const endMonth = endDate.getUTCMonth();
        const endDay = endDate.getUTCDate();
        let years = endYear - startYear;
        if (endMonth < startMonth || (endMonth === startMonth && endDay < startDay)) {
            years--;
        }
        let months = endYear * 12 + endMonth - (startYear * 12 + startMonth);
        if (endDay < startDay) {
            months--;
        }
        const days = Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));
        return { years, months, days };
    }
    /**
     * Calculates the age string for display using the age appropriate units.
     * If the age is greater than or equal to 2 years, then the age is displayed in years.
     * If the age is greater than or equal to 1 month, then the age is displayed in months.
     * Otherwise, the age is displayed in days.
     * @param birthDateStr The birth date or start date in ISO-8601 format YYYY-MM-DD.
     * @param endDateStr Optional end date in ISO-8601 format YYYY-MM-DD. Default value is today.
     * @returns The age string.
     */
    function calculateAgeString(birthDateStr, endDateStr) {
        const { years, months, days } = calculateAge(birthDateStr, endDateStr);
        if (years >= 2) {
            return years.toString().padStart(3, '0') + 'Y';
        }
        else if (months >= 1) {
            return months.toString().padStart(3, '0') + 'M';
        }
        else {
            return days.toString().padStart(3, '0') + 'D';
        }
    }
    /**
     * Returns all questionnaire answers as a map by link ID.
     * @param response The questionnaire response resource.
     * @returns Questionnaire answers mapped by link ID.
     */
    function getQuestionnaireAnswers(response) {
        const result = {};
        buildQuestionnaireAnswerItems(response.item, result);
        return result;
    }
    /**
     * Recursively builds the questionnaire answer items map.
     * @param item The current questionnaire response item.
     * @param result The cumulative result map.
     */
    function buildQuestionnaireAnswerItems(items, result) {
        if (items) {
            for (const item of items) {
                if (item.linkId && item.answer && item.answer.length > 0) {
                    result[item.linkId] = item.answer[0];
                }
                buildQuestionnaireAnswerItems(item.item, result);
            }
        }
    }
    /**
     * Returns the resource identifier for the given system.
     *
     * If multiple identifiers exist with the same system, the first one is returned.
     *
     * If the system is not found, then returns undefined.
     *
     * @param resource The resource to check.
     * @param system The identifier system.
     * @returns The identifier value if found; otherwise undefined.
     */
    function getIdentifier(resource, system) {
        const identifiers = resource.identifier;
        if (!identifiers) {
            return undefined;
        }
        const array = Array.isArray(identifiers) ? identifiers : [identifiers];
        for (const identifier of array) {
            if (identifier.system === system) {
                return identifier.value;
            }
        }
        return undefined;
    }
    /**
     * Returns an extension value by extension URLs.
     * @param resource The base resource.
     * @param urls Array of extension URLs.  Each entry represents a nested extension.
     * @returns The extension value if found; undefined otherwise.
     */
    function getExtensionValue(resource, ...urls) {
        // Let curr be the current resource or extension. Extensions can be nested.
        let curr = resource;
        // For each of the urls, try to find a matching nested extension.
        for (let i = 0; i < urls.length && curr; i++) {
            curr = curr?.extension?.find((e) => e.url === urls[i]);
        }
        return curr?.valueString;
    }
    /**
     * FHIR JSON stringify.
     * Removes properties with empty string values.
     * Removes objects with zero properties.
     * See: https://www.hl7.org/fhir/json.html
     * @param value The input value.
     * @param pretty Optional flag to pretty-print the JSON.
     * @returns The resulting JSON string.
     */
    function stringify(value, pretty) {
        return JSON.stringify(value, stringifyReplacer, pretty ? 2 : undefined);
    }
    /**
     * Evaluates JSON key/value pairs for FHIR JSON stringify.
     * Removes properties with empty string values.
     * Removes objects with zero properties.
     * @param {string} k Property key.
     * @param {*} v Property value.
     */
    function stringifyReplacer(k, v) {
        return !isArrayKey(k) && isEmpty(v) ? undefined : v;
    }
    /**
     * Returns true if the key is an array key.
     * @param k The property key.
     * @returns True if the key is an array key.
     */
    function isArrayKey(k) {
        return !!k.match(/\d+$/);
    }
    /**
     * Returns true if the value is empty (null, undefined, empty string, or empty object).
     * @param v Any value.
     * @returns True if the value is an empty string or an empty object.
     */
    function isEmpty(v) {
        if (v === null || v === undefined) {
            return true;
        }
        const t = typeof v;
        return (t === 'string' && v === '') || (t === 'object' && Object.keys(v).length === 0);
    }
    /**
     * Resource equality.
     * Ignores meta.versionId and meta.lastUpdated.
     * @param object1 The first object.
     * @param object2 The second object.
     * @returns True if the objects are equal.
     */
    function deepEquals$1(object1, object2, path) {
        if (object1 === object2) {
            return true;
        }
        if (isEmpty(object1) && isEmpty(object2)) {
            return true;
        }
        if (isEmpty(object1) || isEmpty(object2)) {
            return false;
        }
        if (Array.isArray(object1) && Array.isArray(object2)) {
            return deepEqualsArray(object1, object2);
        }
        if (Array.isArray(object1) || Array.isArray(object2)) {
            return false;
        }
        if (isObject$1(object1) && isObject$1(object2)) {
            return deepEqualsObject(object1, object2, path);
        }
        if (isObject$1(object1) || isObject$1(object2)) {
            return false;
        }
        return false;
    }
    function deepEqualsArray(array1, array2) {
        if (array1.length !== array2.length) {
            return false;
        }
        for (let i = 0; i < array1.length; i++) {
            if (!deepEquals$1(array1[i], array2[i])) {
                return false;
            }
        }
        return true;
    }
    function deepEqualsObject(object1, object2, path) {
        const keySet = new Set();
        Object.keys(object1).forEach((k) => keySet.add(k));
        Object.keys(object2).forEach((k) => keySet.add(k));
        if (path === 'meta') {
            keySet.delete('versionId');
            keySet.delete('lastUpdated');
            keySet.delete('author');
        }
        for (const key of keySet) {
            const val1 = object1[key];
            const val2 = object2[key];
            if (!deepEquals$1(val1, val2, key)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Creates a deep clone of the input value.
     *
     * Limitations:
     *  - Only supports JSON primitives and arrays.
     *  - Does not support Functions, lambdas, etc.
     *  - Does not support circular references.
     *
     * See: https://web.dev/structured-clone/
     * See: https://stackoverflow.com/questions/40488190/how-is-structured-clone-algorithm-different-from-deep-copy
     *
     * @param input The input to clone.
     * @returns A deep clone of the input.
     */
    function deepClone(input) {
        return JSON.parse(JSON.stringify(input));
    }
    /**
     * Returns true if the input string is a UUID.
     * @param input The input string.
     * @returns True if the input string matches the UUID format.
     */
    function isUUID(input) {
        return !!input.match(/^\w{8}-\w{4}-\w{4}-\w{4}-\w{12}$/i);
    }
    /**
     * Returns true if the input is an object.
     * @param object The candidate object.
     * @returns True if the input is a non-null non-undefined object.
     */
    function isObject$1(obj) {
        return obj !== null && typeof obj === 'object';
    }
    /**
     * Returns true if the input array is an array of strings.
     * @param arr Input array.
     * @returns True if the input array is an array of strings.
     */
    function isStringArray(arr) {
        return arr.every((e) => typeof e === 'string');
    }
    // Precompute hex octets
    // See: https://stackoverflow.com/a/55200387
    const byteToHex = [];
    for (let n = 0; n < 256; n++) {
        byteToHex.push(n.toString(16).padStart(2, '0'));
    }
    /**
     * Converts an ArrayBuffer to hex string.
     * See: https://stackoverflow.com/a/55200387
     * @param arrayBuffer The input array buffer.
     * @returns The resulting hex string.
     */
    function arrayBufferToHex(arrayBuffer) {
        const bytes = new Uint8Array(arrayBuffer);
        const result = new Array(bytes.length);
        for (let i = 0; i < bytes.length; i++) {
            result[i] = byteToHex[bytes[i]];
        }
        return result.join('');
    }
    /**
     * Converts an ArrayBuffer to a base-64 encoded string.
     * @param arrayBuffer The input array buffer.
     * @returns The base-64 encoded string.
     */
    function arrayBufferToBase64(arrayBuffer) {
        const bytes = new Uint8Array(arrayBuffer);
        const result = [];
        for (let i = 0; i < bytes.length; i++) {
            result[i] = String.fromCharCode(bytes[i]);
        }
        return window.btoa(result.join(''));
    }
    function capitalize(word) {
        return word.charAt(0).toUpperCase() + word.substring(1);
    }
    function isLowerCase(c) {
        return c === c.toLowerCase() && c !== c.toUpperCase();
    }
    /**
     * Tries to find a code string for a given system within a given codeable concept.
     * @param concept The codeable concept.
     * @param system The system string.
     * @returns The code if found; otherwise undefined.
     */
    function getCodeBySystem(concept, system) {
        return concept?.coding?.find((coding) => coding.system === system)?.code;
    }
    /**
     * Sets a code for a given system within a given codeable concept.
     * @param concept The codeable concept.
     * @param system The system string.
     * @param code The code value.
     */
    function setCodeBySystem(concept, system, code) {
        if (!concept.coding) {
            concept.coding = [];
        }
        const coding = concept.coding?.find((c) => c.system === system);
        if (coding) {
            coding.code = code;
        }
        else {
            concept.coding?.push({ system, code });
        }
    }
    /**
     * Tries to find an observation interval for the given patient and value.
     * @param definition The observation definition.
     * @param patient The patient.
     * @param value The observation value.
     * @returns The observation interval if found; otherwise undefined.
     */
    function findObservationInterval(definition, patient, value, category) {
        return definition.qualifiedInterval?.find((interval) => observationIntervalMatchesPatient(interval, patient) &&
            observationIntervalMatchesValue(interval, value, definition.quantitativeDetails?.decimalPrecision) &&
            (category === undefined || interval.category === category));
    }
    /**
     * Tries to find an observation reference range for the given patient and condition names.
     * @param definition The observation definition.
     * @param patient The patient.
     * @param names The condition names.
     * @returns The observation interval if found; otherwise undefined.
     */
    function findObservationReferenceRange(definition, patient, names) {
        return definition.qualifiedInterval?.find((interval) => observationIntervalMatchesPatient(interval, patient) && names.includes(interval.condition));
    }
    /**
     * Returns true if the patient matches the observation interval.
     * @param interval The observation interval.
     * @param patient The patient.
     * @returns True if the patient matches the observation interval.
     */
    function observationIntervalMatchesPatient(interval, patient) {
        return observationIntervalMatchesGender(interval, patient) && observationIntervalMatchesAge(interval, patient);
    }
    /**
     * Returns true if the patient gender matches the observation interval.
     * @param interval The observation interval.
     * @param patient The patient.
     * @returns True if the patient gender matches the observation interval.
     */
    function observationIntervalMatchesGender(interval, patient) {
        return !interval.gender || interval.gender === patient.gender;
    }
    /**
     * Returns true if the patient age matches the observation interval.
     * @param interval The observation interval.
     * @param patient The patient.
     * @returns True if the patient age matches the observation interval.
     */
    function observationIntervalMatchesAge(interval, patient) {
        return !interval.age || matchesRange(calculateAge(patient.birthDate).years, interval.age);
    }
    /**
     * Returns true if the value matches the observation interval.
     * @param interval The observation interval.
     * @param value The observation value.
     * @param precision Optional precision in number of digits.
     * @returns True if the value matches the observation interval.
     */
    function observationIntervalMatchesValue(interval, value, precision) {
        return !!interval.range && matchesRange(value, interval.range, precision);
    }
    /**
     * Returns true if the value is in the range accounting for precision.
     * @param value The numeric value.
     * @param range The numeric range.
     * @param precision Optional precision in number of digits.
     * @returns True if the value is within the range.
     */
    function matchesRange(value, range, precision) {
        return ((range.low?.value === undefined || preciseGreaterThanOrEquals(value, range.low.value, precision)) &&
            (range.high?.value === undefined || preciseLessThanOrEquals(value, range.high.value, precision)));
    }
    /**
     * Returns the input number rounded to the specified number of digits.
     * @param a The input number.
     * @param precision The precision in number of digits.
     * @returns The number rounded to the specified number of digits.
     */
    function preciseRound(a, precision) {
        return parseFloat(a.toFixed(precision));
    }
    /**
     * Returns true if the two numbers are equal to the given precision.
     * @param a The first number.
     * @param b The second number.
     * @param precision Optional precision in number of digits.
     * @returns True if the two numbers are equal to the given precision.
     */
    function preciseEquals(a, b, precision) {
        return toPreciseInteger(a, precision) === toPreciseInteger(b, precision);
    }
    /**
     * Returns true if the first number is less than the second number to the given precision.
     * @param a The first number.
     * @param b The second number.
     * @param precision Optional precision in number of digits.
     * @returns True if the first number is less than the second number to the given precision.
     */
    function preciseLessThan(a, b, precision) {
        return toPreciseInteger(a, precision) < toPreciseInteger(b, precision);
    }
    /**
     * Returns true if the first number is greater than the second number to the given precision.
     * @param a The first number.
     * @param b The second number.
     * @param precision Optional precision in number of digits.
     * @returns True if the first number is greater than the second number to the given precision.
     */
    function preciseGreaterThan(a, b, precision) {
        return toPreciseInteger(a, precision) > toPreciseInteger(b, precision);
    }
    /**
     * Returns true if the first number is less than or equal to the second number to the given precision.
     * @param a The first number.
     * @param b The second number.
     * @param precision Optional precision in number of digits.
     * @returns True if the first number is less than or equal to the second number to the given precision.
     */
    function preciseLessThanOrEquals(a, b, precision) {
        return toPreciseInteger(a, precision) <= toPreciseInteger(b, precision);
    }
    /**
     * Returns true if the first number is greater than or equal to the second number to the given precision.
     * @param a The first number.
     * @param b The second number.
     * @param precision Optional precision in number of digits.
     * @returns True if the first number is greater than or equal to the second number to the given precision.
     */
    function preciseGreaterThanOrEquals(a, b, precision) {
        return toPreciseInteger(a, precision) >= toPreciseInteger(b, precision);
    }
    /**
     * Returns an integer representation of the number with the given precision.
     * For example, if precision is 2, then 1.2345 will be returned as 123.
     * @param a The number.
     * @param precision Optional precision in number of digits.
     * @returns The integer with the given precision.
     */
    function toPreciseInteger(a, precision) {
        if (precision === undefined) {
            return a;
        }
        return Math.round(a * Math.pow(10, precision));
    }

    /**
     * Returns a cryptographically secure random string.
     */
    function getRandomString() {
        const randomItems = new Uint32Array(28);
        crypto.getRandomValues(randomItems);
        return arrayBufferToHex(randomItems.buffer);
    }
    /**
     * Encrypts a string with SHA256 encryption.
     * @param str
     */
    async function encryptSHA256(str) {
        return crypto.subtle.digest('SHA-256', new TextEncoder().encode(str));
    }

    /*
     * Based on: https://developer.mozilla.org/en-US/docs/Web/API/EventTarget
     */
    var _EventTarget_listeners;
    class EventTarget {
        constructor() {
            _EventTarget_listeners.set(this, void 0);
            __classPrivateFieldSet(this, _EventTarget_listeners, {}, "f");
        }
        addEventListener(type, callback) {
            if (!__classPrivateFieldGet(this, _EventTarget_listeners, "f")[type]) {
                __classPrivateFieldGet(this, _EventTarget_listeners, "f")[type] = [];
            }
            __classPrivateFieldGet(this, _EventTarget_listeners, "f")[type].push(callback);
        }
        removeEventListeneer(type, callback) {
            const array = __classPrivateFieldGet(this, _EventTarget_listeners, "f")[type];
            if (!array) {
                return;
            }
            for (let i = 0; i < array.length; i++) {
                if (array[i] === callback) {
                    array.splice(i, 1);
                    return;
                }
            }
        }
        dispatchEvent(event) {
            const array = __classPrivateFieldGet(this, _EventTarget_listeners, "f")[event.type];
            if (array) {
                array.forEach((listener) => listener.call(this, event));
            }
            return !event.defaultPrevented;
        }
    }
    _EventTarget_listeners = new WeakMap();

    /**
     * Decodes a section of a JWT.
     * See: https://tools.ietf.org/html/rfc7519
     * @param payload
     */
    function decodePayload(payload) {
        const cleanedPayload = payload.replace(/-/g, '+').replace(/_/g, '/');
        const decodedPayload = decodeBase64(cleanedPayload);
        const uriEncodedPayload = Array.from(decodedPayload).reduce((acc, char) => {
            const uriEncodedChar = ('00' + char.charCodeAt(0).toString(16)).slice(-2);
            return `${acc}%${uriEncodedChar}`;
        }, '');
        const jsonPayload = decodeURIComponent(uriEncodedPayload);
        return JSON.parse(jsonPayload);
    }
    function decodeBase64(data) {
        if (typeof window !== 'undefined') {
            return window.atob(data);
        }
        if (typeof Buffer !== 'undefined') {
            return Buffer.from(data, 'base64').toString('binary');
        }
        throw new Error('Unable to decode base64');
    }
    /**
     * Parses the JWT payload.
     * @param token JWT token
     */
    function parseJWTPayload(token) {
        const [_header, payload, _signature] = token.split('.');
        return decodePayload(payload);
    }

    var _ReadablePromise_suspender, _ReadablePromise_status, _ReadablePromise_response, _ReadablePromise_error, _a;
    /**
     * The ReadablePromise class wraps a request promise suitable for React Suspense.
     * See: https://blog.logrocket.com/react-suspense-data-fetching/#wrappromise-js
     * See: https://github.com/ovieokeh/suspense-data-fetching/blob/master/lib/api/wrapPromise.js
     */
    class ReadablePromise {
        constructor(requestPromise) {
            this[_a] = 'ReadablePromise';
            _ReadablePromise_suspender.set(this, void 0);
            _ReadablePromise_status.set(this, 'pending');
            _ReadablePromise_response.set(this, void 0);
            _ReadablePromise_error.set(this, void 0);
            __classPrivateFieldSet(this, _ReadablePromise_suspender, requestPromise.then((res) => {
                __classPrivateFieldSet(this, _ReadablePromise_status, 'success', "f");
                __classPrivateFieldSet(this, _ReadablePromise_response, res, "f");
                return res;
            }, (err) => {
                __classPrivateFieldSet(this, _ReadablePromise_status, 'error', "f");
                __classPrivateFieldSet(this, _ReadablePromise_error, err, "f");
                throw err;
            }), "f");
        }
        /**
         * Returns true if the promise is pending.
         * @returns True if the Promise is pending.
         */
        isPending() {
            return __classPrivateFieldGet(this, _ReadablePromise_status, "f") === 'pending';
        }
        /**
         * Returns true if the promise resolved successfully.
         * @returns True if the Promise resolved successfully.
         */
        isOk() {
            return __classPrivateFieldGet(this, _ReadablePromise_status, "f") === 'success';
        }
        /**
         * Attempts to read the value of the promise.
         * If the promise is pending, this method will throw a promise.
         * If the promise rejected, this method will throw the rejection reason.
         * If the promise resolved, this method will return the resolved value.
         * @returns The resolved value of the Promise.
         */
        read() {
            switch (__classPrivateFieldGet(this, _ReadablePromise_status, "f")) {
                case 'pending':
                    throw __classPrivateFieldGet(this, _ReadablePromise_suspender, "f");
                case 'error':
                    throw __classPrivateFieldGet(this, _ReadablePromise_error, "f");
                default:
                    return __classPrivateFieldGet(this, _ReadablePromise_response, "f");
            }
        }
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then(onfulfilled, onrejected) {
            return __classPrivateFieldGet(this, _ReadablePromise_suspender, "f").then(onfulfilled, onrejected);
        }
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch(onrejected) {
            return __classPrivateFieldGet(this, _ReadablePromise_suspender, "f").catch(onrejected);
        }
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally) {
            return __classPrivateFieldGet(this, _ReadablePromise_suspender, "f").finally(onfinally);
        }
    }
    _ReadablePromise_suspender = new WeakMap(), _ReadablePromise_status = new WeakMap(), _ReadablePromise_response = new WeakMap(), _ReadablePromise_error = new WeakMap(), _a = Symbol.toStringTag;

    var _ClientStorage_storage, _MemoryStorage_data;
    /**
     * The ClientStorage class is a utility class for storing strings and objects.
     *
     * When using MedplumClient in the browser, it will be backed by browser localStorage.
     *
     * When Using MedplumClient in the server, it will be backed by the MemoryStorage class.
     */
    class ClientStorage {
        constructor() {
            _ClientStorage_storage.set(this, void 0);
            __classPrivateFieldSet(this, _ClientStorage_storage, typeof localStorage !== 'undefined' ? localStorage : new MemoryStorage(), "f");
        }
        clear() {
            __classPrivateFieldGet(this, _ClientStorage_storage, "f").clear();
        }
        getString(key) {
            return __classPrivateFieldGet(this, _ClientStorage_storage, "f").getItem(key) || undefined;
        }
        setString(key, value) {
            if (value) {
                __classPrivateFieldGet(this, _ClientStorage_storage, "f").setItem(key, value);
            }
            else {
                __classPrivateFieldGet(this, _ClientStorage_storage, "f").removeItem(key);
            }
        }
        getObject(key) {
            const str = this.getString(key);
            return str ? JSON.parse(str) : undefined;
        }
        setObject(key, value) {
            this.setString(key, value ? stringify(value) : undefined);
        }
    }
    _ClientStorage_storage = new WeakMap();
    /**
     * The MemoryStorage class is a minimal in-memory implementation of the Storage interface.
     */
    class MemoryStorage {
        constructor() {
            _MemoryStorage_data.set(this, void 0);
            __classPrivateFieldSet(this, _MemoryStorage_data, new Map(), "f");
        }
        /**
         * Returns the number of key/value pairs.
         */
        get length() {
            return __classPrivateFieldGet(this, _MemoryStorage_data, "f").size;
        }
        /**
         * Removes all key/value pairs, if there are any.
         */
        clear() {
            __classPrivateFieldGet(this, _MemoryStorage_data, "f").clear();
        }
        /**
         * Returns the current value associated with the given key, or null if the given key does not exist.
         */
        getItem(key) {
            return __classPrivateFieldGet(this, _MemoryStorage_data, "f").get(key) ?? null;
        }
        /**
         * Sets the value of the pair identified by key to value, creating a new key/value pair if none existed for key previously.
         */
        setItem(key, value) {
            if (value) {
                __classPrivateFieldGet(this, _MemoryStorage_data, "f").set(key, value);
            }
            else {
                __classPrivateFieldGet(this, _MemoryStorage_data, "f").delete(key);
            }
        }
        /**
         * Removes the key/value pair with the given key, if a key/value pair with the given key exists.
         */
        removeItem(key) {
            __classPrivateFieldGet(this, _MemoryStorage_data, "f").delete(key);
        }
        /**
         * Returns the name of the nth key, or null if n is greater than or equal to the number of key/value pairs.
         */
        key(index) {
            return Array.from(__classPrivateFieldGet(this, _MemoryStorage_data, "f").keys())[index];
        }
    }
    _MemoryStorage_data = new WeakMap();

    var types = {
    	Element: {
    		display: "Element",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			}
    		}
    	},
    	BackboneElement: {
    		display: "BackboneElement",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			modifierExtension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			}
    		}
    	},
    	Address: {
    		display: "Address",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			use: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			type: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			text: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			line: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			city: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			district: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			state: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			postalCode: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			country: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			period: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Period"
    					}
    				]
    			}
    		}
    	},
    	Age: {
    		display: "Age",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			value: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "decimal"
    					}
    				]
    			},
    			comparator: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			unit: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			system: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "uri"
    					}
    				]
    			},
    			code: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			}
    		}
    	},
    	Annotation: {
    		display: "Annotation",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			"author[x]": {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Reference",
    						targetProfile: [
    							"http://hl7.org/fhir/StructureDefinition/Practitioner",
    							"http://hl7.org/fhir/StructureDefinition/Patient",
    							"http://hl7.org/fhir/StructureDefinition/RelatedPerson",
    							"http://hl7.org/fhir/StructureDefinition/Organization"
    						]
    					},
    					{
    						code: "string"
    					}
    				]
    			},
    			time: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "dateTime"
    					}
    				]
    			},
    			text: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "markdown"
    					}
    				]
    			}
    		}
    	},
    	Attachment: {
    		display: "Attachment",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			contentType: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			language: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			data: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "base64Binary"
    					}
    				]
    			},
    			url: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "url"
    					}
    				]
    			},
    			size: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "unsignedInt"
    					}
    				]
    			},
    			hash: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "base64Binary"
    					}
    				]
    			},
    			title: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			creation: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "dateTime"
    					}
    				]
    			}
    		}
    	},
    	CodeableConcept: {
    		display: "CodeableConcept",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			coding: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Coding"
    					}
    				]
    			},
    			text: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			}
    		}
    	},
    	Coding: {
    		display: "Coding",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			system: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "uri"
    					}
    				]
    			},
    			version: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			code: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			display: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			userSelected: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "boolean"
    					}
    				]
    			}
    		}
    	},
    	ContactDetail: {
    		display: "ContactDetail",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			name: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			telecom: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "ContactPoint"
    					}
    				]
    			}
    		}
    	},
    	ContactPoint: {
    		display: "ContactPoint",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			system: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			value: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			use: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			rank: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "positiveInt"
    					}
    				]
    			},
    			period: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Period"
    					}
    				]
    			}
    		}
    	},
    	Contributor: {
    		display: "Contributor",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			type: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			name: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			contact: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "ContactDetail"
    					}
    				]
    			}
    		}
    	},
    	Count: {
    		display: "Count",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			value: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "decimal"
    					}
    				]
    			},
    			comparator: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			unit: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			system: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "uri"
    					}
    				]
    			},
    			code: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			}
    		}
    	},
    	DataRequirement: {
    		display: "DataRequirement",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			type: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			profile: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "canonical",
    						targetProfile: [
    							"http://hl7.org/fhir/StructureDefinition/StructureDefinition"
    						]
    					}
    				]
    			},
    			"subject[x]": {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "CodeableConcept"
    					},
    					{
    						code: "Reference",
    						targetProfile: [
    							"http://hl7.org/fhir/StructureDefinition/Group"
    						]
    					}
    				]
    			},
    			mustSupport: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			codeFilter: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Element"
    					}
    				]
    			},
    			dateFilter: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Element"
    					}
    				]
    			},
    			limit: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "positiveInt"
    					}
    				]
    			},
    			sort: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Element"
    					}
    				]
    			}
    		}
    	},
    	DataRequirementCodeFilter: {
    		display: "DataRequirementCodeFilter",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			path: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			searchParam: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			valueSet: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "canonical",
    						targetProfile: [
    							"http://hl7.org/fhir/StructureDefinition/ValueSet"
    						]
    					}
    				]
    			},
    			code: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Coding"
    					}
    				]
    			}
    		},
    		parentType: "DataRequirement"
    	},
    	DataRequirementDateFilter: {
    		display: "DataRequirementDateFilter",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			path: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			searchParam: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			"value[x]": {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "dateTime"
    					},
    					{
    						code: "Period"
    					},
    					{
    						code: "Duration"
    					}
    				]
    			}
    		},
    		parentType: "DataRequirement"
    	},
    	DataRequirementSort: {
    		display: "DataRequirementSort",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			path: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			direction: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			}
    		},
    		parentType: "DataRequirement"
    	},
    	Distance: {
    		display: "Distance",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			value: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "decimal"
    					}
    				]
    			},
    			comparator: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			unit: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			system: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "uri"
    					}
    				]
    			},
    			code: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			}
    		}
    	},
    	Dosage: {
    		display: "Dosage",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			modifierExtension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			sequence: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "integer"
    					}
    				]
    			},
    			text: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			additionalInstruction: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "CodeableConcept"
    					}
    				]
    			},
    			patientInstruction: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			timing: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Timing"
    					}
    				]
    			},
    			"asNeeded[x]": {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "boolean"
    					},
    					{
    						code: "CodeableConcept"
    					}
    				]
    			},
    			site: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "CodeableConcept"
    					}
    				]
    			},
    			route: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "CodeableConcept"
    					}
    				]
    			},
    			method: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "CodeableConcept"
    					}
    				]
    			},
    			doseAndRate: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Element"
    					}
    				]
    			},
    			maxDosePerPeriod: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Ratio"
    					}
    				]
    			},
    			maxDosePerAdministration: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Quantity",
    						profile: [
    							"http://hl7.org/fhir/StructureDefinition/SimpleQuantity"
    						]
    					}
    				]
    			},
    			maxDosePerLifetime: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Quantity",
    						profile: [
    							"http://hl7.org/fhir/StructureDefinition/SimpleQuantity"
    						]
    					}
    				]
    			}
    		}
    	},
    	DosageDoseAndRate: {
    		display: "DosageDoseAndRate",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			type: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "CodeableConcept"
    					}
    				]
    			},
    			"dose[x]": {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Range"
    					},
    					{
    						code: "Quantity",
    						profile: [
    							"http://hl7.org/fhir/StructureDefinition/SimpleQuantity"
    						]
    					}
    				]
    			},
    			"rate[x]": {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Ratio"
    					},
    					{
    						code: "Range"
    					},
    					{
    						code: "Quantity",
    						profile: [
    							"http://hl7.org/fhir/StructureDefinition/SimpleQuantity"
    						]
    					}
    				]
    			}
    		},
    		parentType: "Dosage"
    	},
    	Duration: {
    		display: "Duration",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			value: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "decimal"
    					}
    				]
    			},
    			comparator: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			unit: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			system: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "uri"
    					}
    				]
    			},
    			code: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			}
    		}
    	},
    	ElementDefinition: {
    		display: "ElementDefinition",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			modifierExtension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			path: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			representation: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			sliceName: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			sliceIsConstraining: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "boolean"
    					}
    				]
    			},
    			label: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			code: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Coding"
    					}
    				]
    			},
    			slicing: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Element"
    					}
    				]
    			},
    			short: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			definition: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "markdown"
    					}
    				]
    			},
    			comment: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "markdown"
    					}
    				]
    			},
    			requirements: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "markdown"
    					}
    				]
    			},
    			alias: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			min: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "unsignedInt"
    					}
    				]
    			},
    			max: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			base: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Element"
    					}
    				]
    			},
    			contentReference: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "uri"
    					}
    				]
    			},
    			type: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Element"
    					}
    				]
    			},
    			"defaultValue[x]": {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "base64Binary"
    					},
    					{
    						code: "boolean"
    					},
    					{
    						code: "canonical"
    					},
    					{
    						code: "code"
    					},
    					{
    						code: "date"
    					},
    					{
    						code: "dateTime"
    					},
    					{
    						code: "decimal"
    					},
    					{
    						code: "id"
    					},
    					{
    						code: "instant"
    					},
    					{
    						code: "integer"
    					},
    					{
    						code: "markdown"
    					},
    					{
    						code: "oid"
    					},
    					{
    						code: "positiveInt"
    					},
    					{
    						code: "string"
    					},
    					{
    						code: "time"
    					},
    					{
    						code: "unsignedInt"
    					},
    					{
    						code: "uri"
    					},
    					{
    						code: "url"
    					},
    					{
    						code: "uuid"
    					},
    					{
    						code: "Address"
    					},
    					{
    						code: "Age"
    					},
    					{
    						code: "Annotation"
    					},
    					{
    						code: "Attachment"
    					},
    					{
    						code: "CodeableConcept"
    					},
    					{
    						code: "Coding"
    					},
    					{
    						code: "ContactPoint"
    					},
    					{
    						code: "Count"
    					},
    					{
    						code: "Distance"
    					},
    					{
    						code: "Duration"
    					},
    					{
    						code: "HumanName"
    					},
    					{
    						code: "Identifier"
    					},
    					{
    						code: "Money"
    					},
    					{
    						code: "Period"
    					},
    					{
    						code: "Quantity"
    					},
    					{
    						code: "Range"
    					},
    					{
    						code: "Ratio"
    					},
    					{
    						code: "Reference"
    					},
    					{
    						code: "SampledData"
    					},
    					{
    						code: "Signature"
    					},
    					{
    						code: "Timing"
    					},
    					{
    						code: "ContactDetail"
    					},
    					{
    						code: "Contributor"
    					},
    					{
    						code: "DataRequirement"
    					},
    					{
    						code: "Expression"
    					},
    					{
    						code: "ParameterDefinition"
    					},
    					{
    						code: "RelatedArtifact"
    					},
    					{
    						code: "TriggerDefinition"
    					},
    					{
    						code: "UsageContext"
    					},
    					{
    						code: "Dosage"
    					},
    					{
    						code: "Meta"
    					}
    				]
    			},
    			meaningWhenMissing: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "markdown"
    					}
    				]
    			},
    			orderMeaning: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			"fixed[x]": {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "base64Binary"
    					},
    					{
    						code: "boolean"
    					},
    					{
    						code: "canonical"
    					},
    					{
    						code: "code"
    					},
    					{
    						code: "date"
    					},
    					{
    						code: "dateTime"
    					},
    					{
    						code: "decimal"
    					},
    					{
    						code: "id"
    					},
    					{
    						code: "instant"
    					},
    					{
    						code: "integer"
    					},
    					{
    						code: "markdown"
    					},
    					{
    						code: "oid"
    					},
    					{
    						code: "positiveInt"
    					},
    					{
    						code: "string"
    					},
    					{
    						code: "time"
    					},
    					{
    						code: "unsignedInt"
    					},
    					{
    						code: "uri"
    					},
    					{
    						code: "url"
    					},
    					{
    						code: "uuid"
    					},
    					{
    						code: "Address"
    					},
    					{
    						code: "Age"
    					},
    					{
    						code: "Annotation"
    					},
    					{
    						code: "Attachment"
    					},
    					{
    						code: "CodeableConcept"
    					},
    					{
    						code: "Coding"
    					},
    					{
    						code: "ContactPoint"
    					},
    					{
    						code: "Count"
    					},
    					{
    						code: "Distance"
    					},
    					{
    						code: "Duration"
    					},
    					{
    						code: "HumanName"
    					},
    					{
    						code: "Identifier"
    					},
    					{
    						code: "Money"
    					},
    					{
    						code: "Period"
    					},
    					{
    						code: "Quantity"
    					},
    					{
    						code: "Range"
    					},
    					{
    						code: "Ratio"
    					},
    					{
    						code: "Reference"
    					},
    					{
    						code: "SampledData"
    					},
    					{
    						code: "Signature"
    					},
    					{
    						code: "Timing"
    					},
    					{
    						code: "ContactDetail"
    					},
    					{
    						code: "Contributor"
    					},
    					{
    						code: "DataRequirement"
    					},
    					{
    						code: "Expression"
    					},
    					{
    						code: "ParameterDefinition"
    					},
    					{
    						code: "RelatedArtifact"
    					},
    					{
    						code: "TriggerDefinition"
    					},
    					{
    						code: "UsageContext"
    					},
    					{
    						code: "Dosage"
    					},
    					{
    						code: "Meta"
    					}
    				]
    			},
    			"pattern[x]": {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "base64Binary"
    					},
    					{
    						code: "boolean"
    					},
    					{
    						code: "canonical"
    					},
    					{
    						code: "code"
    					},
    					{
    						code: "date"
    					},
    					{
    						code: "dateTime"
    					},
    					{
    						code: "decimal"
    					},
    					{
    						code: "id"
    					},
    					{
    						code: "instant"
    					},
    					{
    						code: "integer"
    					},
    					{
    						code: "markdown"
    					},
    					{
    						code: "oid"
    					},
    					{
    						code: "positiveInt"
    					},
    					{
    						code: "string"
    					},
    					{
    						code: "time"
    					},
    					{
    						code: "unsignedInt"
    					},
    					{
    						code: "uri"
    					},
    					{
    						code: "url"
    					},
    					{
    						code: "uuid"
    					},
    					{
    						code: "Address"
    					},
    					{
    						code: "Age"
    					},
    					{
    						code: "Annotation"
    					},
    					{
    						code: "Attachment"
    					},
    					{
    						code: "CodeableConcept"
    					},
    					{
    						code: "Coding"
    					},
    					{
    						code: "ContactPoint"
    					},
    					{
    						code: "Count"
    					},
    					{
    						code: "Distance"
    					},
    					{
    						code: "Duration"
    					},
    					{
    						code: "HumanName"
    					},
    					{
    						code: "Identifier"
    					},
    					{
    						code: "Money"
    					},
    					{
    						code: "Period"
    					},
    					{
    						code: "Quantity"
    					},
    					{
    						code: "Range"
    					},
    					{
    						code: "Ratio"
    					},
    					{
    						code: "Reference"
    					},
    					{
    						code: "SampledData"
    					},
    					{
    						code: "Signature"
    					},
    					{
    						code: "Timing"
    					},
    					{
    						code: "ContactDetail"
    					},
    					{
    						code: "Contributor"
    					},
    					{
    						code: "DataRequirement"
    					},
    					{
    						code: "Expression"
    					},
    					{
    						code: "ParameterDefinition"
    					},
    					{
    						code: "RelatedArtifact"
    					},
    					{
    						code: "TriggerDefinition"
    					},
    					{
    						code: "UsageContext"
    					},
    					{
    						code: "Dosage"
    					},
    					{
    						code: "Meta"
    					}
    				]
    			},
    			example: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Element"
    					}
    				]
    			},
    			"minValue[x]": {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "date"
    					},
    					{
    						code: "dateTime"
    					},
    					{
    						code: "instant"
    					},
    					{
    						code: "time"
    					},
    					{
    						code: "decimal"
    					},
    					{
    						code: "integer"
    					},
    					{
    						code: "positiveInt"
    					},
    					{
    						code: "unsignedInt"
    					},
    					{
    						code: "Quantity"
    					}
    				]
    			},
    			"maxValue[x]": {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "date"
    					},
    					{
    						code: "dateTime"
    					},
    					{
    						code: "instant"
    					},
    					{
    						code: "time"
    					},
    					{
    						code: "decimal"
    					},
    					{
    						code: "integer"
    					},
    					{
    						code: "positiveInt"
    					},
    					{
    						code: "unsignedInt"
    					},
    					{
    						code: "Quantity"
    					}
    				]
    			},
    			maxLength: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "integer"
    					}
    				]
    			},
    			condition: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "id"
    					}
    				]
    			},
    			constraint: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Element"
    					}
    				]
    			},
    			mustSupport: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "boolean"
    					}
    				]
    			},
    			isModifier: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "boolean"
    					}
    				]
    			},
    			isModifierReason: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			isSummary: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "boolean"
    					}
    				]
    			},
    			binding: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Element"
    					}
    				]
    			},
    			mapping: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Element"
    					}
    				]
    			}
    		}
    	},
    	ElementDefinitionSlicing: {
    		display: "ElementDefinitionSlicing",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			discriminator: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Element"
    					}
    				]
    			},
    			description: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			ordered: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "boolean"
    					}
    				]
    			},
    			rules: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			}
    		},
    		parentType: "ElementDefinition"
    	},
    	ElementDefinitionSlicingDiscriminator: {
    		display: "ElementDefinitionSlicingDiscriminator",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			type: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			path: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			}
    		},
    		parentType: "ElementDefinitionSlicing"
    	},
    	ElementDefinitionBase: {
    		display: "ElementDefinitionBase",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			path: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			min: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "unsignedInt"
    					}
    				]
    			},
    			max: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			}
    		},
    		parentType: "ElementDefinition"
    	},
    	ElementDefinitionType: {
    		display: "ElementDefinitionType",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			code: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "uri"
    					}
    				]
    			},
    			profile: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "canonical",
    						targetProfile: [
    							"http://hl7.org/fhir/StructureDefinition/StructureDefinition",
    							"http://hl7.org/fhir/StructureDefinition/ImplementationGuide"
    						]
    					}
    				]
    			},
    			targetProfile: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "canonical",
    						targetProfile: [
    							"http://hl7.org/fhir/StructureDefinition/StructureDefinition",
    							"http://hl7.org/fhir/StructureDefinition/ImplementationGuide"
    						]
    					}
    				]
    			},
    			aggregation: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			versioning: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			}
    		},
    		parentType: "ElementDefinition"
    	},
    	ElementDefinitionExample: {
    		display: "ElementDefinitionExample",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			label: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			"value[x]": {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "base64Binary"
    					},
    					{
    						code: "boolean"
    					},
    					{
    						code: "canonical"
    					},
    					{
    						code: "code"
    					},
    					{
    						code: "date"
    					},
    					{
    						code: "dateTime"
    					},
    					{
    						code: "decimal"
    					},
    					{
    						code: "id"
    					},
    					{
    						code: "instant"
    					},
    					{
    						code: "integer"
    					},
    					{
    						code: "markdown"
    					},
    					{
    						code: "oid"
    					},
    					{
    						code: "positiveInt"
    					},
    					{
    						code: "string"
    					},
    					{
    						code: "time"
    					},
    					{
    						code: "unsignedInt"
    					},
    					{
    						code: "uri"
    					},
    					{
    						code: "url"
    					},
    					{
    						code: "uuid"
    					},
    					{
    						code: "Address"
    					},
    					{
    						code: "Age"
    					},
    					{
    						code: "Annotation"
    					},
    					{
    						code: "Attachment"
    					},
    					{
    						code: "CodeableConcept"
    					},
    					{
    						code: "Coding"
    					},
    					{
    						code: "ContactPoint"
    					},
    					{
    						code: "Count"
    					},
    					{
    						code: "Distance"
    					},
    					{
    						code: "Duration"
    					},
    					{
    						code: "HumanName"
    					},
    					{
    						code: "Identifier"
    					},
    					{
    						code: "Money"
    					},
    					{
    						code: "Period"
    					},
    					{
    						code: "Quantity"
    					},
    					{
    						code: "Range"
    					},
    					{
    						code: "Ratio"
    					},
    					{
    						code: "Reference"
    					},
    					{
    						code: "SampledData"
    					},
    					{
    						code: "Signature"
    					},
    					{
    						code: "Timing"
    					},
    					{
    						code: "ContactDetail"
    					},
    					{
    						code: "Contributor"
    					},
    					{
    						code: "DataRequirement"
    					},
    					{
    						code: "Expression"
    					},
    					{
    						code: "ParameterDefinition"
    					},
    					{
    						code: "RelatedArtifact"
    					},
    					{
    						code: "TriggerDefinition"
    					},
    					{
    						code: "UsageContext"
    					},
    					{
    						code: "Dosage"
    					},
    					{
    						code: "Meta"
    					}
    				]
    			}
    		},
    		parentType: "ElementDefinition"
    	},
    	ElementDefinitionConstraint: {
    		display: "ElementDefinitionConstraint",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			key: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "id"
    					}
    				]
    			},
    			requirements: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			severity: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			human: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			expression: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			xpath: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			source: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "canonical",
    						targetProfile: [
    							"http://hl7.org/fhir/StructureDefinition/StructureDefinition"
    						]
    					}
    				]
    			}
    		},
    		parentType: "ElementDefinition"
    	},
    	ElementDefinitionBinding: {
    		display: "ElementDefinitionBinding",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			strength: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			description: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			valueSet: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "canonical",
    						targetProfile: [
    							"http://hl7.org/fhir/StructureDefinition/ValueSet"
    						]
    					}
    				]
    			}
    		},
    		parentType: "ElementDefinition"
    	},
    	ElementDefinitionMapping: {
    		display: "ElementDefinitionMapping",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			identity: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "id"
    					}
    				]
    			},
    			language: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			map: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			comment: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			}
    		},
    		parentType: "ElementDefinition"
    	},
    	Expression: {
    		display: "Expression",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			description: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			name: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "id"
    					}
    				]
    			},
    			language: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			expression: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			reference: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "uri"
    					}
    				]
    			}
    		}
    	},
    	Extension: {
    		display: "Extension",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			url: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			"value[x]": {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "base64Binary"
    					},
    					{
    						code: "boolean"
    					},
    					{
    						code: "canonical"
    					},
    					{
    						code: "code"
    					},
    					{
    						code: "date"
    					},
    					{
    						code: "dateTime"
    					},
    					{
    						code: "decimal"
    					},
    					{
    						code: "id"
    					},
    					{
    						code: "instant"
    					},
    					{
    						code: "integer"
    					},
    					{
    						code: "markdown"
    					},
    					{
    						code: "oid"
    					},
    					{
    						code: "positiveInt"
    					},
    					{
    						code: "string"
    					},
    					{
    						code: "time"
    					},
    					{
    						code: "unsignedInt"
    					},
    					{
    						code: "uri"
    					},
    					{
    						code: "url"
    					},
    					{
    						code: "uuid"
    					},
    					{
    						code: "Address"
    					},
    					{
    						code: "Age"
    					},
    					{
    						code: "Annotation"
    					},
    					{
    						code: "Attachment"
    					},
    					{
    						code: "CodeableConcept"
    					},
    					{
    						code: "Coding"
    					},
    					{
    						code: "ContactPoint"
    					},
    					{
    						code: "Count"
    					},
    					{
    						code: "Distance"
    					},
    					{
    						code: "Duration"
    					},
    					{
    						code: "HumanName"
    					},
    					{
    						code: "Identifier"
    					},
    					{
    						code: "Money"
    					},
    					{
    						code: "Period"
    					},
    					{
    						code: "Quantity"
    					},
    					{
    						code: "Range"
    					},
    					{
    						code: "Ratio"
    					},
    					{
    						code: "Reference"
    					},
    					{
    						code: "SampledData"
    					},
    					{
    						code: "Signature"
    					},
    					{
    						code: "Timing"
    					},
    					{
    						code: "ContactDetail"
    					},
    					{
    						code: "Contributor"
    					},
    					{
    						code: "DataRequirement"
    					},
    					{
    						code: "Expression"
    					},
    					{
    						code: "ParameterDefinition"
    					},
    					{
    						code: "RelatedArtifact"
    					},
    					{
    						code: "TriggerDefinition"
    					},
    					{
    						code: "UsageContext"
    					},
    					{
    						code: "Dosage"
    					},
    					{
    						code: "Meta"
    					}
    				]
    			}
    		}
    	},
    	HumanName: {
    		display: "HumanName",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			use: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			text: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			family: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			given: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			prefix: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			suffix: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			period: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Period"
    					}
    				]
    			}
    		}
    	},
    	Identifier: {
    		display: "Identifier",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			use: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			type: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "CodeableConcept"
    					}
    				]
    			},
    			system: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "uri"
    					}
    				]
    			},
    			value: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			period: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Period"
    					}
    				]
    			},
    			assigner: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Reference",
    						targetProfile: [
    							"http://hl7.org/fhir/StructureDefinition/Organization"
    						]
    					}
    				]
    			}
    		}
    	},
    	MarketingStatus: {
    		display: "MarketingStatus",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			modifierExtension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			country: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "CodeableConcept"
    					}
    				]
    			},
    			jurisdiction: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "CodeableConcept"
    					}
    				]
    			},
    			status: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "CodeableConcept"
    					}
    				]
    			},
    			dateRange: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "Period"
    					}
    				]
    			},
    			restoreDate: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "dateTime"
    					}
    				]
    			}
    		}
    	},
    	Meta: {
    		display: "Meta",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			versionId: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "id"
    					}
    				]
    			},
    			lastUpdated: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "instant"
    					}
    				]
    			},
    			source: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "uri"
    					}
    				]
    			},
    			profile: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "canonical",
    						targetProfile: [
    							"http://hl7.org/fhir/StructureDefinition/StructureDefinition"
    						]
    					}
    				]
    			},
    			security: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Coding"
    					}
    				]
    			},
    			tag: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Coding"
    					}
    				]
    			},
    			project: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "uri"
    					}
    				]
    			},
    			author: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Reference"
    					}
    				]
    			},
    			account: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Reference"
    					}
    				]
    			}
    		}
    	},
    	Money: {
    		display: "Money",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			value: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "decimal"
    					}
    				]
    			},
    			currency: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			}
    		}
    	},
    	Narrative: {
    		display: "Narrative",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			status: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			div: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "xhtml"
    					}
    				]
    			}
    		}
    	},
    	ParameterDefinition: {
    		display: "ParameterDefinition",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			name: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			use: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			min: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "integer"
    					}
    				]
    			},
    			max: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			documentation: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			type: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			profile: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "canonical",
    						targetProfile: [
    							"http://hl7.org/fhir/StructureDefinition/StructureDefinition"
    						]
    					}
    				]
    			}
    		}
    	},
    	Period: {
    		display: "Period",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			start: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "dateTime"
    					}
    				]
    			},
    			end: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "dateTime"
    					}
    				]
    			}
    		}
    	},
    	Population: {
    		display: "Population",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			modifierExtension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			"age[x]": {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Range"
    					},
    					{
    						code: "CodeableConcept"
    					}
    				]
    			},
    			gender: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "CodeableConcept"
    					}
    				]
    			},
    			race: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "CodeableConcept"
    					}
    				]
    			},
    			physiologicalCondition: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "CodeableConcept"
    					}
    				]
    			}
    		}
    	},
    	ProdCharacteristic: {
    		display: "ProdCharacteristic",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			modifierExtension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			height: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Quantity"
    					}
    				]
    			},
    			width: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Quantity"
    					}
    				]
    			},
    			depth: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Quantity"
    					}
    				]
    			},
    			weight: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Quantity"
    					}
    				]
    			},
    			nominalVolume: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Quantity"
    					}
    				]
    			},
    			externalDiameter: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Quantity"
    					}
    				]
    			},
    			shape: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			color: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			imprint: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			image: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Attachment"
    					}
    				]
    			},
    			scoring: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "CodeableConcept"
    					}
    				]
    			}
    		}
    	},
    	ProductShelfLife: {
    		display: "ProductShelfLife",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			modifierExtension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			identifier: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Identifier"
    					}
    				]
    			},
    			type: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "CodeableConcept"
    					}
    				]
    			},
    			period: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "Quantity"
    					}
    				]
    			},
    			specialPrecautionsForStorage: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "CodeableConcept"
    					}
    				]
    			}
    		}
    	},
    	Quantity: {
    		display: "Quantity",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			value: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "decimal"
    					}
    				]
    			},
    			comparator: {
    				min: 0,
    				max: "0",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			unit: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			system: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "uri"
    					}
    				]
    			},
    			code: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			}
    		}
    	},
    	Range: {
    		display: "Range",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			low: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Quantity",
    						profile: [
    							"http://hl7.org/fhir/StructureDefinition/SimpleQuantity"
    						]
    					}
    				]
    			},
    			high: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Quantity",
    						profile: [
    							"http://hl7.org/fhir/StructureDefinition/SimpleQuantity"
    						]
    					}
    				]
    			}
    		}
    	},
    	Ratio: {
    		display: "Ratio",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			numerator: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Quantity"
    					}
    				]
    			},
    			denominator: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Quantity"
    					}
    				]
    			}
    		}
    	},
    	Reference: {
    		display: "Reference",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			reference: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			type: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "uri"
    					}
    				]
    			},
    			identifier: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Identifier"
    					}
    				]
    			},
    			display: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			}
    		}
    	},
    	RelatedArtifact: {
    		display: "RelatedArtifact",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			type: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			label: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			display: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			citation: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "markdown"
    					}
    				]
    			},
    			url: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "url"
    					}
    				]
    			},
    			document: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Attachment"
    					}
    				]
    			},
    			resource: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "canonical",
    						targetProfile: [
    							"http://hl7.org/fhir/StructureDefinition/Resource"
    						]
    					}
    				]
    			}
    		}
    	},
    	SampledData: {
    		display: "SampledData",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			origin: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "Quantity",
    						profile: [
    							"http://hl7.org/fhir/StructureDefinition/SimpleQuantity"
    						]
    					}
    				]
    			},
    			period: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "decimal"
    					}
    				]
    			},
    			factor: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "decimal"
    					}
    				]
    			},
    			lowerLimit: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "decimal"
    					}
    				]
    			},
    			upperLimit: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "decimal"
    					}
    				]
    			},
    			dimensions: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "positiveInt"
    					}
    				]
    			},
    			data: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			}
    		}
    	},
    	Signature: {
    		display: "Signature",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			type: {
    				min: 1,
    				max: "*",
    				type: [
    					{
    						code: "Coding"
    					}
    				]
    			},
    			when: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "instant"
    					}
    				]
    			},
    			who: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "Reference",
    						targetProfile: [
    							"http://hl7.org/fhir/StructureDefinition/Practitioner",
    							"http://hl7.org/fhir/StructureDefinition/PractitionerRole",
    							"http://hl7.org/fhir/StructureDefinition/RelatedPerson",
    							"http://hl7.org/fhir/StructureDefinition/Patient",
    							"http://hl7.org/fhir/StructureDefinition/Device",
    							"http://hl7.org/fhir/StructureDefinition/Organization"
    						]
    					}
    				]
    			},
    			onBehalfOf: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Reference",
    						targetProfile: [
    							"http://hl7.org/fhir/StructureDefinition/Practitioner",
    							"http://hl7.org/fhir/StructureDefinition/PractitionerRole",
    							"http://hl7.org/fhir/StructureDefinition/RelatedPerson",
    							"http://hl7.org/fhir/StructureDefinition/Patient",
    							"http://hl7.org/fhir/StructureDefinition/Device",
    							"http://hl7.org/fhir/StructureDefinition/Organization"
    						]
    					}
    				]
    			},
    			targetFormat: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			sigFormat: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			data: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "base64Binary"
    					}
    				]
    			}
    		}
    	},
    	SubstanceAmount: {
    		display: "SubstanceAmount",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			modifierExtension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			"amount[x]": {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Quantity"
    					},
    					{
    						code: "Range"
    					},
    					{
    						code: "string"
    					}
    				]
    			},
    			amountType: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "CodeableConcept"
    					}
    				]
    			},
    			amountText: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			referenceRange: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Element"
    					}
    				]
    			}
    		}
    	},
    	SubstanceAmountReferenceRange: {
    		display: "SubstanceAmountReferenceRange",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			lowLimit: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Quantity"
    					}
    				]
    			},
    			highLimit: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Quantity"
    					}
    				]
    			}
    		},
    		parentType: "SubstanceAmount"
    	},
    	Timing: {
    		display: "Timing",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			modifierExtension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			event: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "dateTime"
    					}
    				]
    			},
    			repeat: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Element"
    					}
    				]
    			},
    			code: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "CodeableConcept"
    					}
    				]
    			}
    		}
    	},
    	TimingRepeat: {
    		display: "TimingRepeat",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			"bounds[x]": {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Duration"
    					},
    					{
    						code: "Range"
    					},
    					{
    						code: "Period"
    					}
    				]
    			},
    			count: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "positiveInt"
    					}
    				]
    			},
    			countMax: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "positiveInt"
    					}
    				]
    			},
    			duration: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "decimal"
    					}
    				]
    			},
    			durationMax: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "decimal"
    					}
    				]
    			},
    			durationUnit: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			frequency: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "positiveInt"
    					}
    				]
    			},
    			frequencyMax: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "positiveInt"
    					}
    				]
    			},
    			period: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "decimal"
    					}
    				]
    			},
    			periodMax: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "decimal"
    					}
    				]
    			},
    			periodUnit: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			dayOfWeek: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			timeOfDay: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "time"
    					}
    				]
    			},
    			when: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			offset: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "unsignedInt"
    					}
    				]
    			}
    		},
    		parentType: "Timing"
    	},
    	TriggerDefinition: {
    		display: "TriggerDefinition",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			type: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "code"
    					}
    				]
    			},
    			name: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			"timing[x]": {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Timing"
    					},
    					{
    						code: "Reference",
    						targetProfile: [
    							"http://hl7.org/fhir/StructureDefinition/Schedule"
    						]
    					},
    					{
    						code: "date"
    					},
    					{
    						code: "dateTime"
    					}
    				]
    			},
    			data: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "DataRequirement"
    					}
    				]
    			},
    			condition: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "Expression"
    					}
    				]
    			}
    		}
    	},
    	UsageContext: {
    		display: "UsageContext",
    		properties: {
    			id: {
    				min: 0,
    				max: "1",
    				type: [
    					{
    						code: "string"
    					}
    				]
    			},
    			extension: {
    				min: 0,
    				max: "*",
    				type: [
    					{
    						code: "Extension"
    					}
    				]
    			},
    			code: {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "Coding"
    					}
    				]
    			},
    			"value[x]": {
    				min: 1,
    				max: "1",
    				type: [
    					{
    						code: "CodeableConcept"
    					},
    					{
    						code: "Quantity"
    					},
    					{
    						code: "Range"
    					},
    					{
    						code: "Reference",
    						targetProfile: [
    							"http://hl7.org/fhir/StructureDefinition/PlanDefinition",
    							"http://hl7.org/fhir/StructureDefinition/ResearchStudy",
    							"http://hl7.org/fhir/StructureDefinition/InsurancePlan",
    							"http://hl7.org/fhir/StructureDefinition/HealthcareService",
    							"http://hl7.org/fhir/StructureDefinition/Group",
    							"http://hl7.org/fhir/StructureDefinition/Location",
    							"http://hl7.org/fhir/StructureDefinition/Organization"
    						]
    					}
    				]
    			}
    		}
    	}
    };
    var baseSchema = {
    	types: types
    };

    /**
     * List of property types.
     * http://www.hl7.org/fhir/valueset-defined-types.html
     * The list here includes additions found from StructureDefinition resources.
     */
    exports.PropertyType = void 0;
    (function (PropertyType) {
        PropertyType["Address"] = "Address";
        PropertyType["Age"] = "Age";
        PropertyType["Annotation"] = "Annotation";
        PropertyType["Attachment"] = "Attachment";
        PropertyType["BackboneElement"] = "BackboneElement";
        PropertyType["CodeableConcept"] = "CodeableConcept";
        PropertyType["Coding"] = "Coding";
        PropertyType["ContactDetail"] = "ContactDetail";
        PropertyType["ContactPoint"] = "ContactPoint";
        PropertyType["Contributor"] = "Contributor";
        PropertyType["Count"] = "Count";
        PropertyType["DataRequirement"] = "DataRequirement";
        PropertyType["Distance"] = "Distance";
        PropertyType["Dosage"] = "Dosage";
        PropertyType["Duration"] = "Duration";
        PropertyType["Expression"] = "Expression";
        PropertyType["Extension"] = "Extension";
        PropertyType["HumanName"] = "HumanName";
        PropertyType["Identifier"] = "Identifier";
        PropertyType["MarketingStatus"] = "MarketingStatus";
        PropertyType["Meta"] = "Meta";
        PropertyType["Money"] = "Money";
        PropertyType["Narrative"] = "Narrative";
        PropertyType["ParameterDefinition"] = "ParameterDefinition";
        PropertyType["Period"] = "Period";
        PropertyType["Population"] = "Population";
        PropertyType["ProdCharacteristic"] = "ProdCharacteristic";
        PropertyType["ProductShelfLife"] = "ProductShelfLife";
        PropertyType["Quantity"] = "Quantity";
        PropertyType["Range"] = "Range";
        PropertyType["Ratio"] = "Ratio";
        PropertyType["Reference"] = "Reference";
        PropertyType["RelatedArtifact"] = "RelatedArtifact";
        PropertyType["SampledData"] = "SampledData";
        PropertyType["Signature"] = "Signature";
        PropertyType["SubstanceAmount"] = "SubstanceAmount";
        PropertyType["SystemString"] = "http://hl7.org/fhirpath/System.String";
        PropertyType["Timing"] = "Timing";
        PropertyType["TriggerDefinition"] = "TriggerDefinition";
        PropertyType["UsageContext"] = "UsageContext";
        PropertyType["base64Binary"] = "base64Binary";
        PropertyType["boolean"] = "boolean";
        PropertyType["canonical"] = "canonical";
        PropertyType["code"] = "code";
        PropertyType["date"] = "date";
        PropertyType["dateTime"] = "dateTime";
        PropertyType["decimal"] = "decimal";
        PropertyType["id"] = "id";
        PropertyType["instant"] = "instant";
        PropertyType["integer"] = "integer";
        PropertyType["markdown"] = "markdown";
        PropertyType["oid"] = "oid";
        PropertyType["positiveInt"] = "positiveInt";
        PropertyType["string"] = "string";
        PropertyType["time"] = "time";
        PropertyType["unsignedInt"] = "unsignedInt";
        PropertyType["uri"] = "uri";
        PropertyType["url"] = "url";
        PropertyType["uuid"] = "uuid";
    })(exports.PropertyType || (exports.PropertyType = {}));
    /**
     * Creates a new empty IndexedStructureDefinition.
     * @returns The empty IndexedStructureDefinition.
     * @deprecated Use globalSchema
     */
    function createSchema() {
        return { types: {} };
    }
    function createTypeSchema(typeName, structureDefinition, elementDefinition) {
        return {
            structureDefinition,
            elementDefinition,
            display: typeName,
            description: elementDefinition.definition,
            properties: {},
        };
    }
    /**
     * Indexes a bundle of StructureDefinitions for faster lookup.
     * @param bundle A FHIR bundle StructureDefinition resources.
     * @see {@link IndexedStructureDefinition} for more details on indexed StructureDefinitions.
     */
    function indexStructureDefinitionBundle(bundle) {
        for (const entry of bundle.entry) {
            const resource = entry.resource;
            if (resource.resourceType === 'StructureDefinition') {
                indexStructureDefinition(resource);
            }
        }
    }
    /**
     * Indexes a StructureDefinition for fast lookup.
     * @param structureDefinition The original StructureDefinition.
     * @see {@link IndexedStructureDefinition} for more details on indexed StructureDefinitions.
     */
    function indexStructureDefinition(structureDefinition) {
        const typeName = structureDefinition.name;
        if (!typeName) {
            return;
        }
        const elements = structureDefinition.snapshot?.element;
        if (elements) {
            // First pass, build types
            elements.forEach((element) => indexType(structureDefinition, element));
            // Second pass, build properties
            elements.forEach((element) => indexProperty(element));
        }
    }
    /**
     * Indexes TypeSchema from an ElementDefinition.
     * In the common case, there will be many ElementDefinition instances per TypeSchema.
     * Only the first occurrence is saved.
     * @param structureDefinition The parent type structure definition.
     * @param elementDefinition The element definition.
     * @see {@link IndexedStructureDefinition} for more details on indexed StructureDefinitions.
     */
    function indexType(structureDefinition, elementDefinition) {
        const path = elementDefinition.path;
        const typeCode = elementDefinition.type?.[0]?.code;
        if (typeCode !== undefined && typeCode !== 'Element' && typeCode !== 'BackboneElement') {
            return;
        }
        const parts = path.split('.');
        const typeName = buildTypeName(parts);
        globalSchema.types[typeName] = createTypeSchema(typeName, structureDefinition, elementDefinition);
        globalSchema.types[typeName].parentType = buildTypeName(parts.slice(0, parts.length - 1));
    }
    /**
     * Indexes PropertySchema from an ElementDefinition.
     * @param element The input ElementDefinition.
     * @see {@link IndexedStructureDefinition} for more details on indexed StructureDefinitions.
     */
    function indexProperty(element) {
        const path = element.path;
        const parts = path.split('.');
        if (parts.length === 1) {
            return;
        }
        const typeName = buildTypeName(parts.slice(0, parts.length - 1));
        const typeSchema = globalSchema.types[typeName];
        if (!typeSchema) {
            return;
        }
        const key = parts[parts.length - 1];
        typeSchema.properties[key] = element;
    }
    /**
     * Indexes a bundle of SearchParameter resources for faster lookup.
     * @param bundle A FHIR bundle SearchParameter resources.
     * @see {@link IndexedStructureDefinition} for more details on indexed StructureDefinitions.
     */
    function indexSearchParameterBundle(bundle) {
        for (const entry of bundle.entry) {
            const resource = entry.resource;
            if (resource.resourceType === 'SearchParameter') {
                indexSearchParameter(resource);
            }
        }
    }
    /**
     * Indexes a SearchParameter resource for fast lookup.
     * Indexes by SearchParameter.code, which is the query string parameter name.
     * @param searchParam The SearchParameter resource.
     * @see {@link IndexedStructureDefinition} for more details on indexed StructureDefinitions.
     */
    function indexSearchParameter(searchParam) {
        if (!searchParam.base) {
            return;
        }
        for (const resourceType of searchParam.base) {
            const typeSchema = globalSchema.types[resourceType];
            if (!typeSchema) {
                continue;
            }
            if (!typeSchema.searchParams) {
                typeSchema.searchParams = {
                    _id: {
                        base: [resourceType],
                        code: '_id',
                        type: 'token',
                        expression: resourceType + '.id',
                    },
                    _lastUpdated: {
                        base: [resourceType],
                        code: '_lastUpdated',
                        type: 'date',
                        expression: resourceType + '.meta.lastUpdated',
                    },
                    _compartment: {
                        base: [resourceType],
                        code: '_compartment',
                        type: 'reference',
                        expression: resourceType + '.meta.compartment',
                    },
                };
            }
            typeSchema.searchParams[searchParam.code] = searchParam;
        }
    }
    function buildTypeName(components) {
        if (components.length === 1) {
            return components[0];
        }
        return components.map(capitalize).join('');
    }
    function getPropertyDisplayName(path) {
        // Get the property name, which is the remainder after the last period
        // For example, for path "Patient.birthDate"
        // the property name is "birthDate"
        const propertyName = path.replaceAll('[x]', '').split('.').pop();
        // Special case for ID
        if (propertyName === 'id') {
            return 'ID';
        }
        // Split by capital letters
        // Capitalize the first letter of each word
        // Join together with spaces in between
        // Then normalize whitespace to single space character
        // For example, for property name "birthDate",
        // the display name is "Birth Date".
        return propertyName
            .split(/(?=[A-Z])/)
            .map(capitalize)
            .join(' ')
            .replace('_', ' ')
            .replace(/\s+/g, ' ');
    }
    /**
     * Returns an element definition by type and property name.
     * Handles content references.
     * @param typeName The type name.
     * @param propertyName The property name.
     * @returns The element definition if found.
     */
    function getElementDefinition(typeName, propertyName) {
        const typeSchema = globalSchema.types[typeName];
        if (!typeSchema) {
            return undefined;
        }
        const property = typeSchema.properties[propertyName] ?? typeSchema.properties[propertyName + '[x]'];
        if (!property) {
            return undefined;
        }
        if (property.contentReference) {
            // Content references start with a "#"
            // Remove the "#" character
            const contentReference = property.contentReference.substring(1).split('.');
            const referencePropertyName = contentReference.pop();
            const referenceTypeName = buildTypeName(contentReference);
            return getElementDefinition(referenceTypeName, referencePropertyName);
        }
        return property;
    }
    /**
     * Global schema singleton.
     */
    const globalSchema = baseSchema;

    // PKCE auth based on:
    // https://aws.amazon.com/blogs/security/how-to-add-authentication-single-page-web-application-with-amazon-cognito-oauth2-implementation/
    var _MedplumClient_instances, _MedplumClient_fetch, _MedplumClient_createPdf, _MedplumClient_storage, _MedplumClient_requestCache, _MedplumClient_cacheTime, _MedplumClient_baseUrl, _MedplumClient_authorizeUrl, _MedplumClient_tokenUrl, _MedplumClient_logoutUrl, _MedplumClient_onUnauthenticated, _MedplumClient_clientId, _MedplumClient_clientSecret, _MedplumClient_accessToken, _MedplumClient_refreshToken, _MedplumClient_refreshPromise, _MedplumClient_profilePromise, _MedplumClient_profile, _MedplumClient_config, _MedplumClient_addLogin, _MedplumClient_refreshProfile, _MedplumClient_getCacheEntry, _MedplumClient_setCacheEntry, _MedplumClient_request, _MedplumClient_addFetchOptionsDefaults, _MedplumClient_setRequestContentType, _MedplumClient_setRequestBody, _MedplumClient_handleUnauthenticated, _MedplumClient_requestAuthorization, _MedplumClient_refresh, _MedplumClient_fetchTokens, _MedplumClient_verifyTokens, _MedplumClient_setupStorageListener;
    const MEDPLUM_VERSION = "1.0.6-5860113c";
    const DEFAULT_BASE_URL = 'https://api.medplum.com/';
    const DEFAULT_RESOURCE_CACHE_SIZE = 1000;
    const DEFAULT_CACHE_TIME = 60000; // 60 seconds
    const JSON_CONTENT_TYPE = 'application/json';
    const FHIR_CONTENT_TYPE = 'application/fhir+json';
    const PATCH_CONTENT_TYPE = 'application/json-patch+json';
    /**
     * The MedplumClient class provides a client for the Medplum FHIR server.
     *
     * The client can be used in the browser, in a NodeJS application, or in a Medplum Bot.
     *
     * The client provides helpful methods for common operations such as:
     *   1) Authenticating
     *   2) Creating resources
     *   2) Reading resources
     *   3) Updating resources
     *   5) Deleting resources
     *   6) Searching
     *   7) Making GraphQL queries
     *
     * Here is a quick example of how to use the client:
     *
     * ```typescript
     * import { MedplumClient } from '@medplum/core';
     * const medplum = new MedplumClient();
     * ```
     *
     * Create a `Patient`:
     *
     * ```typescript
     * const patient = await medplum.createResource({
     *   resourceType: 'Patient',
     *   name: [{
     *     given: ['Alice'],
     *     family: 'Smith'
     *   }]
     * });
     * ```
     *
     * Read a `Patient` by ID:
     *
     * ```typescript
     * const patient = await medplum.readResource('Patient', '123');
     * console.log(patient.name[0].given[0]);
     * ```
     *
     * Search for a `Patient` by name:
     *
     * ```typescript
     * const bundle = await medplum.search('Patient', 'name=Alice');
     * console.log(bundle.total);
     * ```
     *
     *  <head>
     *    <meta name="algolia:pageRank" content="100" />
     *  </head>

     */
    class MedplumClient extends EventTarget {
        constructor(options) {
            super();
            _MedplumClient_instances.add(this);
            _MedplumClient_fetch.set(this, void 0);
            _MedplumClient_createPdf.set(this, void 0);
            _MedplumClient_storage.set(this, void 0);
            _MedplumClient_requestCache.set(this, void 0);
            _MedplumClient_cacheTime.set(this, void 0);
            _MedplumClient_baseUrl.set(this, void 0);
            _MedplumClient_authorizeUrl.set(this, void 0);
            _MedplumClient_tokenUrl.set(this, void 0);
            _MedplumClient_logoutUrl.set(this, void 0);
            _MedplumClient_onUnauthenticated.set(this, void 0);
            _MedplumClient_clientId.set(this, void 0);
            _MedplumClient_clientSecret.set(this, void 0);
            _MedplumClient_accessToken.set(this, void 0);
            _MedplumClient_refreshToken.set(this, void 0);
            _MedplumClient_refreshPromise.set(this, void 0);
            _MedplumClient_profilePromise.set(this, void 0);
            _MedplumClient_profile.set(this, void 0);
            _MedplumClient_config.set(this, void 0);
            if (options?.baseUrl) {
                if (!options.baseUrl.startsWith('http')) {
                    throw new Error('Base URL must start with http or https');
                }
            }
            __classPrivateFieldSet(this, _MedplumClient_fetch, options?.fetch || window.fetch.bind(window), "f");
            __classPrivateFieldSet(this, _MedplumClient_createPdf, options?.createPdf, "f");
            __classPrivateFieldSet(this, _MedplumClient_storage, new ClientStorage(), "f");
            __classPrivateFieldSet(this, _MedplumClient_requestCache, new LRUCache(options?.resourceCacheSize ?? DEFAULT_RESOURCE_CACHE_SIZE), "f");
            __classPrivateFieldSet(this, _MedplumClient_cacheTime, options?.cacheTime ?? DEFAULT_CACHE_TIME, "f");
            __classPrivateFieldSet(this, _MedplumClient_baseUrl, ensureTrailingSlash(options?.baseUrl) || DEFAULT_BASE_URL, "f");
            __classPrivateFieldSet(this, _MedplumClient_clientId, options?.clientId || '', "f");
            __classPrivateFieldSet(this, _MedplumClient_authorizeUrl, options?.authorizeUrl || __classPrivateFieldGet(this, _MedplumClient_baseUrl, "f") + 'oauth2/authorize', "f");
            __classPrivateFieldSet(this, _MedplumClient_tokenUrl, options?.tokenUrl || __classPrivateFieldGet(this, _MedplumClient_baseUrl, "f") + 'oauth2/token', "f");
            __classPrivateFieldSet(this, _MedplumClient_logoutUrl, options?.logoutUrl || __classPrivateFieldGet(this, _MedplumClient_baseUrl, "f") + 'oauth2/logout', "f");
            __classPrivateFieldSet(this, _MedplumClient_onUnauthenticated, options?.onUnauthenticated, "f");
            const activeLogin = this.getActiveLogin();
            if (activeLogin) {
                __classPrivateFieldSet(this, _MedplumClient_accessToken, activeLogin.accessToken, "f");
                __classPrivateFieldSet(this, _MedplumClient_refreshToken, activeLogin.refreshToken, "f");
                __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_refreshProfile).call(this).catch(console.log);
            }
            __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_setupStorageListener).call(this);
        }
        /**
         * Returns the current base URL for all API requests.
         * By default, this is set to `https://api.medplum.com/`.
         * This can be overridden by setting the `baseUrl` option when creating the client.
         * @category HTTP
         * @returns The current base URL for all API requests.
         */
        getBaseUrl() {
            return __classPrivateFieldGet(this, _MedplumClient_baseUrl, "f");
        }
        /**
         * Clears all auth state including local storage and session storage.
         * @category Authentication
         */
        clear() {
            __classPrivateFieldGet(this, _MedplumClient_storage, "f").clear();
            __classPrivateFieldGet(this, _MedplumClient_requestCache, "f").clear();
            __classPrivateFieldSet(this, _MedplumClient_accessToken, undefined, "f");
            __classPrivateFieldSet(this, _MedplumClient_refreshToken, undefined, "f");
            __classPrivateFieldSet(this, _MedplumClient_profile, undefined, "f");
            __classPrivateFieldSet(this, _MedplumClient_config, undefined, "f");
            this.dispatchEvent({ type: 'change' });
        }
        /**
         * Invalidates any cached values or cached requests for the given URL.
         * @category Caching
         * @param url The URL to invalidate.
         */
        invalidateUrl(url) {
            url = url.toString();
            __classPrivateFieldGet(this, _MedplumClient_requestCache, "f").delete(url);
        }
        /**
         * Invalidates all cached search results or cached requests for the given resourceType.
         * @category Caching
         * @param resourceType The resource type to invalidate.
         */
        invalidateSearches(resourceType) {
            const url = 'fhir/R4/' + resourceType;
            for (const key of __classPrivateFieldGet(this, _MedplumClient_requestCache, "f").keys()) {
                if (key.endsWith(url) || key.includes(url + '?')) {
                    __classPrivateFieldGet(this, _MedplumClient_requestCache, "f").delete(key);
                }
            }
        }
        /**
         * Makes an HTTP GET request to the specified URL.
         *
         * This is a lower level method for custom requests.
         * For common operations, we recommend using higher level methods
         * such as `readResource()`, `search()`, etc.
         *
         * @category HTTP
         * @param url The target URL.
         * @param options Optional fetch options.
         * @returns Promise to the response content.
         */
        get(url, options = {}) {
            url = url.toString();
            const cached = __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_getCacheEntry).call(this, url, options);
            if (cached) {
                return cached.value;
            }
            const promise = new ReadablePromise(__classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_request).call(this, 'GET', url, options));
            __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_setCacheEntry).call(this, url, promise);
            return promise;
        }
        /**
         * Makes an HTTP POST request to the specified URL.
         *
         * This is a lower level method for custom requests.
         * For common operations, we recommend using higher level methods
         * such as `createResource()`.
         *
         * @category HTTP
         * @param url The target URL.
         * @param body The content body. Strings and `File` objects are passed directly. Other objects are converted to JSON.
         * @param contentType The content type to be included in the "Content-Type" header.
         * @param options Optional fetch options.
         * @returns Promise to the response content.
         */
        post(url, body, contentType, options = {}) {
            url = url.toString();
            if (body) {
                __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_setRequestBody).call(this, options, body);
            }
            if (contentType) {
                __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_setRequestContentType).call(this, options, contentType);
            }
            this.invalidateUrl(url);
            return __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_request).call(this, 'POST', url, options);
        }
        /**
         * Makes an HTTP PUT request to the specified URL.
         *
         * This is a lower level method for custom requests.
         * For common operations, we recommend using higher level methods
         * such as `updateResource()`.
         *
         * @category HTTP
         * @param url The target URL.
         * @param body The content body. Strings and `File` objects are passed directly. Other objects are converted to JSON.
         * @param contentType The content type to be included in the "Content-Type" header.
         * @param options Optional fetch options.
         * @returns Promise to the response content.
         */
        put(url, body, contentType, options = {}) {
            url = url.toString();
            if (body) {
                __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_setRequestBody).call(this, options, body);
            }
            if (contentType) {
                __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_setRequestContentType).call(this, options, contentType);
            }
            this.invalidateUrl(url);
            return __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_request).call(this, 'PUT', url, options);
        }
        /**
         * Makes an HTTP PATCH request to the specified URL.
         *
         * This is a lower level method for custom requests.
         * For common operations, we recommend using higher level methods
         * such as `patchResource()`.
         *
         * @category HTTP
         * @param url The target URL.
         * @param operations Array of JSONPatch operations.
         * @param options Optional fetch options.
         * @returns Promise to the response content.
         */
        patch(url, operations, options = {}) {
            url = url.toString();
            __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_setRequestBody).call(this, options, operations);
            __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_setRequestContentType).call(this, options, PATCH_CONTENT_TYPE);
            this.invalidateUrl(url);
            return __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_request).call(this, 'PATCH', url, options);
        }
        /**
         * Makes an HTTP DELETE request to the specified URL.
         *
         *
         * This is a lower level method for custom requests.
         * For common operations, we recommend using higher level methods
         * such as `deleteResource()`.
         *
         * @category HTTP
         * @param url The target URL.
         * @param options Optional fetch options.
         * @returns Promise to the response content.
         */
        delete(url, options = {}) {
            url = url.toString();
            this.invalidateUrl(url);
            return __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_request).call(this, 'DELETE', url, options);
        }
        /**
         * Initiates a new user flow.
         *
         * This method is part of the two different user registration flows:
         * 1) New Practitioner and new Project
         * 2) New Patient registration
         *
         * @category Authentication
         * @param newUserRequest Register request including email and password.
         * @returns Promise to the authentication response.
         */
        async startNewUser(newUserRequest) {
            await this.startPkce();
            return this.post('auth/newuser', {
                ...newUserRequest,
                codeChallengeMethod: 'S256',
                codeChallenge: sessionStorage.getItem('codeChallenge'),
            });
        }
        /**
         * Initiates a new project flow.
         *
         * This requires a partial login from `startNewUser` or `startNewGoogleUser`.
         *
         * @param newProjectRequest Register request including email and password.
         * @returns Promise to the authentication response.
         */
        async startNewProject(newProjectRequest) {
            return this.post('auth/newproject', newProjectRequest);
        }
        /**
         * Initiates a new patient flow.
         *
         * This requires a partial login from `startNewUser` or `startNewGoogleUser`.
         *
         * @param newPatientRequest Register request including email and password.
         * @returns Promise to the authentication response.
         */
        async startNewPatient(newPatientRequest) {
            return this.post('auth/newpatient', newPatientRequest);
        }
        /**
         * Initiates a user login flow.
         * @category Authentication
         * @param loginRequest Login request including email and password.
         * @returns Promise to the authentication response.
         */
        async startLogin(loginRequest) {
            const { codeChallenge, codeChallengeMethod } = this.getCodeChallenge(loginRequest);
            return this.post('auth/login', {
                ...loginRequest,
                clientId: loginRequest.clientId ?? __classPrivateFieldGet(this, _MedplumClient_clientId, "f"),
                scope: loginRequest.scope,
                codeChallengeMethod,
                codeChallenge,
            });
        }
        /**
         * Tries to sign in with Google authentication.
         * The response parameter is the result of a Google authentication.
         * See: https://developers.google.com/identity/gsi/web/guides/handle-credential-responses-js-functions
         * @category Authentication
         * @param loginRequest Login request including Google credential response.
         * @returns Promise to the authentication response.
         */
        async startGoogleLogin(loginRequest) {
            const { codeChallenge, codeChallengeMethod } = this.getCodeChallenge(loginRequest);
            return this.post('auth/google', {
                ...loginRequest,
                clientId: loginRequest.clientId ?? __classPrivateFieldGet(this, _MedplumClient_clientId, "f"),
                scope: loginRequest.scope,
                codeChallengeMethod,
                codeChallenge,
            });
        }
        getCodeChallenge(loginRequest) {
            if (loginRequest.codeChallenge) {
                return {
                    codeChallenge: loginRequest.codeChallenge,
                    codeChallengeMethod: loginRequest.codeChallengeMethod,
                };
            }
            const codeChallenge = sessionStorage.getItem('codeChallenge');
            if (codeChallenge) {
                return {
                    codeChallenge,
                    codeChallengeMethod: 'S256',
                };
            }
            return {};
        }
        /**
         * Signs out locally.
         * Does not invalidate tokens with the server.
         * @category Authentication
         */
        signOut() {
            this.clear();
        }
        /**
         * Tries to sign in the user.
         * Returns true if the user is signed in.
         * This may result in navigating away to the sign in page.
         * @category Authentication
         */
        async signInWithRedirect() {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            if (!code) {
                await __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_requestAuthorization).call(this);
                return undefined;
            }
            else {
                return this.processCode(code);
            }
        }
        /**
         * Tries to sign out the user.
         * See: https://docs.aws.amazon.com/cognito/latest/developerguide/logout-endpoint.html
         * @category Authentication
         */
        signOutWithRedirect() {
            window.location.assign(__classPrivateFieldGet(this, _MedplumClient_logoutUrl, "f"));
        }
        /**
         * Builds a FHIR URL from a collection of URL path components.
         * For example, `buildUrl('/Patient', '123')` returns `fhir/R4/Patient/123`.
         * @category HTTP
         * @param path The path component of the URL.
         * @returns The well-formed FHIR URL.
         */
        fhirUrl(...path) {
            return new URL(__classPrivateFieldGet(this, _MedplumClient_baseUrl, "f") + 'fhir/R4/' + path.join('/'));
        }
        /**
         * Builds a FHIR search URL from a search query or structured query object.
         * @category HTTP
         * @category Search
         * @param query The FHIR search query or structured query object.
         * @returns The well-formed FHIR URL.
         */
        fhirSearchUrl(resourceType, query) {
            const url = this.fhirUrl(resourceType);
            if (query) {
                url.search = query.toString();
            }
            return url;
        }
        /**
         * Sends a FHIR search request.
         *
         * Example using a FHIR search string:
         *
         * ```typescript
         * const bundle = await client.search('Patient', 'name=Alice');
         * console.log(bundle);
         * ```
         *
         * The return value is a FHIR bundle:
         *
         * ```json
         * {
         *    "resourceType": "Bundle",
         *    "type": "searchset",
         *    "entry": [
         *       {
         *          "resource": {
         *             "resourceType": "Patient",
         *             "name": [
         *                {
         *                   "given": [
         *                      "George"
         *                   ],
         *                   "family": "Washington"
         *                }
         *             ],
         *          }
         *       }
         *    ]
         * }
         * ```
         *
         * To query the count of a search, use the summary feature like so:
         *
         * ```typescript
         * const patients = medplum.search('Patient', '_summary=count');
         * ```
         *
         * See FHIR search for full details: https://www.hl7.org/fhir/search.html
         *
         * @category Search
         * @param resourceType The FHIR resource type.
         * @param query The search query as either a string or a structured search object.
         * @param options Optional fetch options.
         * @returns Promise to the search result bundle.
         */
        search(resourceType, query, options = {}) {
            return this.get(this.fhirSearchUrl(resourceType, query), options);
        }
        /**
         * Sends a FHIR search request for a single resource.
         *
         * This is a convenience method for `search()` that returns the first resource rather than a `Bundle`.
         *
         * Example using a FHIR search string:
         *
         * ```typescript
         * const patient = await client.searchOne('Patient', 'identifier=123');
         * console.log(patient);
         * ```
         *
         * The return value is the resource, if available; otherwise, undefined.
         *
         * See FHIR search for full details: https://www.hl7.org/fhir/search.html
         *
         * @category Search
         * @param resourceType The FHIR resource type.
         * @param query The search query as either a string or a structured search object.
         * @param options Optional fetch options.
         * @returns Promise to the search result bundle.
         */
        searchOne(resourceType, query, options = {}) {
            const url = this.fhirSearchUrl(resourceType, query);
            url.searchParams.set('_count', '1');
            url.searchParams.sort();
            const cacheKey = url.toString() + '-searchOne';
            const cached = __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_getCacheEntry).call(this, cacheKey, options);
            if (cached) {
                return cached.value;
            }
            const promise = new ReadablePromise(this.search(resourceType, url.searchParams, options).then((b) => b.entry?.[0]?.resource));
            __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_setCacheEntry).call(this, cacheKey, promise);
            return promise;
        }
        /**
         * Sends a FHIR search request for an array of resources.
         *
         * This is a convenience method for `search()` that returns the resources as an array rather than a `Bundle`.
         *
         * Example using a FHIR search string:
         *
         * ```typescript
         * const patients = await client.searchResources('Patient', 'name=Alice');
         * console.log(patients);
         * ```
         *
         * The return value is an array of resources.
         *
         * See FHIR search for full details: https://www.hl7.org/fhir/search.html
         *
         * @category Search
         * @param resourceType The FHIR resource type.
         * @param query The search query as either a string or a structured search object.
         * @param options Optional fetch options.
         * @returns Promise to the search result bundle.
         */
        searchResources(resourceType, query, options = {}) {
            const url = this.fhirSearchUrl(resourceType, query);
            const cacheKey = url.toString() + '-searchResources';
            const cached = __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_getCacheEntry).call(this, cacheKey, options);
            if (cached) {
                return cached.value;
            }
            const promise = new ReadablePromise(this.search(resourceType, query, options).then((b) => b.entry?.map((e) => e.resource) ?? []));
            __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_setCacheEntry).call(this, cacheKey, promise);
            return promise;
        }
        /**
         * Searches a ValueSet resource using the "expand" operation.
         * See: https://www.hl7.org/fhir/operation-valueset-expand.html
         *
         * @category Search
         * @param system The ValueSet system url.
         * @param filter The search string.
         * @param options Optional fetch options.
         * @returns Promise to expanded ValueSet.
         */
        searchValueSet(system, filter, options = {}) {
            const url = this.fhirUrl('ValueSet', '$expand');
            url.searchParams.set('url', system);
            url.searchParams.set('filter', filter);
            return this.get(url.toString(), options);
        }
        /**
         * Returns a cached resource if it is available.
         * @category Caching
         * @param resourceType The FHIR resource type.
         * @param id The FHIR resource ID.
         * @returns The resource if it is available in the cache; undefined otherwise.
         */
        getCached(resourceType, id) {
            const cached = __classPrivateFieldGet(this, _MedplumClient_requestCache, "f").get(this.fhirUrl(resourceType, id).toString())?.value;
            return cached && cached.isOk() ? cached.read() : undefined;
        }
        /**
         * Returns a cached resource if it is available.
         * @category Caching
         * @param resourceType The FHIR resource type.
         * @param id The FHIR resource ID.
         * @returns The resource if it is available in the cache; undefined otherwise.
         */
        getCachedReference(reference) {
            const refString = reference.reference;
            if (!refString) {
                return undefined;
            }
            const [resourceType, id] = refString.split('/');
            if (!resourceType || !id) {
                return undefined;
            }
            return this.getCached(resourceType, id);
        }
        /**
         * Reads a resource by resource type and ID.
         *
         * Example:
         *
         * ```typescript
         * const patient = await medplum.readResource('Patient', '123');
         * console.log(patient);
         * ```
         *
         * See the FHIR "read" operation for full details: https://www.hl7.org/fhir/http.html#read
         *
         * @category Read
         * @param resourceType The FHIR resource type.
         * @param id The resource ID.
         * @param options Optional fetch options.
         * @returns The resource if available; undefined otherwise.
         */
        readResource(resourceType, id, options = {}) {
            return this.get(this.fhirUrl(resourceType, id), options);
        }
        /**
         * Reads a resource by `Reference`.
         *
         * This is a convenience method for `readResource()` that accepts a `Reference` object.
         *
         * Example:
         *
         * ```typescript
         * const serviceRequest = await medplum.readResource('ServiceRequest', '123');
         * const patient = await medplum.readReference(serviceRequest.subject);
         * console.log(patient);
         * ```
         *
         * See the FHIR "read" operation for full details: https://www.hl7.org/fhir/http.html#read
         *
         * @category Read
         * @param reference The FHIR reference object.
         * @param options Optional fetch options.
         * @returns The resource if available; undefined otherwise.
         */
        readReference(reference, options = {}) {
            const refString = reference?.reference;
            if (!refString) {
                return new ReadablePromise(Promise.reject(new Error('Missing reference')));
            }
            const [resourceType, id] = refString.split('/');
            if (!resourceType || !id) {
                return new ReadablePromise(Promise.reject(new Error('Invalid reference')));
            }
            return this.readResource(resourceType, id, options);
        }
        /**
         * Returns a cached schema for a resource type.
         * If the schema is not cached, returns undefined.
         * It is assumed that a client will call requestSchema before using this method.
         * @category Schema
         * @returns The schema if immediately available, undefined otherwise.
         * @deprecated Use globalSchema instead.
         */
        getSchema() {
            return globalSchema;
        }
        /**
         * Requests the schema for a resource type.
         * If the schema is already cached, the promise is resolved immediately.
         * @category Schema
         * @param resourceType The FHIR resource type.
         * @returns Promise to a schema with the requested resource type.
         */
        async requestSchema(resourceType) {
            if (resourceType in globalSchema.types) {
                return globalSchema;
            }
            const query = `{
      StructureDefinitionList(name: "${resourceType}") {
        name,
        description,
        snapshot {
          element {
            id,
            path,
            min,
            max,
            type {
              code,
              targetProfile
            },
            binding {
              valueSet
            },
            definition
          }
        }
      }
      SearchParameterList(base: "${resourceType}", _count: 100) {
        base,
        code,
        type,
        expression,
        target
      }
    }`.replace(/\s+/g, ' ');
            const response = (await this.graphql(query));
            for (const structureDefinition of response.data.StructureDefinitionList) {
                indexStructureDefinition(structureDefinition);
            }
            for (const searchParameter of response.data.SearchParameterList) {
                indexSearchParameter(searchParameter);
            }
            return globalSchema;
        }
        /**
         * Reads resource history by resource type and ID.
         *
         * The return value is a bundle of all versions of the resource.
         *
         * Example:
         *
         * ```typescript
         * const history = await medplum.readHistory('Patient', '123');
         * console.log(history);
         * ```
         *
         * See the FHIR "history" operation for full details: https://www.hl7.org/fhir/http.html#history
         *
         * @category Read
         * @param resourceType The FHIR resource type.
         * @param id The resource ID.
         * @param options Optional fetch options.
         * @returns Promise to the resource history.
         */
        readHistory(resourceType, id, options = {}) {
            return this.get(this.fhirUrl(resourceType, id, '_history'), options);
        }
        /**
         * Reads a specific version of a resource by resource type, ID, and version ID.
         *
         * Example:
         *
         * ```typescript
         * const version = await medplum.readVersion('Patient', '123', '456');
         * console.log(version);
         * ```
         *
         * See the FHIR "vread" operation for full details: https://www.hl7.org/fhir/http.html#vread
         *
         * @category Read
         * @param resourceType The FHIR resource type.
         * @param id The resource ID.
         * @param vid The version ID.
         * @param options Optional fetch options.
         * @returns The resource if available; undefined otherwise.
         */
        readVersion(resourceType, id, vid, options = {}) {
            return this.get(this.fhirUrl(resourceType, id, '_history', vid), options);
        }
        /**
         * Executes the Patient "everything" operation for a patient.
         *
         * Example:
         *
         * ```typescript
         * const bundle = await medplum.readPatientEverything('123');
         * console.log(bundle);
         * ```
         *
         * See the FHIR "patient-everything" operation for full details: https://hl7.org/fhir/operation-patient-everything.html
         *
         * @category Read
         * @param id The Patient Id
         * @param options Optional fetch options.
         * @returns A Bundle of all Resources related to the Patient
         */
        readPatientEverything(id, options = {}) {
            return this.get(this.fhirUrl('Patient', id, '$everything'), options);
        }
        /**
         * Creates a new FHIR resource.
         *
         * The return value is the newly created resource, including the ID and meta.
         *
         * Example:
         *
         * ```typescript
         * const result = await medplum.createResource({
         *   resourceType: 'Patient',
         *   name: [{
         *    family: 'Smith',
         *    given: ['John']
         *   }]
         * });
         * console.log(result.id);
         * ```
         *
         * See the FHIR "create" operation for full details: https://www.hl7.org/fhir/http.html#create
         *
         * @category Create
         * @param resource The FHIR resource to create.
         * @returns The result of the create operation.
         */
        createResource(resource) {
            if (!resource.resourceType) {
                throw new Error('Missing resourceType');
            }
            this.invalidateSearches(resource.resourceType);
            return this.post(this.fhirUrl(resource.resourceType), resource);
        }
        /**
         * Conditionally create a new FHIR resource only if some equivalent resource does not already exist on the server.
         *
         * The return value is the existing resource or the newly created resource, including the ID and meta.
         *
         * Example:
         *
         * ```typescript
         * const result = await medplum.createResourceIfNoneExist(
         *   {
         *     resourceType: 'Patient',
         *     identifier: [{
         *      system: 'http://example.com/mrn',
         *      value: '123'
         *     }]
         *     name: [{
         *      family: 'Smith',
         *      given: ['John']
         *     }]
         *   },
         *   'identifier=123'
         * );
         * console.log(result.id);
         * ```
         *
         * This method is syntactic sugar for:
         *
         * ```typescript
         * return searchOne(resourceType, query) ?? createResource(resource);
         * ```
         *
         * The query parameter only contains the search parameters (what would be in the URL following the "?").
         *
         * See the FHIR "conditional create" operation for full details: https://www.hl7.org/fhir/http.html#ccreate
         *
         * @category Create
         * @param resource The FHIR resource to create.
         * @param query The search query for an equivalent resource (should not include resource type or "?").
         * @returns The result of the create operation.
         */
        async createResourceIfNoneExist(resource, query) {
            return ((await this.searchOne(resource.resourceType, query)) ?? this.createResource(resource));
        }
        /**
         * Creates a FHIR `Binary` resource with the provided data content.
         *
         * The return value is the newly created resource, including the ID and meta.
         *
         * The `data` parameter can be a string or a `File` object.
         *
         * A `File` object often comes from a `<input type="file">` element.
         *
         * Example:
         *
         * ```typescript
         * const result = await medplum.createBinary(myFile, 'test.jpg', 'image/jpeg');
         * console.log(result.id);
         * ```
         *
         * See the FHIR "create" operation for full details: https://www.hl7.org/fhir/http.html#create
         *
         * @category Create
         * @param data The binary data to upload.
         * @param filename Optional filename for the binary.
         * @param contentType Content type for the binary.
         * @returns The result of the create operation.
         */
        createBinary(data, filename, contentType, onProgress) {
            const url = this.fhirUrl('Binary');
            if (filename) {
                url.searchParams.set('_filename', filename);
            }
            if (onProgress) {
                return this.uploadwithProgress(url, data, contentType, onProgress);
            }
            else {
                return this.post(url, data, contentType);
            }
        }
        uploadwithProgress(url, data, contentType, onProgress) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                xhr.responseType = 'json';
                xhr.onabort = () => reject(new Error('Request aborted'));
                xhr.onerror = () => reject(new Error('Request error'));
                if (onProgress) {
                    xhr.upload.onprogress = (e) => onProgress(e);
                    xhr.upload.onload = (e) => onProgress(e);
                }
                xhr.onload = () => {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        resolve(xhr.response);
                    }
                    else {
                        reject(new Error(xhr.statusText));
                    }
                };
                xhr.open('POST', url);
                xhr.withCredentials = true;
                xhr.setRequestHeader('Authorization', 'Bearer ' + __classPrivateFieldGet(this, _MedplumClient_accessToken, "f"));
                xhr.setRequestHeader('Cache-Control', 'no-cache, no-store, max-age=0');
                xhr.setRequestHeader('Content-Type', contentType);
                xhr.setRequestHeader('X-Medplum', 'extended');
                xhr.send(data);
            });
        }
        /**
         * Creates a PDF as a FHIR `Binary` resource based on pdfmake document definition.
         *
         * The return value is the newly created resource, including the ID and meta.
         *
         * The `docDefinition` parameter is a pdfmake document definition.
         *
         * Example:
         *
         * ```typescript
         * const result = await medplum.createPdf({
         *   content: ['Hello world']
         * });
         * console.log(result.id);
         * ```
         *
         * See the pdfmake document definition for full details: https://pdfmake.github.io/docs/0.1/document-definition-object/
         *
         * @category Media
         * @param docDefinition The PDF document definition.
         * @returns The result of the create operation.
         */
        async createPdf(docDefinition, filename, tableLayouts, fonts) {
            if (!__classPrivateFieldGet(this, _MedplumClient_createPdf, "f")) {
                throw new Error('PDF creation not enabled');
            }
            const blob = await __classPrivateFieldGet(this, _MedplumClient_createPdf, "f").call(this, docDefinition, tableLayouts, fonts);
            return this.createBinary(blob, filename, 'application/pdf');
        }
        /**
         * Creates a FHIR `Communication` resource with the provided data content.
         *
         * This is a convenience method to handle commmon cases where a `Communication` resource is created with a `payload`.
         *
         * @category Create
         * @param resource The FHIR resource to comment on.
         * @param text The text of the comment.
         * @returns The result of the create operation.
         */
        createComment(resource, text) {
            const profile = this.getProfile();
            let encounter = undefined;
            let subject = undefined;
            if (resource.resourceType === 'Encounter') {
                encounter = createReference(resource);
                subject = resource.subject;
            }
            if (resource.resourceType === 'ServiceRequest') {
                encounter = resource.encounter;
                subject = resource.subject;
            }
            if (resource.resourceType === 'Patient') {
                subject = createReference(resource);
            }
            return this.createResource({
                resourceType: 'Communication',
                basedOn: [createReference(resource)],
                encounter,
                subject,
                sender: profile ? createReference(profile) : undefined,
                sent: new Date().toISOString(),
                payload: [{ contentString: text }],
            });
        }
        /**
         * Updates a FHIR resource.
         *
         * The return value is the updated resource, including the ID and meta.
         *
         * Example:
         *
         * ```typescript
         * const result = await medplum.updateResource({
         *   resourceType: 'Patient',
         *   id: '123',
         *   name: [{
         *    family: 'Smith',
         *    given: ['John']
         *   }]
         * });
         * console.log(result.meta.versionId);
         * ```
         *
         * See the FHIR "update" operation for full details: https://www.hl7.org/fhir/http.html#update
         *
         * @category Write
         * @param resource The FHIR resource to update.
         * @returns The result of the update operation.
         */
        async updateResource(resource) {
            if (!resource.resourceType) {
                throw new Error('Missing resourceType');
            }
            if (!resource.id) {
                throw new Error('Missing id');
            }
            this.invalidateSearches(resource.resourceType);
            const result = await this.put(this.fhirUrl(resource.resourceType, resource.id), resource);
            // On 304 not modified, result will be undefined
            // Return the user input instead
            return result ?? resource;
        }
        /**
         * Updates a FHIR resource using JSONPatch operations.
         *
         * The return value is the updated resource, including the ID and meta.
         *
         * Example:
         *
         * ```typescript
         * const result = await medplum.patchResource('Patient', '123', [
         *   {op: 'replace', path: '/name/0/family', value: 'Smith'},
         * ]);
         * console.log(result.meta.versionId);
         * ```
         *
         * See the FHIR "update" operation for full details: https://www.hl7.org/fhir/http.html#patch
         *
         * See the JSONPatch specification for full details: https://tools.ietf.org/html/rfc6902
         *
         * @category Write
         * @param resourceType The FHIR resource type.
         * @param id The resource ID.
         * @param operations The JSONPatch operations.
         * @returns The result of the patch operations.
         */
        patchResource(resourceType, id, operations) {
            this.invalidateSearches(resourceType);
            return this.patch(this.fhirUrl(resourceType, id), operations);
        }
        /**
         * Deletes a FHIR resource by resource type and ID.
         *
         * Example:
         *
         * ```typescript
         * await medplum.deleteResource('Patient', '123');
         * ```
         *
         * See the FHIR "delete" operation for full details: https://www.hl7.org/fhir/http.html#delete
         *
         * @category Delete
         * @param resourceType The FHIR resource type.
         * @param id The resource ID.
         * @returns The result of the delete operation.
         */
        deleteResource(resourceType, id) {
            this.invalidateSearches(resourceType);
            return this.delete(this.fhirUrl(resourceType, id));
        }
        /**
         * Executes the validate operation with the provided resource.
         *
         * Example:
         *
         * ```typescript
         * const result = await medplum.validateResource({
         *   resourceType: 'Patient',
         *   name: [{ given: ['Alice'], family: 'Smith' }],
         * });
         * ```
         *
         * See the FHIR "$validate" operation for full details: https://www.hl7.org/fhir/resource-operation-validate.html
         *
         * @param resource The FHIR resource.
         * @returns The validate operation outcome.
         */
        validateResource(resource) {
            return this.post(this.fhirUrl(resource.resourceType, '$validate'), resource);
        }
        /**
         * Executes a batch or transaction of FHIR operations.
         *
         * Example:
         *
         * ```typescript
         * await medplum.executeBatch({
         *   "resourceType": "Bundle",
         *   "type": "transaction",
         *   "entry": [
         *     {
         *       "fullUrl": "urn:uuid:61ebe359-bfdc-4613-8bf2-c5e300945f0a",
         *       "resource": {
         *         "resourceType": "Patient",
         *         "name": [{ "use": "official", "given": ["Alice"], "family": "Smith" }],
         *         "gender": "female",
         *         "birthDate": "1974-12-25"
         *       },
         *       "request": {
         *         "method": "POST",
         *         "url": "Patient"
         *       }
         *     },
         *     {
         *       "fullUrl": "urn:uuid:88f151c0-a954-468a-88bd-5ae15c08e059",
         *       "resource": {
         *         "resourceType": "Patient",
         *         "identifier": [{ "system": "http:/example.org/fhir/ids", "value": "234234" }],
         *         "name": [{ "use": "official", "given": ["Bob"], "family": "Jones" }],
         *         "gender": "male",
         *         "birthDate": "1974-12-25"
         *       },
         *       "request": {
         *         "method": "POST",
         *         "url": "Patient",
         *         "ifNoneExist": "identifier=http:/example.org/fhir/ids|234234"
         *       }
         *     }
         *   ]
         * });
         * ```
         *
         * See The FHIR "batch/transaction" section for full details: https://hl7.org/fhir/http.html#transaction
         * @category Batch
         * @param bundle The FHIR batch/transaction bundle.
         * @returns The FHIR batch/transaction response bundle.
         */
        executeBatch(bundle) {
            return this.post('fhir/R4', bundle);
        }
        /**
         * Sends an email using the Medplum Email API.
         *
         * Builds the email using nodemailer MailComposer.
         *
         * Examples:
         *
         * Send a simple text email:
         *
         * ```typescript
         * await medplum.sendEmail({
         *   to: 'alice@example.com',
         *   cc: 'bob@example.com',
         *   subject: 'Hello',
         *   text: 'Hello Alice',
         * });
         * ```
         *
         * Send an email with a `Binary` attachment:
         *
         * ```typescript
         * await medplum.sendEmail({
         *   to: 'alice@example.com',
         *   subject: 'Email with attachment',
         *   text: 'See the attached report',
         *   attachments: [{
         *     filename: 'report.pdf',
         *     path: "Binary/" + binary.id
         *   }]
         * });
         * ```
         *
         * See options here: https://nodemailer.com/extras/mailcomposer/
         * @category Media
         * @param options The MailComposer options.
         * @returns Promise to the operation outcome.
         */
        sendEmail(email) {
            return this.post('email/v1/send', email, 'application/json');
        }
        /**
         * Executes a GraphQL query.
         *
         * Example:
         *
         * ```typescript
         * const result = await medplum.graphql(`{
         *   Patient(id: "123") {
         *     resourceType
         *     id
         *     name {
         *       given
         *       family
         *     }
         *   }
         * }`);
         * ```
         *
         * Advanced queries such as named operations and variable substitution are supported:
         *
         * ```typescript
         * const result = await medplum.graphql(
         *   `query GetPatientById($patientId: ID!) {
         *     Patient(id: $patientId) {
         *       resourceType
         *       id
         *       name {
         *         given
         *         family
         *       }
         *     }
         *   }`,
         *   'GetPatientById',
         *   { patientId: '123' }
         * );
         * ```
         *
         * See the GraphQL documentation for more details: https://graphql.org/learn/
         *
         * See the FHIR GraphQL documentation for FHIR specific details: https://www.hl7.org/fhir/graphql.html
         *
         * @category Read
         * @param query The GraphQL query.
         * @param operationName Optional GraphQL operation name.
         * @param variables Optional GraphQL variables.
         * @param options Optional fetch options.
         * @returns The GraphQL result.
         */
        graphql(query, operationName, variables, options) {
            return this.post(this.fhirUrl('$graphql'), { query, operationName, variables }, JSON_CONTENT_TYPE, options);
        }
        /**
         *
         * Executes the $graph operation on this resource to fetch a Bundle of resources linked to the target resource
         * according to a graph definition
      
         * @category Read
         * @param resourceType The FHIR resource type.
         * @param id The resource ID.
         * @param graphName `name` parameter of the GraphDefinition
         * @returns A Bundle
         */
        readResourceGraph(resourceType, id, graphName) {
            return this.get(`${this.fhirUrl(resourceType, id)}/$graph?graph=${graphName}`);
        }
        /**
         * @category Authentication
         * @returns The Login State
         */
        getActiveLogin() {
            return __classPrivateFieldGet(this, _MedplumClient_storage, "f").getObject('activeLogin');
        }
        /**
         * @category Authentication
         */
        async setActiveLogin(login) {
            __classPrivateFieldSet(this, _MedplumClient_accessToken, login.accessToken, "f");
            __classPrivateFieldSet(this, _MedplumClient_refreshToken, login.refreshToken, "f");
            __classPrivateFieldSet(this, _MedplumClient_profile, undefined, "f");
            __classPrivateFieldSet(this, _MedplumClient_config, undefined, "f");
            __classPrivateFieldGet(this, _MedplumClient_storage, "f").setObject('activeLogin', login);
            __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_addLogin).call(this, login);
            __classPrivateFieldGet(this, _MedplumClient_requestCache, "f").clear();
            __classPrivateFieldSet(this, _MedplumClient_refreshPromise, undefined, "f");
            await __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_refreshProfile).call(this);
        }
        /**
         * @category Authentication
         */
        getAccessToken() {
            return __classPrivateFieldGet(this, _MedplumClient_accessToken, "f");
        }
        /**
         * @category Authentication
         */
        setAccessToken(accessToken) {
            __classPrivateFieldSet(this, _MedplumClient_accessToken, accessToken, "f");
            __classPrivateFieldSet(this, _MedplumClient_refreshToken, undefined, "f");
            __classPrivateFieldSet(this, _MedplumClient_profile, undefined, "f");
            __classPrivateFieldSet(this, _MedplumClient_config, undefined, "f");
        }
        /**
         * @category Authentication
         */
        getLogins() {
            return __classPrivateFieldGet(this, _MedplumClient_storage, "f").getObject('logins') ?? [];
        }
        /**
         * @category Authentication
         */
        isLoading() {
            return !!__classPrivateFieldGet(this, _MedplumClient_profilePromise, "f");
        }
        /**
         * @category User Profile
         */
        getProfile() {
            return __classPrivateFieldGet(this, _MedplumClient_profile, "f");
        }
        /**
         * @category User Profile
         */
        async getProfileAsync() {
            if (__classPrivateFieldGet(this, _MedplumClient_profilePromise, "f")) {
                await __classPrivateFieldGet(this, _MedplumClient_profilePromise, "f");
            }
            return this.getProfile();
        }
        /**
         * @category User Profile
         */
        getUserConfiguration() {
            return __classPrivateFieldGet(this, _MedplumClient_config, "f");
        }
        /**
         * Downloads the URL as a blob.
         *
         * @category Read
         * @param url The URL to request.
         * @returns Promise to the response body as a blob.
         */
        async download(url, options = {}) {
            if (__classPrivateFieldGet(this, _MedplumClient_refreshPromise, "f")) {
                await __classPrivateFieldGet(this, _MedplumClient_refreshPromise, "f");
            }
            __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_addFetchOptionsDefaults).call(this, options);
            const response = await __classPrivateFieldGet(this, _MedplumClient_fetch, "f").call(this, url.toString(), options);
            return response.blob();
        }
        /**
         * Starts a new PKCE flow.
         * These PKCE values are stateful, and must survive redirects and page refreshes.
         */
        async startPkce() {
            const pkceState = getRandomString();
            sessionStorage.setItem('pkceState', pkceState);
            const codeVerifier = getRandomString();
            sessionStorage.setItem('codeVerifier', codeVerifier);
            const arrayHash = await encryptSHA256(codeVerifier);
            const codeChallenge = arrayBufferToBase64(arrayHash).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
            sessionStorage.setItem('codeChallenge', codeChallenge);
        }
        /**
         * Processes an OAuth authorization code.
         * See: https://openid.net/specs/openid-connect-core-1_0.html#TokenRequest
         * @param code The authorization code received by URL parameter.
         */
        processCode(code) {
            const formBody = new URLSearchParams();
            formBody.set('grant_type', 'authorization_code');
            formBody.set('client_id', __classPrivateFieldGet(this, _MedplumClient_clientId, "f"));
            formBody.set('code', code);
            formBody.set('redirect_uri', getBaseUrl());
            const codeVerifier = sessionStorage.getItem('codeVerifier');
            if (codeVerifier) {
                formBody.set('code_verifier', codeVerifier);
            }
            return __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_fetchTokens).call(this, formBody);
        }
        /**
         * Starts a new OAuth2 client credentials flow.
         * See: https://datatracker.ietf.org/doc/html/rfc6749#section-4.4
         * @category Authentication
         * @param clientId The client ID.
         * @param clientSecret The client secret.
         * @returns Promise that resolves to the client profile.
         */
        async startClientLogin(clientId, clientSecret) {
            __classPrivateFieldSet(this, _MedplumClient_clientId, clientId, "f");
            __classPrivateFieldSet(this, _MedplumClient_clientSecret, clientSecret, "f");
            const formBody = new URLSearchParams();
            formBody.set('grant_type', 'client_credentials');
            formBody.set('client_id', clientId);
            formBody.set('client_secret', clientSecret);
            return __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_fetchTokens).call(this, formBody);
        }
    }
    _MedplumClient_fetch = new WeakMap(), _MedplumClient_createPdf = new WeakMap(), _MedplumClient_storage = new WeakMap(), _MedplumClient_requestCache = new WeakMap(), _MedplumClient_cacheTime = new WeakMap(), _MedplumClient_baseUrl = new WeakMap(), _MedplumClient_authorizeUrl = new WeakMap(), _MedplumClient_tokenUrl = new WeakMap(), _MedplumClient_logoutUrl = new WeakMap(), _MedplumClient_onUnauthenticated = new WeakMap(), _MedplumClient_clientId = new WeakMap(), _MedplumClient_clientSecret = new WeakMap(), _MedplumClient_accessToken = new WeakMap(), _MedplumClient_refreshToken = new WeakMap(), _MedplumClient_refreshPromise = new WeakMap(), _MedplumClient_profilePromise = new WeakMap(), _MedplumClient_profile = new WeakMap(), _MedplumClient_config = new WeakMap(), _MedplumClient_instances = new WeakSet(), _MedplumClient_addLogin = function _MedplumClient_addLogin(newLogin) {
        const logins = this.getLogins().filter((login) => login.profile?.reference !== newLogin.profile?.reference);
        logins.push(newLogin);
        __classPrivateFieldGet(this, _MedplumClient_storage, "f").setObject('logins', logins);
    }, _MedplumClient_refreshProfile = async function _MedplumClient_refreshProfile() {
        __classPrivateFieldSet(this, _MedplumClient_profilePromise, new Promise((resolve, reject) => {
            this.get('auth/me')
                .then((result) => {
                __classPrivateFieldSet(this, _MedplumClient_profilePromise, undefined, "f");
                __classPrivateFieldSet(this, _MedplumClient_profile, result.profile, "f");
                __classPrivateFieldSet(this, _MedplumClient_config, result.config, "f");
                this.dispatchEvent({ type: 'change' });
                resolve(__classPrivateFieldGet(this, _MedplumClient_profile, "f"));
            })
                .catch(reject);
        }), "f");
        return __classPrivateFieldGet(this, _MedplumClient_profilePromise, "f");
    }, _MedplumClient_getCacheEntry = function _MedplumClient_getCacheEntry(key, options) {
        if (__classPrivateFieldGet(this, _MedplumClient_cacheTime, "f") <= 0 || options?.cache === 'no-cache' || options?.cache === 'reload') {
            return undefined;
        }
        const entry = __classPrivateFieldGet(this, _MedplumClient_requestCache, "f").get(key);
        if (!entry || entry.requestTime + __classPrivateFieldGet(this, _MedplumClient_cacheTime, "f") < Date.now()) {
            return undefined;
        }
        return entry;
    }, _MedplumClient_setCacheEntry = function _MedplumClient_setCacheEntry(key, value) {
        if (__classPrivateFieldGet(this, _MedplumClient_cacheTime, "f") > 0) {
            __classPrivateFieldGet(this, _MedplumClient_requestCache, "f").set(key, { requestTime: Date.now(), value });
        }
    }, _MedplumClient_request = 
    /**
     * Makes an HTTP request.
     * @param {string} method
     * @param {string} url
     * @param {string=} contentType
     * @param {Object=} body
     */
    async function _MedplumClient_request(method, url, options = {}) {
        if (__classPrivateFieldGet(this, _MedplumClient_refreshPromise, "f")) {
            await __classPrivateFieldGet(this, _MedplumClient_refreshPromise, "f");
        }
        if (!url.startsWith('http')) {
            url = __classPrivateFieldGet(this, _MedplumClient_baseUrl, "f") + url;
        }
        options.method = method;
        __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_addFetchOptionsDefaults).call(this, options);
        const response = await __classPrivateFieldGet(this, _MedplumClient_fetch, "f").call(this, url, options);
        if (response.status === 401) {
            // Refresh and try again
            return __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_handleUnauthenticated).call(this, method, url, options);
        }
        if (response.status === 204 || response.status === 304) {
            // No content or change
            return undefined;
        }
        const obj = await response.json();
        if (response.status >= 400) {
            throw obj;
        }
        return obj;
    }, _MedplumClient_addFetchOptionsDefaults = function _MedplumClient_addFetchOptionsDefaults(options) {
        if (!options.headers) {
            options.headers = {};
        }
        const headers = options.headers;
        headers['X-Medplum'] = 'extended';
        if (!headers['Content-Type']) {
            headers['Content-Type'] = FHIR_CONTENT_TYPE;
        }
        if (__classPrivateFieldGet(this, _MedplumClient_accessToken, "f")) {
            headers['Authorization'] = 'Bearer ' + __classPrivateFieldGet(this, _MedplumClient_accessToken, "f");
        }
        if (!options.cache) {
            options.cache = 'no-cache';
        }
        if (!options.credentials) {
            options.credentials = 'include';
        }
    }, _MedplumClient_setRequestContentType = function _MedplumClient_setRequestContentType(options, contentType) {
        if (!options.headers) {
            options.headers = {};
        }
        const headers = options.headers;
        headers['Content-Type'] = contentType;
    }, _MedplumClient_setRequestBody = function _MedplumClient_setRequestBody(options, data) {
        if (typeof data === 'string' ||
            (typeof Blob !== 'undefined' && data instanceof Blob) ||
            (typeof File !== 'undefined' && data instanceof File) ||
            (typeof Uint8Array !== 'undefined' && data instanceof Uint8Array)) {
            options.body = data;
        }
        else if (data) {
            options.body = JSON.stringify(data);
        }
    }, _MedplumClient_handleUnauthenticated = function _MedplumClient_handleUnauthenticated(method, url, options) {
        if (__classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_refresh).call(this)) {
            return __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_request).call(this, method, url, options);
        }
        this.clear();
        if (__classPrivateFieldGet(this, _MedplumClient_onUnauthenticated, "f")) {
            __classPrivateFieldGet(this, _MedplumClient_onUnauthenticated, "f").call(this);
        }
        return Promise.reject(new Error('Unauthenticated'));
    }, _MedplumClient_requestAuthorization = 
    /**
     * Redirects the user to the login screen for authorization.
     * Clears all auth state including local storage and session storage.
     * See: https://openid.net/specs/openid-connect-core-1_0.html#AuthorizationEndpoint
     */
    async function _MedplumClient_requestAuthorization() {
        await this.startPkce();
        const url = new URL(__classPrivateFieldGet(this, _MedplumClient_authorizeUrl, "f"));
        url.searchParams.set('response_type', 'code');
        url.searchParams.set('state', sessionStorage.getItem('pkceState'));
        url.searchParams.set('client_id', __classPrivateFieldGet(this, _MedplumClient_clientId, "f"));
        url.searchParams.set('redirect_uri', getBaseUrl());
        url.searchParams.set('code_challenge_method', 'S256');
        url.searchParams.set('code_challenge', sessionStorage.getItem('codeChallenge'));
        window.location.assign(url.toString());
    }, _MedplumClient_refresh = function _MedplumClient_refresh() {
        if (__classPrivateFieldGet(this, _MedplumClient_refreshPromise, "f")) {
            return __classPrivateFieldGet(this, _MedplumClient_refreshPromise, "f");
        }
        if (__classPrivateFieldGet(this, _MedplumClient_refreshToken, "f")) {
            const formBody = new URLSearchParams();
            formBody.set('grant_type', 'refresh_token');
            formBody.set('client_id', __classPrivateFieldGet(this, _MedplumClient_clientId, "f"));
            formBody.set('refresh_token', __classPrivateFieldGet(this, _MedplumClient_refreshToken, "f"));
            __classPrivateFieldSet(this, _MedplumClient_refreshPromise, __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_fetchTokens).call(this, formBody), "f");
            return __classPrivateFieldGet(this, _MedplumClient_refreshPromise, "f");
        }
        if (__classPrivateFieldGet(this, _MedplumClient_clientId, "f") && __classPrivateFieldGet(this, _MedplumClient_clientSecret, "f")) {
            __classPrivateFieldSet(this, _MedplumClient_refreshPromise, this.startClientLogin(__classPrivateFieldGet(this, _MedplumClient_clientId, "f"), __classPrivateFieldGet(this, _MedplumClient_clientSecret, "f")), "f");
            return __classPrivateFieldGet(this, _MedplumClient_refreshPromise, "f");
        }
        return undefined;
    }, _MedplumClient_fetchTokens = 
    /**
     * Makes a POST request to the tokens endpoint.
     * See: https://openid.net/specs/openid-connect-core-1_0.html#TokenEndpoint
     * @param formBody Token parameters in URL encoded format.
     */
    async function _MedplumClient_fetchTokens(formBody) {
        return __classPrivateFieldGet(this, _MedplumClient_fetch, "f").call(this, __classPrivateFieldGet(this, _MedplumClient_tokenUrl, "f"), {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: formBody,
            credentials: 'include',
        })
            .then((response) => {
            if (!response.ok) {
                throw new Error('Failed to fetch tokens');
            }
            return response.json();
        })
            .then((tokens) => __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_verifyTokens).call(this, tokens))
            .then(() => this.getProfile());
    }, _MedplumClient_verifyTokens = 
    /**
     * Verifies the tokens received from the auth server.
     * Validates the JWT against the JWKS.
     * See: https://openid.net/specs/openid-connect-core-1_0.html#TokenEndpoint
     * @param tokens
     */
    async function _MedplumClient_verifyTokens(tokens) {
        const token = tokens.access_token;
        // Verify token has not expired
        const tokenPayload = parseJWTPayload(token);
        if (Date.now() >= tokenPayload.exp * 1000) {
            this.clear();
            throw new Error('Token expired');
        }
        // Verify app_client_id
        if (__classPrivateFieldGet(this, _MedplumClient_clientId, "f") && tokenPayload.client_id !== __classPrivateFieldGet(this, _MedplumClient_clientId, "f")) {
            this.clear();
            throw new Error('Token was not issued for this audience');
        }
        await this.setActiveLogin({
            accessToken: token,
            refreshToken: tokens.refresh_token,
            project: tokens.project,
            profile: tokens.profile,
        });
    }, _MedplumClient_setupStorageListener = function _MedplumClient_setupStorageListener() {
        try {
            window.addEventListener('storage', (e) => {
                if (e.key === null || e.key === 'activeLogin') {
                    // Storage events fire when different tabs make changes.
                    // On storage clear (key === null) or activeLogin change (key === 'activeLogin')
                    // Refresh the page to ensure the active login is up to date.
                    window.location.reload();
                }
            });
        }
        catch (err) {
            // Silently ignore if this environment does not support storage events
        }
    };
    /**
     * Returns the base URL for the current page.
     * @category HTTP
     */
    function getBaseUrl() {
        return window.location.protocol + '//' + window.location.host + '/';
    }
    function ensureTrailingSlash(url) {
        if (!url) {
            return url;
        }
        return url.endsWith('/') ? url : url + '/';
    }

    var _ParserBuilder_prefixParselets, _ParserBuilder_infixParselets, _Parser_tokens, _Parser_prefixParselets, _Parser_infixParselets;
    class PrefixOperatorAtom {
        constructor(operator, child) {
            this.operator = operator;
            this.child = child;
        }
        toString() {
            return `${this.operator}(${this.child.toString()})`;
        }
    }
    class InfixOperatorAtom {
        constructor(operator, left, right) {
            this.operator = operator;
            this.left = left;
            this.right = right;
        }
        toString() {
            return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;
        }
    }
    class ParserBuilder {
        constructor() {
            _ParserBuilder_prefixParselets.set(this, {});
            _ParserBuilder_infixParselets.set(this, {});
        }
        registerInfix(tokenType, parselet) {
            __classPrivateFieldGet(this, _ParserBuilder_infixParselets, "f")[tokenType] = parselet;
            return this;
        }
        registerPrefix(tokenType, parselet) {
            __classPrivateFieldGet(this, _ParserBuilder_prefixParselets, "f")[tokenType] = parselet;
            return this;
        }
        prefix(tokenType, precedence, builder) {
            return this.registerPrefix(tokenType, {
                parse(parser, token) {
                    const right = parser.consumeAndParse(precedence);
                    return builder(token, right);
                },
            });
        }
        infixLeft(tokenType, precedence, builder) {
            return this.registerInfix(tokenType, {
                parse(parser, left, token) {
                    const right = parser.consumeAndParse(precedence);
                    return builder(left, token, right);
                },
                precedence,
            });
        }
        construct(input) {
            return new Parser(input, __classPrivateFieldGet(this, _ParserBuilder_prefixParselets, "f"), __classPrivateFieldGet(this, _ParserBuilder_infixParselets, "f"));
        }
    }
    _ParserBuilder_prefixParselets = new WeakMap(), _ParserBuilder_infixParselets = new WeakMap();
    class Parser {
        constructor(tokens, prefixParselets, infixParselets) {
            _Parser_tokens.set(this, void 0);
            _Parser_prefixParselets.set(this, void 0);
            _Parser_infixParselets.set(this, void 0);
            __classPrivateFieldSet(this, _Parser_tokens, tokens, "f");
            __classPrivateFieldSet(this, _Parser_prefixParselets, prefixParselets, "f");
            __classPrivateFieldSet(this, _Parser_infixParselets, infixParselets, "f");
        }
        hasMore() {
            return __classPrivateFieldGet(this, _Parser_tokens, "f").length > 0;
        }
        match(expected) {
            const token = this.peek();
            if (token?.id !== expected) {
                return false;
            }
            this.consume();
            return true;
        }
        consumeAndParse(precedence = Infinity) {
            const token = this.consume();
            const prefix = __classPrivateFieldGet(this, _Parser_prefixParselets, "f")[token.id];
            if (!prefix) {
                throw Error(`Parse error at "${token.value}" (line ${token.line}, column ${token.column}). No matching prefix parselet.`);
            }
            let left = prefix.parse(this, token);
            while (precedence > this.getPrecedence()) {
                const next = this.consume();
                const infix = this.getInfixParselet(next);
                left = infix.parse(this, left, next);
            }
            return left;
        }
        getPrecedence() {
            const nextToken = this.peek();
            if (!nextToken) {
                return Infinity;
            }
            const parser = this.getInfixParselet(nextToken);
            if (parser) {
                return parser.precedence;
            }
            return Infinity;
        }
        consume(expectedId, expectedValue) {
            if (!__classPrivateFieldGet(this, _Parser_tokens, "f").length) {
                throw Error('Cant consume unknown more tokens.');
            }
            if (expectedId && this.peek()?.id !== expectedId) {
                const actual = this.peek();
                throw Error(`Expected ${expectedId} but got "${actual.id}" at line ${actual.line} column ${actual.column}.`);
            }
            if (expectedValue && this.peek()?.value !== expectedValue) {
                const actual = this.peek();
                throw Error(`Expected "${expectedValue}" but got "${actual.value}" at line ${actual.line} column ${actual.column}.`);
            }
            return __classPrivateFieldGet(this, _Parser_tokens, "f").shift();
        }
        peek() {
            return __classPrivateFieldGet(this, _Parser_tokens, "f").length > 0 ? __classPrivateFieldGet(this, _Parser_tokens, "f")[0] : undefined;
        }
        removeComments() {
            __classPrivateFieldSet(this, _Parser_tokens, __classPrivateFieldGet(this, _Parser_tokens, "f").filter((t) => t.id !== 'Comment'), "f");
        }
        getInfixParselet(token) {
            return __classPrivateFieldGet(this, _Parser_infixParselets, "f")[token.id === 'Symbol' ? token.value : token.id];
        }
    }
    _Parser_tokens = new WeakMap(), _Parser_prefixParselets = new WeakMap(), _Parser_infixParselets = new WeakMap();

    var _Tokenizer_instances, _Tokenizer_str, _Tokenizer_keywords, _Tokenizer_operators, _Tokenizer_result, _Tokenizer_pos, _Tokenizer_markStack, _Tokenizer_prevToken, _Tokenizer_peekToken, _Tokenizer_consumeToken, _Tokenizer_consumeWhitespace, _Tokenizer_consumeMultiLineComment, _Tokenizer_consumeSingleLineComment, _Tokenizer_consumeString, _Tokenizer_consumeBacktickSymbol, _Tokenizer_consumeDateTime, _Tokenizer_consumeNumber, _Tokenizer_consumeSymbol, _Tokenizer_consumeOperator, _Tokenizer_consumeWhile, _Tokenizer_curr, _Tokenizer_prev, _Tokenizer_peek, _Tokenizer_mark, _Tokenizer_reset, _Tokenizer_advance, _Tokenizer_buildToken;
    const STANDARD_UNITS = [
        'year',
        'years',
        'month',
        'months',
        'week',
        'weeks',
        'day',
        'days',
        'hour',
        'hours',
        'minute',
        'minutes',
        'second',
        'seconds',
        'millisecond',
        'milliseconds',
    ];
    class Tokenizer {
        constructor(str, keywords, operators) {
            _Tokenizer_instances.add(this);
            _Tokenizer_str.set(this, void 0);
            _Tokenizer_keywords.set(this, void 0);
            _Tokenizer_operators.set(this, void 0);
            _Tokenizer_result.set(this, []);
            _Tokenizer_pos.set(this, { index: 0, line: 1, column: 0 });
            _Tokenizer_markStack.set(this, []);
            __classPrivateFieldSet(this, _Tokenizer_str, str, "f");
            __classPrivateFieldSet(this, _Tokenizer_keywords, keywords, "f");
            __classPrivateFieldSet(this, _Tokenizer_operators, operators, "f");
        }
        tokenize() {
            while (__classPrivateFieldGet(this, _Tokenizer_pos, "f").index < __classPrivateFieldGet(this, _Tokenizer_str, "f").length) {
                const token = __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeToken).call(this);
                if (token) {
                    __classPrivateFieldGet(this, _Tokenizer_result, "f").push(token);
                }
            }
            return __classPrivateFieldGet(this, _Tokenizer_result, "f");
        }
    }
    _Tokenizer_str = new WeakMap(), _Tokenizer_keywords = new WeakMap(), _Tokenizer_operators = new WeakMap(), _Tokenizer_result = new WeakMap(), _Tokenizer_pos = new WeakMap(), _Tokenizer_markStack = new WeakMap(), _Tokenizer_instances = new WeakSet(), _Tokenizer_prevToken = function _Tokenizer_prevToken() {
        return __classPrivateFieldGet(this, _Tokenizer_result, "f").slice(-1)[0];
    }, _Tokenizer_peekToken = function _Tokenizer_peekToken() {
        __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_mark).call(this);
        const token = __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeToken).call(this);
        __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_reset).call(this);
        return token;
    }, _Tokenizer_consumeToken = function _Tokenizer_consumeToken() {
        __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeWhitespace).call(this);
        const c = __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_curr).call(this);
        if (!c) {
            return undefined;
        }
        __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_mark).call(this);
        const next = __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_peek).call(this);
        if (c === '/' && next === '*') {
            return __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeMultiLineComment).call(this);
        }
        if (c === '/' && next === '/') {
            return __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeSingleLineComment).call(this);
        }
        if (c === "'" || c === '"') {
            return __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeString).call(this, c);
        }
        if (c === '`') {
            return __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeBacktickSymbol).call(this);
        }
        if (c === '@') {
            return __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeDateTime).call(this);
        }
        if (c.match(/\d/)) {
            return __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeNumber).call(this);
        }
        if (c.match(/\w/)) {
            return __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeSymbol).call(this);
        }
        if (c === '$' && next.match(/\w/)) {
            return __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeSymbol).call(this);
        }
        return __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeOperator).call(this);
    }, _Tokenizer_consumeWhitespace = function _Tokenizer_consumeWhitespace() {
        __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeWhile).call(this, () => __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_curr).call(this).match(/\s/));
    }, _Tokenizer_consumeMultiLineComment = function _Tokenizer_consumeMultiLineComment() {
        const start = __classPrivateFieldGet(this, _Tokenizer_pos, "f").index;
        __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeWhile).call(this, () => __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_curr).call(this) !== '*' || __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_peek).call(this) !== '/');
        __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_advance).call(this);
        __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_advance).call(this);
        return __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_buildToken).call(this, 'Comment', __classPrivateFieldGet(this, _Tokenizer_str, "f").substring(start, __classPrivateFieldGet(this, _Tokenizer_pos, "f").index));
    }, _Tokenizer_consumeSingleLineComment = function _Tokenizer_consumeSingleLineComment() {
        return __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_buildToken).call(this, 'Comment', __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeWhile).call(this, () => __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_curr).call(this) !== '\n'));
    }, _Tokenizer_consumeString = function _Tokenizer_consumeString(endChar) {
        __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_advance).call(this);
        const result = __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_buildToken).call(this, 'String', __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeWhile).call(this, () => __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_prev).call(this) === '\\' || __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_curr).call(this) !== endChar));
        __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_advance).call(this);
        return result;
    }, _Tokenizer_consumeBacktickSymbol = function _Tokenizer_consumeBacktickSymbol() {
        __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_advance).call(this);
        const result = __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_buildToken).call(this, 'Symbol', __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeWhile).call(this, () => __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_curr).call(this) !== '`'));
        __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_advance).call(this);
        return result;
    }, _Tokenizer_consumeDateTime = function _Tokenizer_consumeDateTime() {
        __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_advance).call(this); // Consume "@"
        const start = __classPrivateFieldGet(this, _Tokenizer_pos, "f").index;
        __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeWhile).call(this, () => __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_curr).call(this).match(/[\d-]/));
        if (__classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_curr).call(this) === 'T') {
            __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_advance).call(this);
            __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeWhile).call(this, () => __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_curr).call(this).match(/[\d:]/));
            if (__classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_curr).call(this) === '.' && __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_peek).call(this).match(/\d/)) {
                __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_advance).call(this);
                __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeWhile).call(this, () => __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_curr).call(this).match(/\d/));
            }
            if (__classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_curr).call(this) === 'Z') {
                __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_advance).call(this);
            }
            else if (__classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_curr).call(this) === '+' || __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_curr).call(this) === '-') {
                __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_advance).call(this);
                __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeWhile).call(this, () => __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_curr).call(this).match(/[\d:]/));
            }
        }
        return __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_buildToken).call(this, 'DateTime', __classPrivateFieldGet(this, _Tokenizer_str, "f").substring(start, __classPrivateFieldGet(this, _Tokenizer_pos, "f").index));
    }, _Tokenizer_consumeNumber = function _Tokenizer_consumeNumber() {
        const start = __classPrivateFieldGet(this, _Tokenizer_pos, "f").index;
        let id = 'Number';
        __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeWhile).call(this, () => __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_curr).call(this).match(/\d/));
        if (__classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_curr).call(this) === '.' && __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_peek).call(this).match(/\d/)) {
            __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_advance).call(this);
            __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeWhile).call(this, () => __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_curr).call(this).match(/\d/));
        }
        if (__classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_curr).call(this) === ' ') {
            if (isUnitToken(__classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_peekToken).call(this))) {
                id = 'Quantity';
                __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeToken).call(this);
            }
        }
        return __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_buildToken).call(this, id, __classPrivateFieldGet(this, _Tokenizer_str, "f").substring(start, __classPrivateFieldGet(this, _Tokenizer_pos, "f").index));
    }, _Tokenizer_consumeSymbol = function _Tokenizer_consumeSymbol() {
        const value = __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_consumeWhile).call(this, () => __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_curr).call(this).match(/[$\w]/));
        if (__classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_prevToken).call(this)?.value !== '.' && __classPrivateFieldGet(this, _Tokenizer_keywords, "f").includes(value)) {
            return __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_buildToken).call(this, value, value);
        }
        return __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_buildToken).call(this, 'Symbol', value);
    }, _Tokenizer_consumeOperator = function _Tokenizer_consumeOperator() {
        const c = __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_curr).call(this);
        const next = __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_peek).call(this);
        const twoCharOp = c + next;
        if (__classPrivateFieldGet(this, _Tokenizer_operators, "f").includes(twoCharOp)) {
            __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_advance).call(this);
            __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_advance).call(this);
            return __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_buildToken).call(this, twoCharOp, twoCharOp);
        }
        __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_advance).call(this);
        return __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_buildToken).call(this, c, c);
    }, _Tokenizer_consumeWhile = function _Tokenizer_consumeWhile(condition) {
        const start = __classPrivateFieldGet(this, _Tokenizer_pos, "f").index;
        while (__classPrivateFieldGet(this, _Tokenizer_pos, "f").index < __classPrivateFieldGet(this, _Tokenizer_str, "f").length && condition()) {
            __classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_advance).call(this);
        }
        return __classPrivateFieldGet(this, _Tokenizer_str, "f").substring(start, __classPrivateFieldGet(this, _Tokenizer_pos, "f").index);
    }, _Tokenizer_curr = function _Tokenizer_curr() {
        return __classPrivateFieldGet(this, _Tokenizer_str, "f")[__classPrivateFieldGet(this, _Tokenizer_pos, "f").index];
    }, _Tokenizer_prev = function _Tokenizer_prev() {
        return __classPrivateFieldGet(this, _Tokenizer_str, "f")[__classPrivateFieldGet(this, _Tokenizer_pos, "f").index - 1] ?? '';
    }, _Tokenizer_peek = function _Tokenizer_peek() {
        return __classPrivateFieldGet(this, _Tokenizer_str, "f")[__classPrivateFieldGet(this, _Tokenizer_pos, "f").index + 1] ?? '';
    }, _Tokenizer_mark = function _Tokenizer_mark() {
        __classPrivateFieldGet(this, _Tokenizer_markStack, "f").push({ ...__classPrivateFieldGet(this, _Tokenizer_pos, "f") });
    }, _Tokenizer_reset = function _Tokenizer_reset() {
        const mark = __classPrivateFieldGet(this, _Tokenizer_markStack, "f").pop();
        if (!mark) {
            throw new Error('No mark to reset to');
        }
        __classPrivateFieldGet(this, _Tokenizer_pos, "f").index = mark.index;
        __classPrivateFieldGet(this, _Tokenizer_pos, "f").line = mark.line;
        __classPrivateFieldGet(this, _Tokenizer_pos, "f").column = mark.column;
    }, _Tokenizer_advance = function _Tokenizer_advance() {
        __classPrivateFieldGet(this, _Tokenizer_pos, "f").index++;
        if (__classPrivateFieldGet(this, _Tokenizer_instances, "m", _Tokenizer_curr).call(this) === '\n') {
            __classPrivateFieldGet(this, _Tokenizer_pos, "f").line++;
            __classPrivateFieldGet(this, _Tokenizer_pos, "f").column = 0;
        }
        else {
            __classPrivateFieldGet(this, _Tokenizer_pos, "f").column++;
        }
    }, _Tokenizer_buildToken = function _Tokenizer_buildToken(id, value) {
        const mark = __classPrivateFieldGet(this, _Tokenizer_markStack, "f").pop();
        if (!mark) {
            throw new Error('No mark for token');
        }
        return {
            id,
            value,
            ...mark,
        };
    };
    function isUnitToken(token) {
        if (token) {
            if (token.id === 'String') {
                return true;
            }
            if (token.id === 'Symbol' && STANDARD_UNITS.includes(token.value)) {
                return true;
            }
        }
        return false;
    }

    function parseDateString(str) {
        if (str.startsWith('T')) {
            // If a time string,
            // then normalize to full length.
            return str + 'T00:00:00.000Z'.substring(str.length);
        }
        if (str.length <= 10) {
            // If a local date (i.e., "2021-01-01"),
            // then return as-is.
            return str;
        }
        try {
            // Try to normalize to UTC
            return new Date(str).toISOString();
        }
        catch (e) {
            // Fallback to original input
            // This happens on unsupported time formats such as "2021-01-01T12"
            return str;
        }
    }

    /**
     * Returns a single element array with a typed boolean value.
     * @param value The primitive boolean value.
     * @returns Single element array with a typed boolean value.
     */
    function booleanToTypedValue(value) {
        return [{ type: exports.PropertyType.boolean, value }];
    }
    /**
     * Returns a "best guess" TypedValue for a given value.
     * @param value The unknown value to check.
     * @returns A "best guess" TypedValue for the given value.
     */
    function toTypedValue(value) {
        if (value === null || value === undefined) {
            return { type: 'undefined', value: undefined };
        }
        else if (Number.isSafeInteger(value)) {
            return { type: exports.PropertyType.integer, value };
        }
        else if (typeof value === 'number') {
            return { type: exports.PropertyType.decimal, value };
        }
        else if (typeof value === 'boolean') {
            return { type: exports.PropertyType.boolean, value };
        }
        else if (typeof value === 'string') {
            return { type: exports.PropertyType.string, value };
        }
        else if (isQuantity(value)) {
            return { type: exports.PropertyType.Quantity, value };
        }
        else if (typeof value === 'object' && 'resourceType' in value) {
            return { type: value.resourceType, value };
        }
        else {
            return { type: exports.PropertyType.BackboneElement, value };
        }
    }
    /**
     * Converts unknown object into a JavaScript boolean.
     * Note that this is different than the FHIRPath "toBoolean",
     * which has particular semantics around arrays, empty arrays, and type conversions.
     * @param obj Any value or array of values.
     * @returns The converted boolean value according to FHIRPath rules.
     */
    function toJsBoolean(obj) {
        return obj.length === 0 ? false : !!obj[0].value;
    }
    /**
     * Returns the value of the property and the property type.
     * Some property definitions support multiple types.
     * For example, "Observation.value[x]" can be "valueString", "valueInteger", "valueQuantity", etc.
     * According to the spec, there can only be one property for a given element definition.
     * This function returns the value and the type.
     * @param input The base context (FHIR resource or backbone element).
     * @param path The property path.
     * @returns The value of the property and the property type.
     */
    function getTypedPropertyValue(input, path) {
        if (!input?.value) {
            return undefined;
        }
        const elementDefinition = getElementDefinition(input.type, path);
        if (elementDefinition) {
            const typedResult = getTypedPropertyValueWithSchema(input, path, elementDefinition);
            if (typedResult) {
                return typedResult;
            }
        }
        return getTypedPropertyValueWithoutSchema(input, path);
    }
    /**
     * Returns the value of the property and the property type using a type schema.
     * @param input The base context (FHIR resource or backbone element).
     * @param path The property path.
     * @param property The property element definition.
     * @returns The value of the property and the property type.
     */
    function getTypedPropertyValueWithSchema(input, path, property) {
        const types = property.type;
        if (!types || types.length === 0) {
            return undefined;
        }
        let resultValue = undefined;
        let resultType = 'undefined';
        if (types.length === 1) {
            resultValue = input.value[path];
            resultType = types[0].code;
        }
        else {
            for (const type of types) {
                const path2 = path.replace('[x]', '') + capitalize(type.code);
                if (path2 in input.value) {
                    resultValue = input.value[path2];
                    resultType = type.code;
                    break;
                }
            }
        }
        if (isEmpty(resultValue)) {
            return undefined;
        }
        if (resultType === 'Element' || resultType === 'BackboneElement') {
            resultType = buildTypeName(property.path?.split('.'));
        }
        if (Array.isArray(resultValue)) {
            return resultValue.map((element) => toTypedValueWithType(element, resultType));
        }
        else {
            return toTypedValueWithType(resultValue, resultType);
        }
    }
    function toTypedValueWithType(value, type) {
        if (type === 'Resource' && typeof value === 'object' && 'resourceType' in value) {
            type = value.resourceType;
        }
        return { type, value };
    }
    /**
     * Returns the value of the property and the property type using a type schema.
     * Note that because the type schema is not available, this function may be inaccurate.
     * In some cases, that is the desired behavior.
     * @param typedValue The base context (FHIR resource or backbone element).
     * @param path The property path.
     * @returns The value of the property and the property type.
     */
    function getTypedPropertyValueWithoutSchema(typedValue, path) {
        const input = typedValue.value;
        if (!input || typeof input !== 'object') {
            return undefined;
        }
        let result = undefined;
        if (path in input) {
            result = input[path];
        }
        else {
            // Only support property names that would be valid types
            // Examples:
            // value + valueString = ok, because "string" is valid
            // value + valueDecimal = ok, because "decimal" is valid
            // id + identifiier = not ok, because "entifier" is not a valid type
            // resource + resourceType = not ok, because "type" is not a valid type
            for (const propertyType in exports.PropertyType) {
                const propertyName = path + capitalize(propertyType);
                if (propertyName in input) {
                    result = input[propertyName];
                    break;
                }
            }
        }
        if (isEmpty(result)) {
            return undefined;
        }
        if (Array.isArray(result)) {
            return result.map(toTypedValue);
        }
        else {
            return toTypedValue(result);
        }
    }
    /**
     * Removes duplicates in array using FHIRPath equality rules.
     * @param arr The input array.
     * @returns The result array with duplicates removed.
     */
    function removeDuplicates(arr) {
        const result = [];
        for (const i of arr) {
            let found = false;
            for (const j of result) {
                if (toJsBoolean(fhirPathEquals(i, j))) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                result.push(i);
            }
        }
        return result;
    }
    /**
     * Returns a negated FHIRPath boolean expression.
     * @param input The input array.
     * @returns The negated type value array.
     */
    function fhirPathNot(input) {
        return booleanToTypedValue(!toJsBoolean(input));
    }
    /**
     * Determines if two arrays are equal according to FHIRPath equality rules.
     * @param x The first array.
     * @param y The second array.
     * @returns FHIRPath true if the arrays are equal.
     */
    function fhirPathArrayEquals(x, y) {
        if (x.length === 0 || y.length === 0) {
            return [];
        }
        if (x.length !== y.length) {
            return booleanToTypedValue(false);
        }
        return booleanToTypedValue(x.every((val, index) => toJsBoolean(fhirPathEquals(val, y[index]))));
    }
    /**
     * Determines if two values are equal according to FHIRPath equality rules.
     * @param x The first value.
     * @param y The second value.
     * @returns True if equal.
     */
    function fhirPathEquals(x, y) {
        const xValue = x.value;
        const yValue = y.value;
        if (typeof xValue === 'number' && typeof yValue === 'number') {
            return booleanToTypedValue(Math.abs(xValue - yValue) < 1e-8);
        }
        if (isQuantity(xValue) && isQuantity(yValue)) {
            return booleanToTypedValue(isQuantityEquivalent(xValue, yValue));
        }
        if (typeof xValue === 'object' && typeof yValue === 'object') {
            return booleanToTypedValue(deepEquals(x, y));
        }
        return booleanToTypedValue(xValue === yValue);
    }
    /**
     * Determines if two arrays are equivalent according to FHIRPath equality rules.
     * @param x The first array.
     * @param y The second array.
     * @returns FHIRPath true if the arrays are equivalent.
     */
    function fhirPathArrayEquivalent(x, y) {
        if (x.length === 0 && y.length === 0) {
            return booleanToTypedValue(true);
        }
        if (x.length !== y.length) {
            return booleanToTypedValue(false);
        }
        x.sort(fhirPathEquivalentCompare);
        y.sort(fhirPathEquivalentCompare);
        return booleanToTypedValue(x.every((val, index) => toJsBoolean(fhirPathEquivalent(val, y[index]))));
    }
    /**
     * Determines if two values are equivalent according to FHIRPath equality rules.
     * @param x The first value.
     * @param y The second value.
     * @returns True if equivalent.
     */
    function fhirPathEquivalent(x, y) {
        const xValue = x.value;
        const yValue = y.value;
        if (typeof xValue === 'number' && typeof yValue === 'number') {
            // Use more generous threshold than equality
            // Decimal: values must be equal, comparison is done on values rounded to the precision of the least precise operand.
            // Trailing zeroes after the decimal are ignored in determining precision.
            return booleanToTypedValue(Math.abs(xValue - yValue) < 0.01);
        }
        if (isQuantity(xValue) && isQuantity(yValue)) {
            return booleanToTypedValue(isQuantityEquivalent(xValue, yValue));
        }
        if (typeof xValue === 'object' && typeof yValue === 'object') {
            return booleanToTypedValue(deepEquals(xValue, yValue));
        }
        if (typeof xValue === 'string' && typeof yValue === 'string') {
            // String: the strings must be the same, ignoring case and locale, and normalizing whitespace
            // (see String Equivalence for more details).
            return booleanToTypedValue(xValue.toLowerCase() === yValue.toLowerCase());
        }
        return booleanToTypedValue(xValue === yValue);
    }
    /**
     * Returns the sort order of two values for FHIRPath array equivalence.
     * @param x The first value.
     * @param y The second value.
     * @returns The sort order of the values.
     */
    function fhirPathEquivalentCompare(x, y) {
        const xValue = x.value;
        const yValue = y.value;
        if (typeof xValue === 'number' && typeof yValue === 'number') {
            return xValue - yValue;
        }
        if (typeof xValue === 'string' && typeof yValue === 'string') {
            return xValue.localeCompare(yValue);
        }
        return 0;
    }
    /**
     * Determines if the typed value is the desired type.
     * @param typedValue The typed value to check.
     * @param desiredType The desired type name.
     * @returns True if the typed value is of the desired type.
     */
    function fhirPathIs(typedValue, desiredType) {
        const { value } = typedValue;
        if (value === undefined || value === null) {
            return false;
        }
        switch (desiredType) {
            case 'Boolean':
                return typeof value === 'boolean';
            case 'Decimal':
            case 'Integer':
                return typeof value === 'number';
            case 'Date':
                return typeof value === 'string' && !!value.match(/^\d{4}(-\d{2}(-\d{2})?)?/);
            case 'DateTime':
                return typeof value === 'string' && !!value.match(/^\d{4}(-\d{2}(-\d{2})?)?T/);
            case 'Time':
                return typeof value === 'string' && !!value.match(/^T\d/);
            case 'Period':
                return isPeriod(value);
            case 'Quantity':
                return isQuantity(value);
            default:
                return typeof value === 'object' && value?.resourceType === desiredType;
        }
    }
    /**
     * Determines if the input is a Period object.
     * This is heuristic based, as we do not have strong typing at runtime.
     * @param input The input value.
     * @returns True if the input is a period.
     */
    function isPeriod(input) {
        return !!(input && typeof input === 'object' && 'start' in input);
    }
    /**
     * Determines if the input is a Quantity object.
     * This is heuristic based, as we do not have strong typing at runtime.
     * @param input The input value.
     * @returns True if the input is a quantity.
     */
    function isQuantity(input) {
        return !!(input && typeof input === 'object' && 'value' in input && typeof input.value === 'number');
    }
    function isQuantityEquivalent(x, y) {
        return (Math.abs(x.value - y.value) < 0.01 &&
            (x.unit === y.unit || x.code === y.code || x.unit === y.code || x.code === y.unit));
    }
    /**
     * Resource equality.
     * See: https://dmitripavlutin.com/how-to-compare-objects-in-javascript/#4-deep-equality
     * @param object1 The first object.
     * @param object2 The second object.
     * @returns True if the objects are equal.
     */
    function deepEquals(object1, object2) {
        const keys1 = Object.keys(object1);
        const keys2 = Object.keys(object2);
        if (keys1.length !== keys2.length) {
            return false;
        }
        for (const key of keys1) {
            const val1 = object1[key];
            const val2 = object2[key];
            if (isObject(val1) && isObject(val2)) {
                if (!deepEquals(val1, val2)) {
                    return false;
                }
            }
            else {
                if (val1 !== val2) {
                    return false;
                }
            }
        }
        return true;
    }
    function isObject(obj) {
        return obj !== null && typeof obj === 'object';
    }

    /**
     * Temporary placholder for unimplemented methods.
     */
    const stub = () => [];
    const functions = {
        /*
         * 5.1 Existence
         * See: https://hl7.org/fhirpath/#existence
         */
        /**
         * Returns true if the input collection is empty ({ }) and false otherwise.
         *
         * See: https://hl7.org/fhirpath/#empty-boolean
         *
         * @param input The input collection.
         * @returns True if the input collection is empty ({ }) and false otherwise.
         */
        empty: (input) => {
            return booleanToTypedValue(input.length === 0);
        },
        /**
         * Returns true if the collection has unknown elements, and false otherwise.
         * This is the opposite of empty(), and as such is a shorthand for empty().not().
         * If the input collection is empty ({ }), the result is false.
         *
         * The function can also take an optional criteria to be applied to the collection
         * prior to the determination of the exists. In this case, the function is shorthand
         * for where(criteria).exists().
         *
         * See: https://hl7.org/fhirpath/#existscriteria-expression-boolean
         *
         * @param input
         * @param criteria
         * @returns True if the collection has unknown elements, and false otherwise.
         */
        exists: (input, criteria) => {
            if (criteria) {
                return booleanToTypedValue(input.filter((e) => toJsBoolean(criteria.eval([e]))).length > 0);
            }
            else {
                return booleanToTypedValue(input.length > 0);
            }
        },
        /**
         * Returns true if for every element in the input collection, criteria evaluates to true.
         * Otherwise, the result is false.
         *
         * If the input collection is empty ({ }), the result is true.
         *
         * See: https://hl7.org/fhirpath/#allcriteria-expression-boolean
         *
         * @param input The input collection.
         * @param criteria The evaluation criteria.
         * @returns True if for every element in the input collection, criteria evaluates to true.
         */
        all: (input, criteria) => {
            return booleanToTypedValue(input.every((e) => toJsBoolean(criteria.eval([e]))));
        },
        /**
         * Takes a collection of Boolean values and returns true if all the items are true.
         * If unknown items are false, the result is false.
         * If the input is empty ({ }), the result is true.
         *
         * See: https://hl7.org/fhirpath/#alltrue-boolean
         *
         * @param input The input collection.
         * @param criteria The evaluation criteria.
         * @returns True if all the items are true.
         */
        allTrue: (input) => {
            for (const value of input) {
                if (!value.value) {
                    return booleanToTypedValue(false);
                }
            }
            return booleanToTypedValue(true);
        },
        /**
         * Takes a collection of Boolean values and returns true if unknown of the items are true.
         * If all the items are false, or if the input is empty ({ }), the result is false.
         *
         * See: https://hl7.org/fhirpath/#anytrue-boolean
         *
         * @param input The input collection.
         * @param criteria The evaluation criteria.
         * @returns True if unknown of the items are true.
         */
        anyTrue: (input) => {
            for (const value of input) {
                if (value.value) {
                    return booleanToTypedValue(true);
                }
            }
            return booleanToTypedValue(false);
        },
        /**
         * Takes a collection of Boolean values and returns true if all the items are false.
         * If unknown items are true, the result is false.
         * If the input is empty ({ }), the result is true.
         *
         * See: https://hl7.org/fhirpath/#allfalse-boolean
         *
         * @param input The input collection.
         * @param criteria The evaluation criteria.
         * @returns True if all the items are false.
         */
        allFalse: (input) => {
            for (const value of input) {
                if (value.value) {
                    return booleanToTypedValue(false);
                }
            }
            return booleanToTypedValue(true);
        },
        /**
         * Takes a collection of Boolean values and returns true if unknown of the items are false.
         * If all the items are true, or if the input is empty ({ }), the result is false.
         *
         * See: https://hl7.org/fhirpath/#anyfalse-boolean
         *
         * @param input The input collection.
         * @param criteria The evaluation criteria.
         * @returns True if for every element in the input collection, criteria evaluates to true.
         */
        anyFalse: (input) => {
            for (const value of input) {
                if (!value.value) {
                    return booleanToTypedValue(true);
                }
            }
            return booleanToTypedValue(false);
        },
        /**
         * Returns true if all items in the input collection are members of the collection passed
         * as the other argument. Membership is determined using the = (Equals) (=) operation.
         *
         * Conceptually, this function is evaluated by testing each element in the input collection
         * for membership in the other collection, with a default of true. This means that if the
         * input collection is empty ({ }), the result is true, otherwise if the other collection
         * is empty ({ }), the result is false.
         *
         * See: http://hl7.org/fhirpath/#subsetofother-collection-boolean
         */
        subsetOf: stub,
        /**
         * Returns true if all items in the collection passed as the other argument are members of
         * the input collection. Membership is determined using the = (Equals) (=) operation.
         *
         * Conceptually, this function is evaluated by testing each element in the other collection
         * for membership in the input collection, with a default of true. This means that if the
         * other collection is empty ({ }), the result is true, otherwise if the input collection
         * is empty ({ }), the result is false.
         *
         * See: http://hl7.org/fhirpath/#supersetofother-collection-boolean
         */
        supersetOf: stub,
        /**
         * Returns the integer count of the number of items in the input collection.
         * Returns 0 when the input collection is empty.
         *
         * See: https://hl7.org/fhirpath/#count-integer
         *
         * @param input The input collection.
         * @returns The integer count of the number of items in the input collection.
         */
        count: (input) => {
            return [{ type: exports.PropertyType.integer, value: input.length }];
        },
        /**
         * Returns a collection containing only the unique items in the input collection.
         * To determine whether two items are the same, the = (Equals) (=) operator is used,
         * as defined below.
         *
         * If the input collection is empty ({ }), the result is empty.
         *
         * Note that the order of elements in the input collection is not guaranteed to be
         * preserved in the result.
         *
         * See: https://hl7.org/fhirpath/#distinct-collection
         *
         * @param input The input collection.
         * @returns The integer count of the number of items in the input collection.
         */
        distinct: (input) => {
            const result = [];
            for (const value of input) {
                if (!result.some((e) => e.value === value.value)) {
                    result.push(value);
                }
            }
            return result;
        },
        /**
         * Returns true if all the items in the input collection are distinct.
         * To determine whether two items are distinct, the = (Equals) (=) operator is used,
         * as defined below.
         *
         * See: https://hl7.org/fhirpath/#isdistinct-boolean
         *
         * @param input The input collection.
         * @returns The integer count of the number of items in the input collection.
         */
        isDistinct: (input) => {
            return booleanToTypedValue(input.length === functions.distinct(input).length);
        },
        /*
         * 5.2 Filtering and projection
         */
        /**
         * Returns a collection containing only those elements in the input collection
         * for which the stated criteria expression evaluates to true.
         * Elements for which the expression evaluates to false or empty ({ }) are not
         * included in the result.
         *
         * If the input collection is empty ({ }), the result is empty.
         *
         * If the result of evaluating the condition is other than a single boolean value,
         * the evaluation will end and signal an error to the calling environment,
         * consistent with singleton evaluation of collections behavior.
         *
         * See: https://hl7.org/fhirpath/#wherecriteria-expression-collection
         *
         * @param input The input collection.
         * @param condition The condition atom.
         * @returns A collection containing only those elements in the input collection for which the stated criteria expression evaluates to true.
         */
        where: (input, criteria) => {
            return input.filter((e) => toJsBoolean(criteria.eval([e])));
        },
        /**
         * Evaluates the projection expression for each item in the input collection.
         * The result of each evaluation is added to the output collection. If the
         * evaluation results in a collection with multiple items, all items are added
         * to the output collection (collections resulting from evaluation of projection
         * are flattened). This means that if the evaluation for an element results in
         * the empty collection ({ }), no element is added to the result, and that if
         * the input collection is empty ({ }), the result is empty as well.
         *
         * See: http://hl7.org/fhirpath/#selectprojection-expression-collection
         */
        select: (input, criteria) => {
            return input.map((e) => criteria.eval([e])).flat();
        },
        /**
         * A version of select that will repeat the projection and add it to the output
         * collection, as long as the projection yields new items (as determined by
         * the = (Equals) (=) operator).
         *
         * See: http://hl7.org/fhirpath/#repeatprojection-expression-collection
         */
        repeat: stub,
        /**
         * Returns a collection that contains all items in the input collection that
         * are of the given type or a subclass thereof. If the input collection is
         * empty ({ }), the result is empty. The type argument is an identifier that
         * must resolve to the name of a type in a model
         *
         * See: http://hl7.org/fhirpath/#oftypetype-type-specifier-collection
         */
        ofType: (input, criteria) => {
            return input.filter((e) => e.type === criteria.name);
        },
        /*
         * 5.3 Subsetting
         */
        /**
         * Will return the single item in the input if there is just one item.
         * If the input collection is empty ({ }), the result is empty.
         * If there are multiple items, an error is signaled to the evaluation environment.
         * This function is useful for ensuring that an error is returned if an assumption
         * about cardinality is violated at run-time.
         *
         * See: https://hl7.org/fhirpath/#single-collection
         *
         * @param input The input collection.
         * @returns The single item in the input if there is just one item.
         */
        single: (input) => {
            if (input.length > 1) {
                throw new Error('Expected input length one for single()');
            }
            return input.length === 0 ? [] : input.slice(0, 1);
        },
        /**
         * Returns a collection containing only the first item in the input collection.
         * This function is equivalent to item[0], so it will return an empty collection if the input collection has no items.
         *
         * See: https://hl7.org/fhirpath/#first-collection
         *
         * @param input The input collection.
         * @returns A collection containing only the first item in the input collection.
         */
        first: (input) => {
            return input.length === 0 ? [] : input.slice(0, 1);
        },
        /**
         * Returns a collection containing only the last item in the input collection.
         * Will return an empty collection if the input collection has no items.
         *
         * See: https://hl7.org/fhirpath/#last-collection
         *
         * @param input The input collection.
         * @returns A collection containing only the last item in the input collection.
         */
        last: (input) => {
            return input.length === 0 ? [] : input.slice(input.length - 1, input.length);
        },
        /**
         * Returns a collection containing all but the first item in the input collection.
         * Will return an empty collection if the input collection has no items, or only one item.
         *
         * See: https://hl7.org/fhirpath/#tail-collection
         *
         * @param input The input collection.
         * @returns A collection containing all but the first item in the input collection.
         */
        tail: (input) => {
            return input.length === 0 ? [] : input.slice(1, input.length);
        },
        /**
         * Returns a collection containing all but the first num items in the input collection.
         * Will return an empty collection if there are no items remaining after the
         * indicated number of items have been skipped, or if the input collection is empty.
         * If num is less than or equal to zero, the input collection is simply returned.
         *
         * See: https://hl7.org/fhirpath/#skipnum-integer-collection
         *
         * @param input The input collection.
         * @returns A collection containing all but the first item in the input collection.
         */
        skip: (input, num) => {
            const numValue = num.eval(input)[0]?.value;
            if (typeof numValue !== 'number') {
                throw new Error('Expected a number for skip(num)');
            }
            if (numValue >= input.length) {
                return [];
            }
            if (numValue <= 0) {
                return input;
            }
            return input.slice(numValue, input.length);
        },
        /**
         * Returns a collection containing the first num items in the input collection,
         * or less if there are less than num items.
         * If num is less than or equal to 0, or if the input collection is empty ({ }),
         * take returns an empty collection.
         *
         * See: https://hl7.org/fhirpath/#takenum-integer-collection
         *
         * @param input The input collection.
         * @returns A collection containing the first num items in the input collection.
         */
        take: (input, num) => {
            const numValue = num.eval(input)[0]?.value;
            if (typeof numValue !== 'number') {
                throw new Error('Expected a number for take(num)');
            }
            if (numValue >= input.length) {
                return input;
            }
            if (numValue <= 0) {
                return [];
            }
            return input.slice(0, numValue);
        },
        /**
         * Returns the set of elements that are in both collections.
         * Duplicate items will be eliminated by this function.
         * Order of items is not guaranteed to be preserved in the result of this function.
         *
         * See: http://hl7.org/fhirpath/#intersectother-collection-collection
         */
        intersect: (input, other) => {
            if (!other) {
                return input;
            }
            const otherArray = other.eval(input);
            const result = [];
            for (const value of input) {
                if (!result.some((e) => e.value === value.value) && otherArray.some((e) => e.value === value.value)) {
                    result.push(value);
                }
            }
            return result;
        },
        /**
         * Returns the set of elements that are not in the other collection.
         * Duplicate items will not be eliminated by this function, and order will be preserved.
         *
         * e.g. (1 | 2 | 3).exclude(2) returns (1 | 3).
         *
         * See: http://hl7.org/fhirpath/#excludeother-collection-collection
         */
        exclude: (input, other) => {
            if (!other) {
                return input;
            }
            const otherArray = other.eval(input);
            const result = [];
            for (const value of input) {
                if (!otherArray.some((e) => e.value === value.value)) {
                    result.push(value);
                }
            }
            return result;
        },
        /*
         * 5.4. Combining
         *
         * See: https://hl7.org/fhirpath/#combining
         */
        /**
         * Merge the two collections into a single collection,
         * eliminating unknown duplicate values (using = (Equals) (=) to determine equality).
         * There is no expectation of order in the resulting collection.
         *
         * In other words, this function returns the distinct list of elements from both inputs.
         *
         * See: http://hl7.org/fhirpath/#unionother-collection
         */
        union: (input, other) => {
            if (!other) {
                return input;
            }
            const otherArray = other.eval(input);
            return removeDuplicates([...input, ...otherArray]);
        },
        /**
         * Merge the input and other collections into a single collection
         * without eliminating duplicate values. Combining an empty collection
         * with a non-empty collection will return the non-empty collection.
         *
         * There is no expectation of order in the resulting collection.
         *
         * See: http://hl7.org/fhirpath/#combineother-collection-collection
         */
        combine: (input, other) => {
            if (!other) {
                return input;
            }
            const otherArray = other.eval(input);
            return [...input, ...otherArray];
        },
        /*
         * 5.5. Conversion
         *
         * See: https://hl7.org/fhirpath/#conversion
         */
        /**
         * The iif function in FHIRPath is an immediate if,
         * also known as a conditional operator (such as C’s ? : operator).
         *
         * The criterion expression is expected to evaluate to a Boolean.
         *
         * If criterion is true, the function returns the value of the true-result argument.
         *
         * If criterion is false or an empty collection, the function returns otherwise-result,
         * unless the optional otherwise-result is not given, in which case the function returns an empty collection.
         *
         * Note that short-circuit behavior is expected in this function. In other words,
         * true-result should only be evaluated if the criterion evaluates to true,
         * and otherwise-result should only be evaluated otherwise. For implementations,
         * this means delaying evaluation of the arguments.
         *
         * @param input
         * @param criterion
         * @param trueResult
         * @param otherwiseResult
         * @returns
         */
        iif: (input, criterion, trueResult, otherwiseResult) => {
            const evalResult = criterion.eval(input);
            if (evalResult.length > 1 || (evalResult.length === 1 && typeof evalResult[0].value !== 'boolean')) {
                throw new Error('Expected criterion to evaluate to a Boolean');
            }
            if (toJsBoolean(evalResult)) {
                return trueResult.eval(input);
            }
            if (otherwiseResult) {
                return otherwiseResult.eval(input);
            }
            return [];
        },
        /**
         * Converts an input collection to a boolean.
         *
         * If the input collection contains a single item, this function will return a single boolean if:
         *   1) the item is a Boolean
         *   2) the item is an Integer and is equal to one of the possible integer representations of Boolean values
         *   3) the item is a Decimal that is equal to one of the possible decimal representations of Boolean values
         *   4) the item is a String that is equal to one of the possible string representations of Boolean values
         *
         * If the item is not one the above types, or the item is a String, Integer, or Decimal, but is not equal to one of the possible values convertible to a Boolean, the result is empty.
         *
         * See: https://hl7.org/fhirpath/#toboolean-boolean
         *
         * @param input
         * @returns
         */
        toBoolean: (input) => {
            if (input.length === 0) {
                return [];
            }
            const [{ value }] = validateInput(input, 1);
            if (typeof value === 'boolean') {
                return [{ type: exports.PropertyType.boolean, value }];
            }
            if (typeof value === 'number') {
                if (value === 0 || value === 1) {
                    return booleanToTypedValue(!!value);
                }
            }
            if (typeof value === 'string') {
                const lowerStr = value.toLowerCase();
                if (['true', 't', 'yes', 'y', '1', '1.0'].includes(lowerStr)) {
                    return booleanToTypedValue(true);
                }
                if (['false', 'f', 'no', 'n', '0', '0.0'].includes(lowerStr)) {
                    return booleanToTypedValue(false);
                }
            }
            return [];
        },
        /**
         * If the input collection contains a single item, this function will return true if:
         *   1) the item is a Boolean
         *   2) the item is an Integer that is equal to one of the possible integer representations of Boolean values
         *   3) the item is a Decimal that is equal to one of the possible decimal representations of Boolean values
         *   4) the item is a String that is equal to one of the possible string representations of Boolean values
         *
         * If the item is not one of the above types, or the item is a String, Integer, or Decimal, but is not equal to one of the possible values convertible to a Boolean, the result is false.
         *
         * Possible values for Integer, Decimal, and String are described in the toBoolean() function.
         *
         * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
         *
         * If the input collection is empty, the result is empty.
         *
         * See: http://hl7.org/fhirpath/#convertstoboolean-boolean
         *
         * @param input
         * @returns
         */
        convertsToBoolean: (input) => {
            if (input.length === 0) {
                return [];
            }
            return booleanToTypedValue(functions.toBoolean(input).length === 1);
        },
        /**
         * Returns the integer representation of the input.
         *
         * If the input collection contains a single item, this function will return a single integer if:
         *   1) the item is an Integer
         *   2) the item is a String and is convertible to an integer
         *   3) the item is a Boolean, where true results in a 1 and false results in a 0.
         *
         * If the item is not one the above types, the result is empty.
         *
         * If the item is a String, but the string is not convertible to an integer (using the regex format (\\+|-)?\d+), the result is empty.
         *
         * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
         *
         * If the input collection is empty, the result is empty.
         *
         * See: https://hl7.org/fhirpath/#tointeger-integer
         *
         * @param input The input collection.
         * @returns The string representation of the input.
         */
        toInteger: (input) => {
            if (input.length === 0) {
                return [];
            }
            const [{ value }] = validateInput(input, 1);
            if (typeof value === 'number') {
                return [{ type: exports.PropertyType.integer, value }];
            }
            if (typeof value === 'string' && value.match(/^[+-]?\d+$/)) {
                return [{ type: exports.PropertyType.integer, value: parseInt(value, 10) }];
            }
            if (typeof value === 'boolean') {
                return [{ type: exports.PropertyType.integer, value: value ? 1 : 0 }];
            }
            return [];
        },
        /**
         * Returns true if the input can be converted to string.
         *
         * If the input collection contains a single item, this function will return true if:
         *   1) the item is an Integer
         *   2) the item is a String and is convertible to an Integer
         *   3) the item is a Boolean
         *   4) If the item is not one of the above types, or the item is a String, but is not convertible to an Integer (using the regex format (\\+|-)?\d+), the result is false.
         *
         * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
         *
         * If the input collection is empty, the result is empty.
         *
         * See: https://hl7.org/fhirpath/#convertstointeger-boolean
         *
         * @param input The input collection.
         * @returns
         */
        convertsToInteger: (input) => {
            if (input.length === 0) {
                return [];
            }
            return booleanToTypedValue(functions.toInteger(input).length === 1);
        },
        /**
         * If the input collection contains a single item, this function will return a single date if:
         *   1) the item is a Date
         *   2) the item is a DateTime
         *   3) the item is a String and is convertible to a Date
         *
         * If the item is not one of the above types, the result is empty.
         *
         * If the item is a String, but the string is not convertible to a Date (using the format YYYY-MM-DD), the result is empty.
         *
         * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
         *
         * If the input collection is empty, the result is empty.
         *
         * See: https://hl7.org/fhirpath/#todate-date
         */
        toDate: (input) => {
            if (input.length === 0) {
                return [];
            }
            const [{ value }] = validateInput(input, 1);
            if (typeof value === 'string' && value.match(/^\d{4}(-\d{2}(-\d{2})?)?/)) {
                return [{ type: exports.PropertyType.date, value: parseDateString(value) }];
            }
            return [];
        },
        /**
         * If the input collection contains a single item, this function will return true if:
         *   1) the item is a Date
         *   2) the item is a DateTime
         *   3) the item is a String and is convertible to a Date
         *
         * If the item is not one of the above types, or is not convertible to a Date (using the format YYYY-MM-DD), the result is false.
         *
         * If the item contains a partial date (e.g. '2012-01'), the result is a partial date.
         *
         * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
         *
         * If the input collection is empty, the result is empty.
         *
         * See: https://hl7.org/fhirpath/#convertstodate-boolean
         */
        convertsToDate: (input) => {
            if (input.length === 0) {
                return [];
            }
            return booleanToTypedValue(functions.toDate(input).length === 1);
        },
        /**
       * If the input collection contains a single item, this function will return a single datetime if:
       *   1) the item is a DateTime
       *   2) the item is a Date, in which case the result is a DateTime with the year, month, and day of the Date, and the time components empty (not set to zero)
       *   3) the item is a String and is convertible to a DateTime
       *
       * If the item is not one of the above types, the result is empty.
       *
       * If the item is a String, but the string is not convertible to a DateTime (using the format YYYY-MM-DDThh:mm:ss.fff(+|-)hh:mm), the result is empty.
       *
       * If the item contains a partial datetime (e.g. '2012-01-01T10:00'), the result is a partial datetime.
       *
       * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
       *
       * If the input collection is empty, the result is empty.
      
       * See: https://hl7.org/fhirpath/#todatetime-datetime
       *
       * @param input
       * @returns
       */
        toDateTime: (input) => {
            if (input.length === 0) {
                return [];
            }
            const [{ value }] = validateInput(input, 1);
            if (typeof value === 'string' && value.match(/^\d{4}(-\d{2}(-\d{2})?)?/)) {
                return [{ type: exports.PropertyType.dateTime, value: parseDateString(value) }];
            }
            return [];
        },
        /**
         * If the input collection contains a single item, this function will return true if:
         *   1) the item is a DateTime
         *   2) the item is a Date
         *   3) the item is a String and is convertible to a DateTime
         *
         * If the item is not one of the above types, or is not convertible to a DateTime (using the format YYYY-MM-DDThh:mm:ss.fff(+|-)hh:mm), the result is false.
         *
         * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
         *
         * If the input collection is empty, the result is empty.
         *
         * See: https://hl7.org/fhirpath/#convertstodatetime-boolean
         *
         * @param input
         * @returns
         */
        convertsToDateTime: (input) => {
            if (input.length === 0) {
                return [];
            }
            return booleanToTypedValue(functions.toDateTime(input).length === 1);
        },
        /**
         * If the input collection contains a single item, this function will return a single decimal if:
         *   1) the item is an Integer or Decimal
         *   2) the item is a String and is convertible to a Decimal
         *   3) the item is a Boolean, where true results in a 1.0 and false results in a 0.0.
         *   4) If the item is not one of the above types, the result is empty.
         *
         * If the item is a String, but the string is not convertible to a Decimal (using the regex format (\\+|-)?\d+(\.\d+)?), the result is empty.
         *
         * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
         *
         * If the input collection is empty, the result is empty.
         *
         * See: https://hl7.org/fhirpath/#decimal-conversion-functions
         *
         * @param input The input collection.
         * @returns
         */
        toDecimal: (input) => {
            if (input.length === 0) {
                return [];
            }
            const [{ value }] = validateInput(input, 1);
            if (typeof value === 'number') {
                return [{ type: exports.PropertyType.decimal, value }];
            }
            if (typeof value === 'string' && value.match(/^-?\d{1,9}(\.\d{1,9})?$/)) {
                return [{ type: exports.PropertyType.decimal, value: parseFloat(value) }];
            }
            if (typeof value === 'boolean') {
                return [{ type: exports.PropertyType.decimal, value: value ? 1 : 0 }];
            }
            return [];
        },
        /**
       * If the input collection contains a single item, this function will true if:
       *   1) the item is an Integer or Decimal
       *   2) the item is a String and is convertible to a Decimal
       *   3) the item is a Boolean
       *
       * If the item is not one of the above types, or is not convertible to a Decimal (using the regex format (\\+|-)?\d+(\.\d+)?), the result is false.
       *
       * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
       *
       * If the input collection is empty, the result is empty.
      
       * See: https://hl7.org/fhirpath/#convertstodecimal-boolean
       *
       * @param input The input collection.
       * @returns
       */
        convertsToDecimal: (input) => {
            if (input.length === 0) {
                return [];
            }
            return booleanToTypedValue(functions.toDecimal(input).length === 1);
        },
        /**
         * If the input collection contains a single item, this function will return a single quantity if:
         *   1) the item is an Integer, or Decimal, where the resulting quantity will have the default unit ('1')
         *   2) the item is a Quantity
         *   3) the item is a String and is convertible to a Quantity
         *   4) the item is a Boolean, where true results in the quantity 1.0 '1', and false results in the quantity 0.0 '1'
         *
         * If the item is not one of the above types, the result is empty.
         *
         * See: https://hl7.org/fhirpath/#quantity-conversion-functions
         *
         * @param input The input collection.
         * @returns
         */
        toQuantity: (input) => {
            if (input.length === 0) {
                return [];
            }
            const [{ value }] = validateInput(input, 1);
            if (isQuantity(value)) {
                return [{ type: exports.PropertyType.Quantity, value }];
            }
            if (typeof value === 'number') {
                return [{ type: exports.PropertyType.Quantity, value: { value, unit: '1' } }];
            }
            if (typeof value === 'string' && value.match(/^-?\d{1,9}(\.\d{1,9})?/)) {
                return [{ type: exports.PropertyType.Quantity, value: { value: parseFloat(value), unit: '1' } }];
            }
            if (typeof value === 'boolean') {
                return [{ type: exports.PropertyType.Quantity, value: { value: value ? 1 : 0, unit: '1' } }];
            }
            return [];
        },
        /**
         * If the input collection contains a single item, this function will return true if:
         *   1) the item is an Integer, Decimal, or Quantity
         *   2) the item is a String that is convertible to a Quantity
         *   3) the item is a Boolean
         *
         * If the item is not one of the above types, or is not convertible to a Quantity using the following regex format:
         *
         *     (?'value'(\+|-)?\d+(\.\d+)?)\s*('(?'unit'[^']+)'|(?'time'[a-zA-Z]+))?
         *
         * then the result is false.
         *
         * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
         *
         * If the input collection is empty, the result is empty.
         *
         * If the unit argument is provided, it must be the string representation of a UCUM code (or a FHIRPath calendar duration keyword), and is used to determine whether the input quantity can be converted to the given unit, according to the unit conversion rules specified by UCUM. If the input quantity can be converted, the result is true, otherwise, the result is false.
         *
         * See: https://hl7.org/fhirpath/#convertstoquantityunit-string-boolean
         *
         * @param input The input collection.
         * @returns
         */
        convertsToQuantity: (input) => {
            if (input.length === 0) {
                return [];
            }
            return booleanToTypedValue(functions.toQuantity(input).length === 1);
        },
        /**
         * Returns the string representation of the input.
         *
         * If the input collection contains a single item, this function will return a single String if:
         *
         *  1) the item in the input collection is a String
         *  2) the item in the input collection is an Integer, Decimal, Date, Time, DateTime, or Quantity the output will contain its String representation
         *  3) the item is a Boolean, where true results in 'true' and false in 'false'.
         *
         * If the item is not one of the above types, the result is false.
         *
         * See: https://hl7.org/fhirpath/#tostring-string
         *
         * @param input The input collection.
         * @returns The string representation of the input.
         */
        toString: (input) => {
            if (input.length === 0) {
                return [];
            }
            const [{ value }] = validateInput(input, 1);
            if (value === null || value === undefined) {
                return [];
            }
            if (isQuantity(value)) {
                return [{ type: exports.PropertyType.string, value: `${value.value} '${value.unit}'` }];
            }
            return [{ type: exports.PropertyType.string, value: value.toString() }];
        },
        /**
         * Returns true if the input can be converted to string.
         *
         * If the input collection contains a single item, this function will return true if:
         *   1) the item is a String
         *   2) the item is an Integer, Decimal, Date, Time, or DateTime
         *   3) the item is a Boolean
         *   4) the item is a Quantity
         *
         * If the item is not one of the above types, the result is false.
         *
         * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
         *
         * If the input collection is empty, the result is empty.
         *
         * See: https://hl7.org/fhirpath/#tostring-string
         *
         * @param input The input collection.
         * @returns
         */
        convertsToString: (input) => {
            if (input.length === 0) {
                return [];
            }
            return booleanToTypedValue(functions.toString(input).length === 1);
        },
        /**
         * If the input collection contains a single item, this function will return a single time if:
         *   1) the item is a Time
         *   2) the item is a String and is convertible to a Time
         *
         * If the item is not one of the above types, the result is empty.
         *
         * If the item is a String, but the string is not convertible to a Time (using the format hh:mm:ss.fff(+|-)hh:mm), the result is empty.
         *
         * If the item contains a partial time (e.g. '10:00'), the result is a partial time.
         *
         * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
         *
         * If the input collection is empty, the result is empty.
         *
         * See: https://hl7.org/fhirpath/#totime-time
         *
         * @param input
         * @returns
         */
        toTime: (input) => {
            if (input.length === 0) {
                return [];
            }
            const [{ value }] = validateInput(input, 1);
            if (typeof value === 'string') {
                const match = value.match(/^T?(\d{2}(:\d{2}(:\d{2})?)?)/);
                if (match) {
                    return [{ type: exports.PropertyType.time, value: parseDateString('T' + match[1]) }];
                }
            }
            return [];
        },
        /**
         * If the input collection contains a single item, this function will return true if:
         *   1) the item is a Time
         *   2) the item is a String and is convertible to a Time
         *
         * If the item is not one of the above types, or is not convertible to a Time (using the format hh:mm:ss.fff(+|-)hh:mm), the result is false.
         *
         * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
         *
         * If the input collection is empty, the result is empty.
         *
         * See: https://hl7.org/fhirpath/#convertstotime-boolean
         *
         * @param input
         * @returns
         */
        convertsToTime: (input) => {
            if (input.length === 0) {
                return [];
            }
            return booleanToTypedValue(functions.toTime(input).length === 1);
        },
        /*
         * 5.6. String Manipulation.
         *
         * See: https://hl7.org/fhirpath/#string-manipulation
         */
        /**
         * Returns the 0-based index of the first position substring is found in the input string, or -1 if it is not found.
         *
         * If substring is an empty string (''), the function returns 0.
         *
         * If the input or substring is empty ({ }), the result is empty ({ }).
         *
         * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
         *
         * See: https://hl7.org/fhirpath/#indexofsubstring-string-integer
         *
         * @param input The input collection.
         * @returns The index of the substring.
         */
        indexOf: (input, substringAtom) => {
            return applyStringFunc((str, substring) => str.indexOf(substring), input, substringAtom);
        },
        /**
         * Returns the part of the string starting at position start (zero-based). If length is given, will return at most length number of characters from the input string.
         *
         * If start lies outside the length of the string, the function returns empty ({ }). If there are less remaining characters in the string than indicated by length, the function returns just the remaining characters.
         *
         * If the input or start is empty, the result is empty.
         *
         * If an empty length is provided, the behavior is the same as if length had not been provided.
         *
         * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
         *
         * @param input The input collection.
         * @returns The index of the substring.
         */
        substring: (input, startAtom, lengthAtom) => {
            return applyStringFunc((str, start, length) => {
                const startIndex = start;
                const endIndex = length ? startIndex + length : str.length;
                return startIndex < 0 || startIndex >= str.length ? undefined : str.substring(startIndex, endIndex);
            }, input, startAtom, lengthAtom);
        },
        /**
         *
         * @param input The input collection.
         * @returns The index of the substring.
         */
        startsWith: (input, prefixAtom) => {
            return applyStringFunc((str, prefix) => str.startsWith(prefix), input, prefixAtom);
        },
        /**
         *
         * @param input The input collection.
         * @returns The index of the substring.
         */
        endsWith: (input, suffixAtom) => {
            return applyStringFunc((str, suffix) => str.endsWith(suffix), input, suffixAtom);
        },
        /**
         *
         * @param input The input collection.
         * @returns The index of the substring.
         */
        contains: (input, substringAtom) => {
            return applyStringFunc((str, substring) => str.includes(substring), input, substringAtom);
        },
        /**
         *
         * @param input The input collection.
         * @returns The index of the substring.
         */
        upper: (input) => {
            return applyStringFunc((str) => str.toUpperCase(), input);
        },
        /**
         *
         * @param input The input collection.
         * @returns The index of the substring.
         */
        lower: (input) => {
            return applyStringFunc((str) => str.toLowerCase(), input);
        },
        /**
         *
         * @param input The input collection.
         * @returns The index of the substring.
         */
        replace: (input, patternAtom, substitionAtom) => {
            return applyStringFunc((str, pattern, substition) => str.replaceAll(pattern, substition), input, patternAtom, substitionAtom);
        },
        /**
         *
         * @param input The input collection.
         * @returns The index of the substring.
         */
        matches: (input, regexAtom) => {
            return applyStringFunc((str, regex) => !!str.match(regex), input, regexAtom);
        },
        /**
         *
         * @param input The input collection.
         * @returns The index of the substring.
         */
        replaceMatches: (input, regexAtom, substitionAtom) => {
            return applyStringFunc((str, pattern, substition) => str.replaceAll(pattern, substition), input, regexAtom, substitionAtom);
        },
        /**
         *
         * @param input The input collection.
         * @returns The index of the substring.
         */
        length: (input) => {
            return applyStringFunc((str) => str.length, input);
        },
        /**
         * Returns the list of characters in the input string. If the input collection is empty ({ }), the result is empty.
         *
         * See: https://hl7.org/fhirpath/#tochars-collection
         *
         * @param input The input collection.
         */
        toChars: (input) => {
            return applyStringFunc((str) => (str ? str.split('') : undefined), input);
        },
        /*
         * 5.7. Math
         */
        /**
         * Returns the absolute value of the input. When taking the absolute value of a quantity, the unit is unchanged.
         *
         * If the input collection is empty, the result is empty.
         *
         * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
         *
         * See: https://hl7.org/fhirpath/#abs-integer-decimal-quantity
         *
         * @param input The input collection.
         * @returns A collection containing the result.
         */
        abs: (input) => {
            return applyMathFunc(Math.abs, input);
        },
        /**
         * Returns the first integer greater than or equal to the input.
         *
         * If the input collection is empty, the result is empty.
         *
         * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
         *
         * See: https://hl7.org/fhirpath/#ceiling-integer
         *
         * @param input The input collection.
         * @returns A collection containing the result.
         */
        ceiling: (input) => {
            return applyMathFunc(Math.ceil, input);
        },
        /**
         * Returns e raised to the power of the input.
         *
         * If the input collection contains an Integer, it will be implicitly converted to a Decimal and the result will be a Decimal.
         *
         * If the input collection is empty, the result is empty.
         *
         * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
         *
         * See: https://hl7.org/fhirpath/#exp-decimal
         *
         * @param input The input collection.
         * @returns A collection containing the result.
         */
        exp: (input) => {
            return applyMathFunc(Math.exp, input);
        },
        /**
         * Returns the first integer less than or equal to the input.
         *
         * If the input collection is empty, the result is empty.
         *
         * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
         *
         * See: https://hl7.org/fhirpath/#floor-integer
         *
         * @param input The input collection.
         * @returns A collection containing the result.
         */
        floor: (input) => {
            return applyMathFunc(Math.floor, input);
        },
        /**
         * Returns the natural logarithm of the input (i.e. the logarithm base e).
         *
         * When used with an Integer, it will be implicitly converted to a Decimal.
         *
         * If the input collection is empty, the result is empty.
         *
         * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
         *
         * See: https://hl7.org/fhirpath/#ln-decimal
         *
         * @param input The input collection.
         * @returns A collection containing the result.
         */
        ln: (input) => {
            return applyMathFunc(Math.log, input);
        },
        /**
         * Returns the logarithm base base of the input number.
         *
         * When used with Integers, the arguments will be implicitly converted to Decimal.
         *
         * If base is empty, the result is empty.
         *
         * If the input collection is empty, the result is empty.
         *
         * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
         *
         * See: https://hl7.org/fhirpath/#logbase-decimal-decimal
         *
         * @param input The input collection.
         * @returns A collection containing the result.
         */
        log: (input, baseAtom) => {
            return applyMathFunc((value, base) => Math.log(value) / Math.log(base), input, baseAtom);
        },
        /**
         * Raises a number to the exponent power. If this function is used with Integers, the result is an Integer. If the function is used with Decimals, the result is a Decimal. If the function is used with a mixture of Integer and Decimal, the Integer is implicitly converted to a Decimal and the result is a Decimal.
         *
         * If the power cannot be represented (such as the -1 raised to the 0.5), the result is empty.
         *
         * If the input is empty, or exponent is empty, the result is empty.
         *
         * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
         *
         * See: https://hl7.org/fhirpath/#powerexponent-integer-decimal-integer-decimal
         *
         * @param input The input collection.
         * @returns A collection containing the result.
         */
        power: (input, expAtom) => {
            return applyMathFunc(Math.pow, input, expAtom);
        },
        /**
         * Rounds the decimal to the nearest whole number using a traditional round (i.e. 0.5 or higher will round to 1). If specified, the precision argument determines the decimal place at which the rounding will occur. If not specified, the rounding will default to 0 decimal places.
         *
         * If specified, the number of digits of precision must be >= 0 or the evaluation will end and signal an error to the calling environment.
         *
         * If the input collection contains a single item of type Integer, it will be implicitly converted to a Decimal.
         *
         * If the input collection is empty, the result is empty.
         *
         * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
         *
         * See: https://hl7.org/fhirpath/#roundprecision-integer-decimal
         *
         * @param input The input collection.
         * @returns A collection containing the result.
         */
        round: (input) => {
            return applyMathFunc(Math.round, input);
        },
        /**
         * Returns the square root of the input number as a Decimal.
         *
         * If the square root cannot be represented (such as the square root of -1), the result is empty.
         *
         * If the input collection is empty, the result is empty.
         *
         * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
         *
         * Note that this function is equivalent to raising a number of the power of 0.5 using the power() function.
         *
         * See: https://hl7.org/fhirpath/#sqrt-decimal
         *
         * @param input The input collection.
         * @returns A collection containing the result.
         */
        sqrt: (input) => {
            return applyMathFunc(Math.sqrt, input);
        },
        /**
         * Returns the integer portion of the input.
         *
         * If the input collection is empty, the result is empty.
         *
         * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.
         *
         * See: https://hl7.org/fhirpath/#truncate-integer
         *
         * @param input The input collection.
         * @returns A collection containing the result.
         */
        truncate: (input) => {
            return applyMathFunc((x) => x | 0, input);
        },
        /*
         * 5.8. Tree navigation
         */
        children: stub,
        descendants: stub,
        /*
         * 5.9. Utility functions
         */
        /**
         * Adds a String representation of the input collection to the diagnostic log,
         * using the name argument as the name in the log. This log should be made available
         * to the user in some appropriate fashion. Does not change the input, so returns
         * the input collection as output.
         *
         * If the projection argument is used, the trace would log the result of evaluating
         * the project expression on the input, but still return the input to the trace
         * function unchanged.
         *
         * See: https://hl7.org/fhirpath/#tracename-string-projection-expression-collection
         *
         * @param input The input collection.
         * @param nameAtom The log name.
         */
        trace: (input, nameAtom) => {
            console.log('trace', input, nameAtom);
            return input;
        },
        /**
         * Returns the current date and time, including timezone offset.
         *
         * See: https://hl7.org/fhirpath/#now-datetime
         */
        now: () => {
            return [{ type: exports.PropertyType.dateTime, value: new Date().toISOString() }];
        },
        /**
         * Returns the current time.
         *
         * See: https://hl7.org/fhirpath/#timeofday-time
         */
        timeOfDay: () => {
            return [{ type: exports.PropertyType.time, value: new Date().toISOString().substring(11) }];
        },
        /**
         * Returns the current date.
         *
         * See: https://hl7.org/fhirpath/#today-date
         */
        today: () => {
            return [{ type: exports.PropertyType.date, value: new Date().toISOString().substring(0, 10) }];
        },
        /**
         * Calculates the difference between two dates or date/times.
         *
         * This is not part of the official FHIRPath spec.
         *
         * IBM FHIR issue: https://github.com/IBM/FHIR/issues/1014
         * IBM FHIR PR: https://github.com/IBM/FHIR/pull/1023
         */
        between: (input, startAtom, endAtom, unitsAtom) => {
            const startDate = functions.toDateTime(startAtom.eval(input));
            if (startDate.length === 0) {
                throw new Error('Invalid start date');
            }
            const endDate = functions.toDateTime(endAtom.eval(input));
            if (endDate.length === 0) {
                throw new Error('Invalid end date');
            }
            const unit = unitsAtom.eval(input)[0]?.value;
            if (unit !== 'years' && unit !== 'months' && unit !== 'days') {
                throw new Error('Invalid units');
            }
            const age = calculateAge(startDate[0].value, endDate[0].value);
            return [{ type: exports.PropertyType.Quantity, value: { value: age[unit], unit } }];
        },
        /*
         * 6.3 Types
         */
        /**
         * The is() function is supported for backwards compatibility with previous
         * implementations of FHIRPath. Just as with the is keyword, the type argument
         * is an identifier that must resolve to the name of a type in a model.
         *
         * For implementations with compile-time typing, this requires special-case
         * handling when processing the argument to treat it as a type specifier rather
         * than an identifier expression:
         *
         * @param input
         * @param typeAtom
         * @returns
         */
        is: (input, typeAtom) => {
            let typeName = '';
            if (typeAtom instanceof SymbolAtom) {
                typeName = typeAtom.name;
            }
            else if (typeAtom instanceof DotAtom) {
                typeName = typeAtom.left.name + '.' + typeAtom.right.name;
            }
            if (!typeName) {
                return [];
            }
            return input.map((value) => ({ type: exports.PropertyType.boolean, value: fhirPathIs(value, typeName) }));
        },
        /*
         * 6.5 Boolean logic
         */
        /**
         * 6.5.3. not() : Boolean
         *
         * Returns true if the input collection evaluates to false, and false if it evaluates to true. Otherwise, the result is empty ({ }):
         *
         * @param input
         * @returns
         */
        not: (input) => {
            return functions.toBoolean(input).map((value) => ({ type: exports.PropertyType.boolean, value: !value.value }));
        },
        /*
         * Additional functions
         * See: https://hl7.org/fhir/fhirpath.html#functions
         */
        /**
         * For each item in the collection, if it is a string that is a uri (or canonical or url), locate the target of the reference, and add it to the resulting collection. If the item does not resolve to a resource, the item is ignored and nothing is added to the output collection.
         * The items in the collection may also represent a Reference, in which case the Reference.reference is resolved.
         * @param input The input collection.
         * @returns
         */
        resolve: (input) => {
            return input
                .map((e) => {
                const value = e.value;
                let refStr;
                if (typeof value === 'string') {
                    refStr = value;
                }
                else if (typeof value === 'object') {
                    const ref = value;
                    if (ref.resource) {
                        return toTypedValue(ref.resource);
                    }
                    refStr = ref.reference;
                }
                if (!refStr) {
                    return { type: exports.PropertyType.BackboneElement, value: null };
                }
                const [resourceType, id] = refStr.split('/');
                return { type: exports.PropertyType.BackboneElement, value: { resourceType, id } };
            })
                .filter((e) => !!e.value);
        },
        /**
         * The as operator can be used to treat a value as a specific type.
         * @param input The input value.
         * @returns The value as the specific type.
         */
        as: (input) => {
            return input;
        },
        /*
         * 12. Formal Specifications
         */
        /**
         * Returns the type of the input.
         *
         * 12.2. Model Information
         *
         * The model information returned by the reflection function type() is specified as an
         * XML Schema document (xsd) and included in this specification at the following link:
         * https://hl7.org/fhirpath/modelinfo.xsd
         *
         * See: https://hl7.org/fhirpath/#model-information
         *
         * @param input The input collection.
         * @returns
         */
        type: (input) => {
            return input.map(({ value }) => {
                if (typeof value === 'boolean') {
                    return { type: exports.PropertyType.BackboneElement, value: { namespace: 'System', name: 'Boolean' } };
                }
                if (typeof value === 'number') {
                    return { type: exports.PropertyType.BackboneElement, value: { namespace: 'System', name: 'Integer' } };
                }
                if (value && typeof value === 'object' && 'resourceType' in value) {
                    return {
                        type: exports.PropertyType.BackboneElement,
                        value: { namespace: 'FHIR', name: value.resourceType },
                    };
                }
                return { type: exports.PropertyType.BackboneElement, value: null };
            });
        },
        conformsTo: (input, systemAtom) => {
            const system = systemAtom.eval(input)[0].value;
            if (!system.startsWith('http://hl7.org/fhir/StructureDefinition/')) {
                throw new Error('Expected a StructureDefinition URL');
            }
            const expectedResourceType = system.replace('http://hl7.org/fhir/StructureDefinition/', '');
            return input.map((value) => ({
                type: exports.PropertyType.boolean,
                value: value.value?.resourceType === expectedResourceType,
            }));
        },
    };
    /*
     * Helper utilities
     */
    function applyStringFunc(func, input, ...argsAtoms) {
        if (input.length === 0) {
            return [];
        }
        const [{ value }] = validateInput(input, 1);
        if (typeof value !== 'string') {
            throw new Error('String function cannot be called with non-string');
        }
        const result = func(value, ...argsAtoms.map((atom) => atom && atom.eval(input)?.[0]?.value));
        if (result === undefined) {
            return [];
        }
        if (Array.isArray(result)) {
            return result.map(toTypedValue);
        }
        return [toTypedValue(result)];
    }
    function applyMathFunc(func, input, ...argsAtoms) {
        if (input.length === 0) {
            return [];
        }
        const [{ value }] = validateInput(input, 1);
        const quantity = isQuantity(value);
        const numberInput = quantity ? value.value : value;
        if (typeof numberInput !== 'number') {
            throw new Error('Math function cannot be called with non-number');
        }
        const result = func(numberInput, ...argsAtoms.map((atom) => atom.eval(input)?.[0]?.value));
        const type = quantity ? exports.PropertyType.Quantity : input[0].type;
        const returnValue = quantity ? { ...value, value: result } : result;
        return [{ type, value: returnValue }];
    }
    function validateInput(input, count) {
        if (input.length !== count) {
            throw new Error(`Expected ${count} arguments`);
        }
        for (const element of input) {
            if (element === null || element === undefined) {
                throw new Error('Expected non-null argument');
            }
        }
        return input;
    }

    var _SymbolAtom_instances, _SymbolAtom_evalValue;
    class FhirPathAtom {
        constructor(original, child) {
            this.original = original;
            this.child = child;
        }
        eval(context) {
            try {
                if (context.length > 0) {
                    return context.map((e) => this.child.eval([e])).flat();
                }
                else {
                    return this.child.eval([]);
                }
            }
            catch (error) {
                throw new Error(`FhirPathError on "${this.original}": ${error}`);
            }
        }
        toString() {
            return this.child.toString();
        }
    }
    class LiteralAtom {
        constructor(value) {
            this.value = value;
        }
        eval() {
            return [this.value];
        }
        toString() {
            const value = this.value.value;
            if (typeof value === 'string') {
                return `'${value}'`;
            }
            return value.toString();
        }
    }
    class SymbolAtom {
        constructor(name) {
            this.name = name;
            _SymbolAtom_instances.add(this);
        }
        eval(context) {
            if (this.name === '$this') {
                return context;
            }
            return context
                .map((e) => __classPrivateFieldGet(this, _SymbolAtom_instances, "m", _SymbolAtom_evalValue).call(this, e))
                .flat()
                .filter((e) => e?.value !== undefined);
        }
        toString() {
            return this.name;
        }
    }
    _SymbolAtom_instances = new WeakSet(), _SymbolAtom_evalValue = function _SymbolAtom_evalValue(typedValue) {
        const input = typedValue.value;
        if (!input || typeof input !== 'object') {
            return undefined;
        }
        if ('resourceType' in input && input.resourceType === this.name) {
            return typedValue;
        }
        return getTypedPropertyValue(typedValue, this.name);
    };
    class EmptySetAtom {
        eval() {
            return [];
        }
        toString() {
            return '{}';
        }
    }
    class UnaryOperatorAtom extends PrefixOperatorAtom {
        constructor(operator, child, impl) {
            super(operator, child);
            this.impl = impl;
        }
        eval(context) {
            return this.impl(this.child.eval(context));
        }
        toString() {
            return this.child.toString();
        }
    }
    class AsAtom extends InfixOperatorAtom {
        constructor(left, right) {
            super('as', left, right);
        }
        eval(context) {
            return functions.ofType(this.left.eval(context), this.right);
        }
    }
    class ArithemticOperatorAtom extends InfixOperatorAtom {
        constructor(operator, left, right, impl) {
            super(operator, left, right);
            this.impl = impl;
        }
        eval(context) {
            const leftEvalResult = this.left.eval(context);
            if (leftEvalResult.length !== 1) {
                return [];
            }
            const rightEvalResult = this.right.eval(context);
            if (rightEvalResult.length !== 1) {
                return [];
            }
            const leftValue = leftEvalResult[0].value;
            const rightValue = rightEvalResult[0].value;
            const leftNumber = isQuantity(leftValue) ? leftValue.value : leftValue;
            const rightNumber = isQuantity(rightValue) ? rightValue.value : rightValue;
            const result = this.impl(leftNumber, rightNumber);
            if (typeof result === 'boolean') {
                return booleanToTypedValue(result);
            }
            else if (isQuantity(leftValue)) {
                return [{ type: exports.PropertyType.Quantity, value: { ...leftValue, value: result } }];
            }
            else {
                return [toTypedValue(result)];
            }
        }
    }
    class ConcatAtom extends InfixOperatorAtom {
        constructor(left, right) {
            super('&', left, right);
        }
        eval(context) {
            const leftValue = this.left.eval(context);
            const rightValue = this.right.eval(context);
            const result = [...leftValue, ...rightValue];
            if (result.length > 0 && result.every((e) => typeof e.value === 'string')) {
                return [{ type: exports.PropertyType.string, value: result.map((e) => e.value).join('') }];
            }
            return result;
        }
    }
    class ContainsAtom extends InfixOperatorAtom {
        constructor(left, right) {
            super('contains', left, right);
        }
        eval(context) {
            const leftValue = this.left.eval(context);
            const rightValue = this.right.eval(context);
            return booleanToTypedValue(leftValue.some((e) => e.value === rightValue[0].value));
        }
    }
    class InAtom extends InfixOperatorAtom {
        constructor(left, right) {
            super('in', left, right);
        }
        eval(context) {
            const leftValue = this.left.eval(context);
            const rightValue = this.right.eval(context);
            return booleanToTypedValue(rightValue.some((e) => e.value === leftValue[0].value));
        }
    }
    class DotAtom extends InfixOperatorAtom {
        constructor(left, right) {
            super('.', left, right);
        }
        eval(context) {
            return this.right.eval(this.left.eval(context));
        }
        toString() {
            return `${this.left.toString()}.${this.right.toString()}`;
        }
    }
    class UnionAtom extends InfixOperatorAtom {
        constructor(left, right) {
            super('|', left, right);
        }
        eval(context) {
            const leftResult = this.left.eval(context);
            const rightResult = this.right.eval(context);
            return removeDuplicates([...leftResult, ...rightResult]);
        }
    }
    class EqualsAtom extends InfixOperatorAtom {
        constructor(left, right) {
            super('=', left, right);
        }
        eval(context) {
            const leftValue = this.left.eval(context);
            const rightValue = this.right.eval(context);
            return fhirPathArrayEquals(leftValue, rightValue);
        }
    }
    class NotEqualsAtom extends InfixOperatorAtom {
        constructor(left, right) {
            super('!=', left, right);
        }
        eval(context) {
            const leftValue = this.left.eval(context);
            const rightValue = this.right.eval(context);
            return fhirPathNot(fhirPathArrayEquals(leftValue, rightValue));
        }
    }
    class EquivalentAtom extends InfixOperatorAtom {
        constructor(left, right) {
            super('~', left, right);
        }
        eval(context) {
            const leftValue = this.left.eval(context);
            const rightValue = this.right.eval(context);
            return fhirPathArrayEquivalent(leftValue, rightValue);
        }
    }
    class NotEquivalentAtom extends InfixOperatorAtom {
        constructor(left, right) {
            super('!~', left, right);
        }
        eval(context) {
            const leftValue = this.left.eval(context);
            const rightValue = this.right.eval(context);
            return fhirPathNot(fhirPathArrayEquivalent(leftValue, rightValue));
        }
    }
    class IsAtom extends InfixOperatorAtom {
        constructor(left, right) {
            super('is', left, right);
        }
        eval(context) {
            const leftValue = this.left.eval(context);
            if (leftValue.length !== 1) {
                return [];
            }
            const typeName = this.right.name;
            return booleanToTypedValue(fhirPathIs(leftValue[0], typeName));
        }
    }
    /**
     * 6.5.1. and
     * Returns true if both operands evaluate to true,
     * false if either operand evaluates to false,
     * and the empty collection otherwise.
     */
    class AndAtom extends InfixOperatorAtom {
        constructor(left, right) {
            super('and', left, right);
        }
        eval(context) {
            const leftValue = this.left.eval(context);
            const rightValue = this.right.eval(context);
            if (leftValue[0]?.value === true && rightValue[0]?.value === true) {
                return booleanToTypedValue(true);
            }
            if (leftValue[0]?.value === false || rightValue[0]?.value === false) {
                return booleanToTypedValue(false);
            }
            return [];
        }
    }
    class OrAtom extends InfixOperatorAtom {
        constructor(left, right) {
            super('or', left, right);
        }
        eval(context) {
            const leftValue = this.left.eval(context);
            if (toJsBoolean(leftValue)) {
                return leftValue;
            }
            const rightValue = this.right.eval(context);
            if (toJsBoolean(rightValue)) {
                return rightValue;
            }
            return [];
        }
    }
    /**
     * 6.5.4. xor
     * Returns true if exactly one of the operands evaluates to true,
     * false if either both operands evaluate to true or both operands evaluate to false,
     * and the empty collection otherwise.
     */
    class XorAtom extends InfixOperatorAtom {
        constructor(left, right) {
            super('xor', left, right);
        }
        eval(context) {
            const leftResult = this.left.eval(context);
            const rightResult = this.right.eval(context);
            if (leftResult.length === 0 && rightResult.length === 0) {
                return [];
            }
            const leftValue = leftResult.length === 0 ? null : leftResult[0].value;
            const rightValue = rightResult.length === 0 ? null : rightResult[0].value;
            if ((leftValue === true && rightValue !== true) || (leftValue !== true && rightValue === true)) {
                return booleanToTypedValue(true);
            }
            if ((leftValue === true && rightValue === true) || (leftValue === false && rightValue === false)) {
                return booleanToTypedValue(false);
            }
            return [];
        }
    }
    class FunctionAtom {
        constructor(name, args) {
            this.name = name;
            this.args = args;
        }
        eval(context) {
            const impl = functions[this.name];
            if (!impl) {
                throw new Error('Unrecognized function: ' + this.name);
            }
            return impl(context, ...this.args);
        }
        toString() {
            return `${this.name}(${this.args.map((arg) => arg.toString()).join(', ')})`;
        }
    }
    class IndexerAtom {
        constructor(left, expr) {
            this.left = left;
            this.expr = expr;
        }
        eval(context) {
            const evalResult = this.expr.eval(context);
            if (evalResult.length !== 1) {
                return [];
            }
            const index = evalResult[0].value;
            if (typeof index !== 'number') {
                throw new Error(`Invalid indexer expression: should return integer}`);
            }
            const leftResult = this.left.eval(context);
            if (!(index in leftResult)) {
                return [];
            }
            return [leftResult[index]];
        }
        toString() {
            return `${this.left.toString()}[${this.expr.toString()}]`;
        }
    }

    const FHIRPATH_KEYWORDS = ['true', 'false'];
    const FHIRPATH_OPERATORS = ['!=', '!~', '<=', '>=', '{}', '->'];
    function tokenize(str) {
        return new Tokenizer(str, FHIRPATH_KEYWORDS, FHIRPATH_OPERATORS).tokenize();
    }

    const PARENTHESES_PARSELET = {
        parse(parser) {
            const expr = parser.consumeAndParse();
            if (!parser.match(')')) {
                throw new Error('Parse error: expected `)` got `' + parser.peek()?.value + '`');
            }
            return expr;
        },
    };
    const INDEXER_PARSELET = {
        parse(parser, left) {
            const expr = parser.consumeAndParse();
            if (!parser.match(']')) {
                throw new Error('Parse error: expected `]`');
            }
            return new IndexerAtom(left, expr);
        },
        precedence: 2 /* OperatorPrecedence.Indexer */,
    };
    const FUNCTION_CALL_PARSELET = {
        parse(parser, left) {
            if (!(left instanceof SymbolAtom)) {
                throw new Error('Unexpected parentheses');
            }
            const args = [];
            while (!parser.match(')')) {
                args.push(parser.consumeAndParse());
                parser.match(',');
            }
            return new FunctionAtom(left.name, args); //, functions[left.name]);
        },
        precedence: 0 /* OperatorPrecedence.FunctionCall */,
    };
    function parseQuantity(str) {
        const parts = str.split(' ');
        const value = parseFloat(parts[0]);
        let unit = parts[1];
        if (unit && unit.startsWith("'") && unit.endsWith("'")) {
            unit = unit.substring(1, unit.length - 1);
        }
        else {
            unit = '{' + unit + '}';
        }
        return { value, unit };
    }
    function initFhirPathParserBuilder() {
        return new ParserBuilder()
            .registerPrefix('String', {
            parse: (_, token) => new LiteralAtom({ type: exports.PropertyType.string, value: token.value }),
        })
            .registerPrefix('DateTime', {
            parse: (_, token) => new LiteralAtom({ type: exports.PropertyType.dateTime, value: parseDateString(token.value) }),
        })
            .registerPrefix('Quantity', {
            parse: (_, token) => new LiteralAtom({ type: exports.PropertyType.Quantity, value: parseQuantity(token.value) }),
        })
            .registerPrefix('Number', {
            parse: (_, token) => new LiteralAtom({ type: exports.PropertyType.decimal, value: parseFloat(token.value) }),
        })
            .registerPrefix('true', { parse: () => new LiteralAtom({ type: exports.PropertyType.boolean, value: true }) })
            .registerPrefix('false', { parse: () => new LiteralAtom({ type: exports.PropertyType.boolean, value: false }) })
            .registerPrefix('Symbol', { parse: (_, token) => new SymbolAtom(token.value) })
            .registerPrefix('{}', { parse: () => new EmptySetAtom() })
            .registerPrefix('(', PARENTHESES_PARSELET)
            .registerInfix('[', INDEXER_PARSELET)
            .registerInfix('(', FUNCTION_CALL_PARSELET)
            .prefix('+', 3 /* OperatorPrecedence.UnaryAdd */, (_, right) => new UnaryOperatorAtom('+', right, (x) => x))
            .prefix('-', 3 /* OperatorPrecedence.UnarySubtract */, (_, right) => new ArithemticOperatorAtom('-', right, right, (_, y) => -y))
            .infixLeft('.', 1 /* OperatorPrecedence.Dot */, (left, _, right) => new DotAtom(left, right))
            .infixLeft('/', 4 /* OperatorPrecedence.Divide */, (left, _, right) => new ArithemticOperatorAtom('/', left, right, (x, y) => x / y))
            .infixLeft('*', 4 /* OperatorPrecedence.Multiply */, (left, _, right) => new ArithemticOperatorAtom('*', left, right, (x, y) => x * y))
            .infixLeft('+', 5 /* OperatorPrecedence.Add */, (left, _, right) => new ArithemticOperatorAtom('+', left, right, (x, y) => x + y))
            .infixLeft('-', 5 /* OperatorPrecedence.Subtract */, (left, _, right) => new ArithemticOperatorAtom('-', left, right, (x, y) => x - y))
            .infixLeft('|', 7 /* OperatorPrecedence.Union */, (left, _, right) => new UnionAtom(left, right))
            .infixLeft('=', 9 /* OperatorPrecedence.Equals */, (left, _, right) => new EqualsAtom(left, right))
            .infixLeft('!=', 9 /* OperatorPrecedence.Equals */, (left, _, right) => new NotEqualsAtom(left, right))
            .infixLeft('~', 9 /* OperatorPrecedence.Equivalent */, (left, _, right) => new EquivalentAtom(left, right))
            .infixLeft('!~', 9 /* OperatorPrecedence.NotEquivalent */, (left, _, right) => new NotEquivalentAtom(left, right))
            .infixLeft('<', 8 /* OperatorPrecedence.LessThan */, (left, _, right) => new ArithemticOperatorAtom('<', left, right, (x, y) => x < y))
            .infixLeft('<=', 8 /* OperatorPrecedence.LessThanOrEquals */, (left, _, right) => new ArithemticOperatorAtom('<=', left, right, (x, y) => x <= y))
            .infixLeft('>', 8 /* OperatorPrecedence.GreaterThan */, (left, _, right) => new ArithemticOperatorAtom('>', left, right, (x, y) => x > y))
            .infixLeft('>=', 8 /* OperatorPrecedence.GreaterThanOrEquals */, (left, _, right) => new ArithemticOperatorAtom('>=', left, right, (x, y) => x >= y))
            .infixLeft('&', 5 /* OperatorPrecedence.Ampersand */, (left, _, right) => new ConcatAtom(left, right))
            .infixLeft('and', 6 /* OperatorPrecedence.Is */, (left, _, right) => new AndAtom(left, right))
            .infixLeft('as', 6 /* OperatorPrecedence.Is */, (left, _, right) => new AsAtom(left, right))
            .infixLeft('contains', 6 /* OperatorPrecedence.Is */, (left, _, right) => new ContainsAtom(left, right))
            .infixLeft('div', 6 /* OperatorPrecedence.Is */, (left, _, right) => new ArithemticOperatorAtom('div', left, right, (x, y) => (x / y) | 0))
            .infixLeft('in', 6 /* OperatorPrecedence.Is */, (left, _, right) => new InAtom(left, right))
            .infixLeft('is', 6 /* OperatorPrecedence.Is */, (left, _, right) => new IsAtom(left, right))
            .infixLeft('mod', 6 /* OperatorPrecedence.Is */, (left, _, right) => new ArithemticOperatorAtom('mod', left, right, (x, y) => x % y))
            .infixLeft('or', 6 /* OperatorPrecedence.Is */, (left, _, right) => new OrAtom(left, right))
            .infixLeft('xor', 6 /* OperatorPrecedence.Is */, (left, _, right) => new XorAtom(left, right));
    }
    const fhirPathParserBuilder = initFhirPathParserBuilder();
    /**
     * Parses a FHIRPath expression into an AST.
     * The result can be used to evaluate the expression against a resource or other object.
     * This method is useful if you know that you will evaluate the same expression many times
     * against different resources.
     * @param input The FHIRPath expression to parse.
     * @returns The AST representing the expression.
     */
    function parseFhirPath(input) {
        return new FhirPathAtom(input, fhirPathParserBuilder.construct(tokenize(input)).consumeAndParse());
    }
    /**
     * Evaluates a FHIRPath expression against a resource or other object.
     * @param expression The FHIRPath expression to parse.
     * @param input The resource or object to evaluate the expression against.
     * @returns The result of the FHIRPath expression against the resource or object.
     */
    function evalFhirPath(expression, input) {
        // eval requires a TypedValue array
        // As a convenience, we can accept array or non-array, and TypedValue or unknown value
        const array = Array.isArray(input) ? input : [input];
        for (let i = 0; i < array.length; i++) {
            const el = array[i];
            if (!(typeof el === 'object' && 'type' in el && 'value' in el)) {
                array[i] = toTypedValue(array[i]);
            }
        }
        return evalFhirPathTyped(expression, array).map((e) => e.value);
    }
    /**
     * Evaluates a FHIRPath expression against a resource or other object.
     * @param expression The FHIRPath expression to parse.
     * @param input The resource or object to evaluate the expression against.
     * @returns The result of the FHIRPath expression against the resource or object.
     */
    function evalFhirPathTyped(expression, input) {
        return parseFhirPath(expression).eval(input);
    }

    /**
     * The Hl7Context class represents the parsing context for an HL7 message.
     *
     * MSH-1:
     * https://hl7-definition.caristix.com/v2/HL7v2.6/Fields/MSH.1
     *
     * MSH-2:
     * https://hl7-definition.caristix.com/v2/HL7v2.6/Fields/MSH.2
     *
     * See this tutorial on MSH, and why it's a bad idea to use anything other than the default values:
     * https://www.hl7soup.com/HL7TutorialMSH.html
     */
    class Hl7Context {
        constructor(segmentSeparator = '\r', fieldSeparator = '|', componentSeparator = '^', repetitionSeparator = '~', escapeCharacter = '\\', subcomponentSeparator = '&') {
            this.segmentSeparator = segmentSeparator;
            this.fieldSeparator = fieldSeparator;
            this.componentSeparator = componentSeparator;
            this.repetitionSeparator = repetitionSeparator;
            this.escapeCharacter = escapeCharacter;
            this.subcomponentSeparator = subcomponentSeparator;
        }
        /**
         * Returns the MSH-2 field value based on the configured separators.
         * @returns The HL7 MSH-2 field value.
         */
        getMsh2() {
            return (this.fieldSeparator +
                this.componentSeparator +
                this.repetitionSeparator +
                this.escapeCharacter +
                this.subcomponentSeparator);
        }
    }
    /**
     * The Hl7Message class represents one HL7 message.
     * A message is a collection of segments.
     */
    class Hl7Message {
        /**
         * Creates a new HL7 message.
         * @param segments The HL7 segments.
         * @param context Optional HL7 parsing context.
         */
        constructor(segments, context = new Hl7Context()) {
            this.context = context;
            this.segments = segments;
        }
        /**
         * Returns an HL7 segment by index or by name.
         * @param index The HL7 segment index or name.
         * @returns The HL7 segment if found; otherwise, undefined.
         */
        get(index) {
            if (typeof index === 'number') {
                return this.segments[index];
            }
            return this.segments.find((s) => s.name === index);
        }
        /**
         * Returns all HL7 segments of a given name.
         * @param name The HL7 segment name.
         * @returns An array of HL7 segments with the specified name.
         */
        getAll(name) {
            return this.segments.filter((s) => s.name === name);
        }
        /**
         * Returns the HL7 message as a string.
         * @returns The HL7 message as a string.
         */
        toString() {
            return this.segments.map((s) => s.toString()).join(this.context.segmentSeparator);
        }
        /**
         * Returns an HL7 "ACK" (acknowledgement) message for this message.
         * @returns The HL7 "ACK" message.
         */
        buildAck() {
            const now = new Date();
            const msh = this.get('MSH');
            const sendingApp = msh?.get(2)?.toString() || '';
            const sendingFacility = msh?.get(3)?.toString() || '';
            const receivingApp = msh?.get(4)?.toString() || '';
            const receivingFacility = msh?.get(5)?.toString() || '';
            const controlId = msh?.get(9)?.toString() || '';
            const versionId = msh?.get(12)?.toString() || '2.5.1';
            return new Hl7Message([
                new Hl7Segment([
                    'MSH',
                    this.context.getMsh2(),
                    receivingApp,
                    receivingFacility,
                    sendingApp,
                    sendingFacility,
                    now.toISOString(),
                    '',
                    'ACK',
                    now.getTime().toString(),
                    'P',
                    versionId,
                ], this.context),
                new Hl7Segment(['MSA', 'AA', controlId, 'OK'], this.context),
            ]);
        }
        /**
         * Parses an HL7 message string into an Hl7Message object.
         * @param text The HL7 message text.
         * @returns The parsed HL7 message.
         */
        static parse(text) {
            if (!text.startsWith('MSH')) {
                const err = new Error('Invalid HL7 message');
                err.type = 'entity.parse.failed';
                throw err;
            }
            const context = new Hl7Context('\r', text.charAt(3), // Field separator, recommended "|"
            text.charAt(4), // Component separator, recommended "^"
            text.charAt(5), // Repetition separator, recommended "~"
            text.charAt(6), // Escape character, recommended "\"
            text.charAt(7) // Subcomponent separator, recommended "&"
            );
            return new Hl7Message(text.split(/[\r\n]+/).map((line) => Hl7Segment.parse(line, context)), context);
        }
    }
    /**
     * The Hl7Segment class represents one HL7 segment.
     * A segment is a collection of fields.
     * The name field is the first field.
     */
    class Hl7Segment {
        /**
         * Creates a new HL7 segment.
         * @param fields The HL7 fields.
         * @param context Optional HL7 parsing context.
         */
        constructor(fields, context = new Hl7Context()) {
            this.context = context;
            if (isStringArray(fields)) {
                this.fields = fields.map((f) => Hl7Field.parse(f));
            }
            else {
                this.fields = fields;
            }
            this.name = this.fields[0].components[0][0];
        }
        /**
         * Returns an HL7 field by index.
         * @param index The HL7 field index.
         * @returns The HL7 field.
         */
        get(index) {
            return this.fields[index];
        }
        /**
         * Returns the HL7 segment as a string.
         * @returns The HL7 segment as a string.
         */
        toString() {
            return this.fields.map((f) => f.toString()).join(this.context.fieldSeparator);
        }
        /**
         * Parses an HL7 segment string into an Hl7Segment object.
         * @param text The HL7 segment text.
         * @param context Optional HL7 parsing context.
         * @returns The parsed HL7 segment.
         */
        static parse(text, context = new Hl7Context()) {
            return new Hl7Segment(text.split(context.fieldSeparator).map((f) => Hl7Field.parse(f, context)), context);
        }
    }
    /**
     * The Hl7Field class represents one HL7 field.
     * A field is a collection of components.
     */
    class Hl7Field {
        /**
         * Creates a new HL7 field.
         * @param components The HL7 components.
         * @param context Optional HL7 parsing context.
         */
        constructor(components, context = new Hl7Context()) {
            this.context = context;
            this.components = components;
        }
        /**
         * Returns an HL7 component by index.
         * @param component The component index.
         * @param subcomponent Optional subcomponent index.
         * @param repetition Optional repetition index.
         * @returns The string value of the specified component.
         */
        get(component, subcomponent, repetition = 0) {
            let value = this.components[repetition][component] || '';
            if (subcomponent !== undefined) {
                value = value.split(this.context.subcomponentSeparator)[subcomponent] || '';
            }
            return value;
        }
        /**
         * Returns the HL7 field as a string.
         * @returns The HL7 field as a string.
         */
        toString() {
            return this.components.map((r) => r.join(this.context.componentSeparator)).join(this.context.repetitionSeparator);
        }
        /**
         * Parses an HL7 field string into an Hl7Field object.
         * @param text The HL7 field text.
         * @param context Optional HL7 parsing context.
         * @returns The parsed HL7 field.
         */
        static parse(text, context = new Hl7Context()) {
            return new Hl7Field(text.split(context.repetitionSeparator).map((r) => r.split(context.componentSeparator)), context);
        }
    }

    const DEFAULT_SEARCH_COUNT = 20;
    /**
     * Search operators.
     * These operators represent "modifiers" and "prefixes" in FHIR search.
     * See: https://www.hl7.org/fhir/search.html
     */
    exports.Operator = void 0;
    (function (Operator) {
        Operator["EQUALS"] = "eq";
        Operator["NOT_EQUALS"] = "ne";
        // Numbers
        Operator["GREATER_THAN"] = "gt";
        Operator["LESS_THAN"] = "lt";
        Operator["GREATER_THAN_OR_EQUALS"] = "ge";
        Operator["LESS_THAN_OR_EQUALS"] = "le";
        // Dates
        Operator["STARTS_AFTER"] = "sa";
        Operator["ENDS_BEFORE"] = "eb";
        Operator["APPROXIMATELY"] = "ap";
        // String
        Operator["CONTAINS"] = "contains";
        Operator["EXACT"] = "exact";
        // Token
        Operator["TEXT"] = "text";
        Operator["NOT"] = "not";
        Operator["ABOVE"] = "above";
        Operator["BELOW"] = "below";
        Operator["IN"] = "in";
        Operator["NOT_IN"] = "not-in";
        Operator["OF_TYPE"] = "of-type";
        // All
        Operator["MISSING"] = "missing";
    })(exports.Operator || (exports.Operator = {}));
    const MODIFIER_OPERATORS = [
        exports.Operator.CONTAINS,
        exports.Operator.EXACT,
        exports.Operator.TEXT,
        exports.Operator.NOT,
        exports.Operator.ABOVE,
        exports.Operator.BELOW,
        exports.Operator.IN,
        exports.Operator.NOT_IN,
        exports.Operator.OF_TYPE,
        exports.Operator.MISSING,
    ];
    const PREFIX_OPERATORS = [
        exports.Operator.NOT_EQUALS,
        exports.Operator.GREATER_THAN,
        exports.Operator.LESS_THAN,
        exports.Operator.GREATER_THAN_OR_EQUALS,
        exports.Operator.LESS_THAN_OR_EQUALS,
        exports.Operator.STARTS_AFTER,
        exports.Operator.ENDS_BEFORE,
        exports.Operator.APPROXIMATELY,
    ];
    /**
     * Parses a URL into a SearchRequest.
     *
     * See the FHIR search spec: http://hl7.org/fhir/r4/search.html
     *
     * @param url The URL to parse.
     * @returns Parsed search definition.
     */
    function parseSearchDefinition(url) {
        const location = new URL(url, 'https://example.com/');
        const resourceType = location.pathname
            .replace(/(^\/)|(\/$)/g, '') // Remove leading and trailing slashes
            .split('/')
            .pop();
        const params = new URLSearchParams(location.search);
        let filters = undefined;
        let sortRules = undefined;
        let fields = undefined;
        let offset = undefined;
        let count = undefined;
        let total = undefined;
        params.forEach((value, key) => {
            if (key === '_fields') {
                fields = value.split(',');
            }
            else if (key === '_offset') {
                offset = parseInt(value);
            }
            else if (key === '_count') {
                count = parseInt(value);
            }
            else if (key === '_total') {
                total = value;
            }
            else if (key === '_sort') {
                sortRules = sortRules || [];
                sortRules.push(parseSortRule(value));
            }
            else {
                filters = filters || [];
                filters.push(parseSearchFilter(key, value));
            }
        });
        return {
            resourceType,
            filters,
            fields,
            offset,
            count,
            total,
            sortRules,
        };
    }
    /**
     * Parses a URL query parameter into a sort rule.
     *
     * By default, the sort rule is the field name.
     *
     * Sort rules can be reversed into descending order by prefixing the field name with a minus sign.
     *
     * See sorting: http://hl7.org/fhir/r4/search.html#_sort
     *
     * @param value The URL parameter value.
     * @returns The parsed sort rule.
     */
    function parseSortRule(value) {
        if (value.startsWith('-')) {
            return { code: value.substring(1), descending: true };
        }
        else {
            return { code: value };
        }
    }
    /**
     * Parses a URL query parameter into a search filter.
     *
     * FHIR search filters can be specified as modifiers or prefixes.
     *
     * For string properties, modifiers are appended to the key, e.g. "name:contains=eve".
     *
     * For date and numeric properties, prefixes are prepended to the value, e.g. "birthdate=gt2000".
     *
     * See the FHIR search spec: http://hl7.org/fhir/r4/search.html
     *
     * @param key The URL parameter key.
     * @param value The URL parameter value.
     * @returns The parsed search filter.
     */
    function parseSearchFilter(key, value) {
        let code = key;
        let operator = exports.Operator.EQUALS;
        for (const modifier of MODIFIER_OPERATORS) {
            const modifierIndex = code.indexOf(':' + modifier);
            if (modifierIndex !== -1) {
                operator = modifier;
                code = code.substring(0, modifierIndex);
            }
        }
        for (const prefix of PREFIX_OPERATORS) {
            if (value.match(new RegExp('^' + prefix + '\\d'))) {
                operator = prefix;
                value = value.substring(prefix.length);
            }
        }
        return { code, operator, value };
    }
    /**
     * Formats a search definition object into a query string.
     * Note: The return value does not include the resource type.
     * @param {!SearchRequest} definition The search definition.
     * @returns Formatted URL.
     */
    function formatSearchQuery(definition) {
        const params = [];
        if (definition.fields) {
            params.push('_fields=' + definition.fields.join(','));
        }
        if (definition.filters) {
            definition.filters.forEach((filter) => params.push(formatFilter(filter)));
        }
        if (definition.sortRules && definition.sortRules.length > 0) {
            params.push(formatSortRules(definition.sortRules));
        }
        if (definition.offset !== undefined) {
            params.push('_offset=' + definition.offset);
        }
        if (definition.count !== undefined) {
            params.push('_count=' + definition.count);
        }
        if (definition.total !== undefined) {
            params.push('_total=' + definition.total);
        }
        if (params.length === 0) {
            return '';
        }
        params.sort();
        return '?' + params.join('&');
    }
    function formatFilter(filter) {
        const modifier = MODIFIER_OPERATORS.includes(filter.operator) ? ':' + filter.operator : '';
        const prefix = PREFIX_OPERATORS.includes(filter.operator) ? filter.operator : '';
        return `${filter.code}${modifier}=${prefix}${encodeURIComponent(filter.value)}`;
    }
    function formatSortRules(sortRules) {
        if (!sortRules || sortRules.length === 0) {
            return '';
        }
        return '_sort=' + sortRules.map((sr) => (sr.descending ? '-' + sr.code : sr.code)).join(',');
    }

    exports.SearchParameterType = void 0;
    (function (SearchParameterType) {
        SearchParameterType["BOOLEAN"] = "BOOLEAN";
        SearchParameterType["NUMBER"] = "NUMBER";
        SearchParameterType["QUANTITY"] = "QUANTITY";
        SearchParameterType["TEXT"] = "TEXT";
        SearchParameterType["REFERENCE"] = "REFERENCE";
        SearchParameterType["DATE"] = "DATE";
        SearchParameterType["DATETIME"] = "DATETIME";
        SearchParameterType["PERIOD"] = "PERIOD";
    })(exports.SearchParameterType || (exports.SearchParameterType = {}));
    /**
     * Returns the type details of a SearchParameter.
     *
     * The SearchParameter resource has a "type" parameter, but that is missing some critical information.
     *
     * For example:
     *   1) The "date" type includes "date", "datetime", and "period".
     *   2) The "token" type includes enums and booleans.
     *   3) Arrays/multiple values are not reflected at all.
     *
     * @param resourceType The root resource type.
     * @param searchParam The search parameter.
     * @returns The search parameter type details.
     */
    function getSearchParameterDetails(resourceType, searchParam) {
        let result = globalSchema.types[resourceType]?.searchParamsDetails?.[searchParam.code];
        if (!result) {
            result = buildSearchParamterDetails(resourceType, searchParam);
        }
        return result;
    }
    function setSearchParamterDetails(resourceType, code, details) {
        const typeSchema = globalSchema.types[resourceType];
        if (!typeSchema.searchParamsDetails) {
            typeSchema.searchParamsDetails = {};
        }
        typeSchema.searchParamsDetails[code] = details;
    }
    function buildSearchParamterDetails(resourceType, searchParam) {
        if (searchParam.code === '_lastUpdated') {
            return { columnName: 'lastUpdated', type: exports.SearchParameterType.DATETIME };
        }
        const code = searchParam.code;
        const columnName = convertCodeToColumnName(code);
        const expression = getExpressionForResourceType(resourceType, searchParam.expression)?.split('.');
        if (!expression) {
            // This happens on compound types
            // In the future, explore returning multiple column definitions
            return { columnName, type: exports.SearchParameterType.TEXT };
        }
        const defaultType = getSearchParameterType(searchParam);
        let baseType = resourceType;
        let elementDefinition = undefined;
        let propertyType = undefined;
        let array = false;
        for (let i = 1; i < expression.length; i++) {
            const propertyName = expression[i];
            elementDefinition =
                globalSchema.types[baseType]?.properties?.[propertyName] ??
                    globalSchema.types[baseType]?.properties?.[propertyName + '[x]'];
            if (!elementDefinition) {
                throw new Error(`Element definition not found for ${resourceType} ${searchParam.code}`);
            }
            if (elementDefinition.max === '*') {
                array = true;
            }
            propertyType = elementDefinition.type?.[0].code;
            if (!propertyType) {
                // This happens when one of parent properties uses contentReference
                // In the future, explore following the reference
                return { columnName, type: defaultType, array };
            }
            if (i < expression.length - 1) {
                if (propertyType === 'Element' || propertyType === 'BackboneElement') {
                    baseType = baseType + capitalize(propertyName);
                }
                else {
                    baseType = propertyType;
                }
            }
        }
        const type = getSearchParameterType(searchParam, propertyType);
        const result = { columnName, type, elementDefinition, array };
        setSearchParamterDetails(resourceType, code, result);
        return result;
    }
    /**
     * Converts a hyphen-delimited code to camelCase string.
     * @param code The search parameter code.
     * @returns The SQL column name.
     */
    function convertCodeToColumnName(code) {
        return code.split('-').reduce((result, word, index) => result + (index ? capitalize(word) : word), '');
    }
    function getSearchParameterType(searchParam, propertyType) {
        let type = exports.SearchParameterType.TEXT;
        switch (searchParam.type) {
            case 'date':
                if (propertyType === exports.PropertyType.dateTime || propertyType === exports.PropertyType.instant) {
                    type = exports.SearchParameterType.DATETIME;
                }
                else {
                    type = exports.SearchParameterType.DATE;
                }
                break;
            case 'number':
                type = exports.SearchParameterType.NUMBER;
                break;
            case 'quantity':
                type = exports.SearchParameterType.QUANTITY;
                break;
            case 'reference':
                type = exports.SearchParameterType.REFERENCE;
                break;
            case 'token':
                if (propertyType === 'boolean') {
                    type = exports.SearchParameterType.BOOLEAN;
                }
                break;
        }
        return type;
    }
    function getExpressionForResourceType(resourceType, expression) {
        const expressions = expression.split(' | ');
        for (const e of expressions) {
            if (isIgnoredExpression(e)) {
                continue;
            }
            const simplified = simplifyExpression(e);
            if (simplified.startsWith(resourceType + '.')) {
                return simplified;
            }
        }
        return undefined;
    }
    function isIgnoredExpression(input) {
        return input.includes(' as Period') || input.includes(' as SampledDate');
    }
    function simplifyExpression(input) {
        let result = input.trim();
        if (result.startsWith('(') && result.endsWith(')')) {
            result = result.substring(1, result.length - 1);
        }
        if (result.includes('[0]')) {
            result = result.replaceAll('[0]', '');
        }
        const stopStrings = [' != ', ' as ', '.as(', '.exists(', '.where('];
        for (const stopString of stopStrings) {
            if (result.includes(stopString)) {
                result = result.substring(0, result.indexOf(stopString));
            }
        }
        return result;
    }

    /**
     * Determines if the resource matches the search request.
     * @param resource The resource that was created or updated.
     * @param searchRequest The subscription criteria as a search request.
     * @returns True if the resource satisfies the search request.
     */
    function matchesSearchRequest(resource, searchRequest) {
        if (searchRequest.resourceType !== resource.resourceType) {
            return false;
        }
        if (searchRequest.filters) {
            for (const filter of searchRequest.filters) {
                if (!matchesSearchFilter(resource, searchRequest, filter)) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * Determines if the resource matches the search filter.
     * @param resource The resource that was created or updated.
     * @param filter One of the filters of a subscription criteria.
     * @returns True if the resource satisfies the search filter.
     */
    function matchesSearchFilter(resource, searchRequest, filter) {
        const searchParam = globalSchema.types[searchRequest.resourceType]?.searchParams?.[filter.code];
        switch (searchParam?.type) {
            case 'reference':
                return matchesReferenceFilter(resource, filter, searchParam);
            case 'string':
                return matchesStringFilter(resource, filter, searchParam);
            case 'token':
                return matchesTokenFilter(resource, filter, searchParam);
            case 'date':
                return matchesDateFilter(resource, filter, searchParam);
        }
        // Unknown search parameter or search parameter type
        // Default fail the check
        return false;
    }
    function matchesReferenceFilter(resource, filter, searchParam) {
        const values = evalFhirPath(searchParam.expression, resource);
        const negated = isNegated(filter.operator);
        if (filter.value === '' && values.length === 0) {
            // If the filter operator is "equals", then the filter matches.
            // If the filter operator is "not equals", then the filter does not match.
            return filter.operator === exports.Operator.EQUALS;
        }
        // Normalize the values array into reference strings
        const references = values.map((value) => (typeof value === 'string' ? value : value.reference));
        for (const filterValue of filter.value.split(',')) {
            let match = references.includes(filterValue);
            if (!match && filter.code === '_compartment') {
                // Backwards compability for compartment search parameter
                // In previous versions, the resource type was not required in compartment values
                // So, "123" would match "Patient/123"
                // We need to maintain this behavior for backwards compatibility
                match = references.some((reference) => reference?.endsWith('/' + filterValue));
            }
            if (match) {
                return !negated;
            }
        }
        // If "not equals" and no matches, then return true
        // If "equals" and no matches, then return false
        return negated;
    }
    function matchesTokenFilter(resource, filter, searchParam) {
        const details = getSearchParameterDetails(resource.resourceType, searchParam);
        if (details.type === exports.SearchParameterType.BOOLEAN) {
            return matchesBooleanFilter(resource, filter, searchParam);
        }
        else {
            return matchesStringFilter(resource, filter, searchParam);
        }
    }
    function matchesBooleanFilter(resource, filter, searchParam) {
        const values = evalFhirPath(searchParam.expression, resource);
        const expected = filter.value === 'true';
        const result = values.includes(expected);
        return isNegated(filter.operator) ? !result : result;
    }
    function matchesStringFilter(resource, filter, searchParam) {
        const resourceValues = evalFhirPath(searchParam.expression, resource);
        const filterValues = filter.value.split(',');
        const negated = isNegated(filter.operator);
        for (const resourceValue of resourceValues) {
            for (const filterValue of filterValues) {
                const match = matchesStringValue(resourceValue, filter.operator, filterValue);
                if (match) {
                    return !negated;
                }
            }
        }
        // If "not equals" and no matches, then return true
        // If "equals" and no matches, then return false
        return negated;
    }
    function matchesStringValue(resourceValue, operator, filterValue) {
        let str = '';
        if (resourceValue) {
            if (typeof resourceValue === 'string') {
                str = resourceValue;
            }
            else if (typeof resourceValue === 'object') {
                str = JSON.stringify(resourceValue);
            }
        }
        return str.toLowerCase().includes(filterValue.toLowerCase());
    }
    function matchesDateFilter(resource, filter, searchParam) {
        const resourceValues = evalFhirPath(searchParam.expression, resource);
        const filterValues = filter.value.split(',');
        const negated = isNegated(filter.operator);
        for (const resourceValue of resourceValues) {
            for (const filterValue of filterValues) {
                const match = matchesDateValue(resourceValue, filter.operator, filterValue);
                if (match) {
                    return !negated;
                }
            }
        }
        // If "not equals" and no matches, then return true
        // If "equals" and no matches, then return false
        return negated;
    }
    function matchesDateValue(resourceValue, operator, filterValue) {
        switch (operator) {
            case exports.Operator.STARTS_AFTER:
            case exports.Operator.GREATER_THAN:
                return resourceValue > filterValue;
            case exports.Operator.GREATER_THAN_OR_EQUALS:
                return resourceValue >= filterValue;
            case exports.Operator.ENDS_BEFORE:
            case exports.Operator.LESS_THAN:
                return resourceValue < filterValue;
            case exports.Operator.LESS_THAN_OR_EQUALS:
                return resourceValue <= filterValue;
            case exports.Operator.EQUALS:
            case exports.Operator.NOT_EQUALS:
                return resourceValue === filterValue;
        }
        return false;
    }
    function isNegated(operator) {
        return operator === exports.Operator.NOT_EQUALS || operator === exports.Operator.NOT;
    }

    const OK_ID = 'ok';
    const CREATED_ID = 'created';
    const GONE_ID = 'gone';
    const NOT_MODIFIED_ID = 'not-modified';
    const NOT_FOUND_ID = 'not-found';
    const UNAUTHORIZED_ID = 'unauthorized';
    const FORBIDDEN_ID = 'forbidden';
    const TOO_MANY_REQUESTS_ID = 'too-many-requests';
    const allOk = {
        resourceType: 'OperationOutcome',
        id: OK_ID,
        issue: [
            {
                severity: 'information',
                code: 'informational',
                details: {
                    text: 'All OK',
                },
            },
        ],
    };
    const created = {
        resourceType: 'OperationOutcome',
        id: CREATED_ID,
        issue: [
            {
                severity: 'information',
                code: 'informational',
                details: {
                    text: 'Created',
                },
            },
        ],
    };
    const notModified = {
        resourceType: 'OperationOutcome',
        id: NOT_MODIFIED_ID,
        issue: [
            {
                severity: 'information',
                code: 'informational',
                details: {
                    text: 'Not Modified',
                },
            },
        ],
    };
    const notFound = {
        resourceType: 'OperationOutcome',
        id: NOT_FOUND_ID,
        issue: [
            {
                severity: 'error',
                code: 'not-found',
                details: {
                    text: 'Not found',
                },
            },
        ],
    };
    const unauthorized = {
        resourceType: 'OperationOutcome',
        id: UNAUTHORIZED_ID,
        issue: [
            {
                severity: 'error',
                code: 'login',
                details: {
                    text: 'Unauthorized',
                },
            },
        ],
    };
    const forbidden = {
        resourceType: 'OperationOutcome',
        id: FORBIDDEN_ID,
        issue: [
            {
                severity: 'error',
                code: 'forbidden',
                details: {
                    text: 'Forbidden',
                },
            },
        ],
    };
    const gone = {
        resourceType: 'OperationOutcome',
        id: GONE_ID,
        issue: [
            {
                severity: 'error',
                code: 'deleted',
                details: {
                    text: 'Gone',
                },
            },
        ],
    };
    const tooManyRequests = {
        resourceType: 'OperationOutcome',
        id: TOO_MANY_REQUESTS_ID,
        issue: [
            {
                severity: 'error',
                code: 'throttled',
                details: {
                    text: 'Too Many Requests',
                },
            },
        ],
    };
    function badRequest(details, expression) {
        return {
            resourceType: 'OperationOutcome',
            issue: [
                {
                    severity: 'error',
                    code: 'invalid',
                    details: {
                        text: details,
                    },
                    expression: expression ? [expression] : undefined,
                },
            ],
        };
    }
    function isOk(outcome) {
        return outcome.id === OK_ID || outcome.id === CREATED_ID || outcome.id === NOT_MODIFIED_ID;
    }
    function isNotFound(outcome) {
        return outcome.id === NOT_FOUND_ID;
    }
    function isGone(outcome) {
        return outcome.id === GONE_ID;
    }
    function getStatus(outcome) {
        if (outcome.id === OK_ID) {
            return 200;
        }
        else if (outcome.id === CREATED_ID) {
            return 201;
        }
        else if (outcome.id === NOT_MODIFIED_ID) {
            return 304;
        }
        else if (outcome.id === UNAUTHORIZED_ID) {
            return 401;
        }
        else if (outcome.id === FORBIDDEN_ID) {
            return 403;
        }
        else if (outcome.id === NOT_FOUND_ID) {
            return 404;
        }
        else if (outcome.id === GONE_ID) {
            return 410;
        }
        else if (outcome.id === TOO_MANY_REQUESTS_ID) {
            return 429;
        }
        else {
            return 400;
        }
    }
    /**
     * Asserts that the operation completed successfully and that the resource is defined.
     * @param outcome The operation outcome.
     * @param resource The resource that may or may not have been returned.
     */
    function assertOk(outcome, resource) {
        if (!isOk(outcome) || resource === undefined) {
            throw new OperationOutcomeError(outcome);
        }
    }
    class OperationOutcomeError extends Error {
        constructor(outcome) {
            super(outcome?.issue?.[0].details?.text);
            this.outcome = outcome;
        }
    }
    /**
     * Normalizes an error object into a displayable error string.
     * @param error The error value which could be a string, Error, OperationOutcome, or other unknown type.
     * @returns A display string for the error.
     */
    function normalizeErrorString(error) {
        if (!error) {
            return 'Unknown error';
        }
        if (typeof error === 'string') {
            return error;
        }
        if (error instanceof Error) {
            return error.message;
        }
        if (typeof error === 'object' && 'resourceType' in error) {
            const outcome = error;
            return outcome.issue?.[0]?.details?.text ?? 'Unknown error';
        }
        return JSON.stringify(error);
    }

    exports.AndAtom = AndAtom;
    exports.ArithemticOperatorAtom = ArithemticOperatorAtom;
    exports.AsAtom = AsAtom;
    exports.ConcatAtom = ConcatAtom;
    exports.ContainsAtom = ContainsAtom;
    exports.DEFAULT_SEARCH_COUNT = DEFAULT_SEARCH_COUNT;
    exports.DotAtom = DotAtom;
    exports.EmptySetAtom = EmptySetAtom;
    exports.EqualsAtom = EqualsAtom;
    exports.EquivalentAtom = EquivalentAtom;
    exports.FHIRPATH_KEYWORDS = FHIRPATH_KEYWORDS;
    exports.FHIRPATH_OPERATORS = FHIRPATH_OPERATORS;
    exports.FhirPathAtom = FhirPathAtom;
    exports.FunctionAtom = FunctionAtom;
    exports.Hl7Context = Hl7Context;
    exports.Hl7Field = Hl7Field;
    exports.Hl7Message = Hl7Message;
    exports.Hl7Segment = Hl7Segment;
    exports.InAtom = InAtom;
    exports.IndexerAtom = IndexerAtom;
    exports.IsAtom = IsAtom;
    exports.LRUCache = LRUCache;
    exports.LiteralAtom = LiteralAtom;
    exports.MEDPLUM_VERSION = MEDPLUM_VERSION;
    exports.MedplumClient = MedplumClient;
    exports.NotEqualsAtom = NotEqualsAtom;
    exports.NotEquivalentAtom = NotEquivalentAtom;
    exports.OperationOutcomeError = OperationOutcomeError;
    exports.OrAtom = OrAtom;
    exports.ReadablePromise = ReadablePromise;
    exports.SymbolAtom = SymbolAtom;
    exports.UnaryOperatorAtom = UnaryOperatorAtom;
    exports.UnionAtom = UnionAtom;
    exports.XorAtom = XorAtom;
    exports.allOk = allOk;
    exports.arrayBufferToBase64 = arrayBufferToBase64;
    exports.arrayBufferToHex = arrayBufferToHex;
    exports.assertOk = assertOk;
    exports.badRequest = badRequest;
    exports.booleanToTypedValue = booleanToTypedValue;
    exports.buildTypeName = buildTypeName;
    exports.calculateAge = calculateAge;
    exports.calculateAgeString = calculateAgeString;
    exports.capitalize = capitalize;
    exports.createReference = createReference;
    exports.createSchema = createSchema;
    exports.created = created;
    exports.deepClone = deepClone;
    exports.deepEquals = deepEquals$1;
    exports.evalFhirPath = evalFhirPath;
    exports.evalFhirPathTyped = evalFhirPathTyped;
    exports.fhirPathArrayEquals = fhirPathArrayEquals;
    exports.fhirPathArrayEquivalent = fhirPathArrayEquivalent;
    exports.fhirPathEquals = fhirPathEquals;
    exports.fhirPathEquivalent = fhirPathEquivalent;
    exports.fhirPathIs = fhirPathIs;
    exports.fhirPathNot = fhirPathNot;
    exports.findObservationInterval = findObservationInterval;
    exports.findObservationReferenceRange = findObservationReferenceRange;
    exports.forbidden = forbidden;
    exports.formatAddress = formatAddress;
    exports.formatCodeableConcept = formatCodeableConcept;
    exports.formatCoding = formatCoding;
    exports.formatDate = formatDate;
    exports.formatDateTime = formatDateTime;
    exports.formatFamilyName = formatFamilyName;
    exports.formatGivenName = formatGivenName;
    exports.formatHumanName = formatHumanName;
    exports.formatMoney = formatMoney;
    exports.formatObservationValue = formatObservationValue;
    exports.formatPeriod = formatPeriod;
    exports.formatQuantity = formatQuantity;
    exports.formatRange = formatRange;
    exports.formatSearchQuery = formatSearchQuery;
    exports.formatTime = formatTime;
    exports.formatTiming = formatTiming;
    exports.getCodeBySystem = getCodeBySystem;
    exports.getDateProperty = getDateProperty;
    exports.getDisplayString = getDisplayString;
    exports.getElementDefinition = getElementDefinition;
    exports.getExpressionForResourceType = getExpressionForResourceType;
    exports.getExtensionValue = getExtensionValue;
    exports.getIdentifier = getIdentifier;
    exports.getImageSrc = getImageSrc;
    exports.getPropertyDisplayName = getPropertyDisplayName;
    exports.getQuestionnaireAnswers = getQuestionnaireAnswers;
    exports.getReferenceString = getReferenceString;
    exports.getSearchParameterDetails = getSearchParameterDetails;
    exports.getStatus = getStatus;
    exports.getTypedPropertyValue = getTypedPropertyValue;
    exports.globalSchema = globalSchema;
    exports.gone = gone;
    exports.indexSearchParameter = indexSearchParameter;
    exports.indexSearchParameterBundle = indexSearchParameterBundle;
    exports.indexStructureDefinition = indexStructureDefinition;
    exports.indexStructureDefinitionBundle = indexStructureDefinitionBundle;
    exports.initFhirPathParserBuilder = initFhirPathParserBuilder;
    exports.isEmpty = isEmpty;
    exports.isGone = isGone;
    exports.isLowerCase = isLowerCase;
    exports.isNotFound = isNotFound;
    exports.isObject = isObject$1;
    exports.isOk = isOk;
    exports.isPeriod = isPeriod;
    exports.isProfileResource = isProfileResource;
    exports.isQuantity = isQuantity;
    exports.isQuantityEquivalent = isQuantityEquivalent;
    exports.isStringArray = isStringArray;
    exports.isUUID = isUUID;
    exports.isValidDate = isValidDate;
    exports.matchesRange = matchesRange;
    exports.matchesSearchRequest = matchesSearchRequest;
    exports.normalizeErrorString = normalizeErrorString;
    exports.notFound = notFound;
    exports.notModified = notModified;
    exports.parseFhirPath = parseFhirPath;
    exports.parseJWTPayload = parseJWTPayload;
    exports.parseSearchDefinition = parseSearchDefinition;
    exports.preciseEquals = preciseEquals;
    exports.preciseGreaterThan = preciseGreaterThan;
    exports.preciseGreaterThanOrEquals = preciseGreaterThanOrEquals;
    exports.preciseLessThan = preciseLessThan;
    exports.preciseLessThanOrEquals = preciseLessThanOrEquals;
    exports.preciseRound = preciseRound;
    exports.removeDuplicates = removeDuplicates;
    exports.resolveId = resolveId;
    exports.setCodeBySystem = setCodeBySystem;
    exports.stringify = stringify;
    exports.toJsBoolean = toJsBoolean;
    exports.toTypedValue = toTypedValue;
    exports.tokenize = tokenize;
    exports.tooManyRequests = tooManyRequests;
    exports.unauthorized = unauthorized;

}));
//# sourceMappingURL=index.cjs.map
