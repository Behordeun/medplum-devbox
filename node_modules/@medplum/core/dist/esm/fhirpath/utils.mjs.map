{"version":3,"file":"utils.mjs","sources":["../../../src/fhirpath/utils.ts"],"sourcesContent":["import { ElementDefinition, Period, Quantity, Resource } from '@medplum/fhirtypes';\nimport { buildTypeName, getElementDefinition, PropertyType, TypedValue } from '../types';\nimport { capitalize, isEmpty } from '../utils';\n\n/**\n * Returns a single element array with a typed boolean value.\n * @param value The primitive boolean value.\n * @returns Single element array with a typed boolean value.\n */\nexport function booleanToTypedValue(value: boolean): [TypedValue] {\n  return [{ type: PropertyType.boolean, value }];\n}\n\n/**\n * Returns a \"best guess\" TypedValue for a given value.\n * @param value The unknown value to check.\n * @returns A \"best guess\" TypedValue for the given value.\n */\nexport function toTypedValue(value: unknown): TypedValue {\n  if (value === null || value === undefined) {\n    return { type: 'undefined', value: undefined };\n  } else if (Number.isSafeInteger(value)) {\n    return { type: PropertyType.integer, value };\n  } else if (typeof value === 'number') {\n    return { type: PropertyType.decimal, value };\n  } else if (typeof value === 'boolean') {\n    return { type: PropertyType.boolean, value };\n  } else if (typeof value === 'string') {\n    return { type: PropertyType.string, value };\n  } else if (isQuantity(value)) {\n    return { type: PropertyType.Quantity, value };\n  } else if (typeof value === 'object' && 'resourceType' in value) {\n    return { type: (value as Resource).resourceType, value };\n  } else {\n    return { type: PropertyType.BackboneElement, value };\n  }\n}\n\n/**\n * Converts unknown object into a JavaScript boolean.\n * Note that this is different than the FHIRPath \"toBoolean\",\n * which has particular semantics around arrays, empty arrays, and type conversions.\n * @param obj Any value or array of values.\n * @returns The converted boolean value according to FHIRPath rules.\n */\nexport function toJsBoolean(obj: TypedValue[]): boolean {\n  return obj.length === 0 ? false : !!obj[0].value;\n}\n\n/**\n * Returns the value of the property and the property type.\n * Some property definitions support multiple types.\n * For example, \"Observation.value[x]\" can be \"valueString\", \"valueInteger\", \"valueQuantity\", etc.\n * According to the spec, there can only be one property for a given element definition.\n * This function returns the value and the type.\n * @param input The base context (FHIR resource or backbone element).\n * @param path The property path.\n * @returns The value of the property and the property type.\n */\nexport function getTypedPropertyValue(input: TypedValue, path: string): TypedValue[] | TypedValue | undefined {\n  if (!input?.value) {\n    return undefined;\n  }\n\n  const elementDefinition = getElementDefinition(input.type, path);\n  if (elementDefinition) {\n    const typedResult = getTypedPropertyValueWithSchema(input, path, elementDefinition);\n    if (typedResult) {\n      return typedResult;\n    }\n  }\n\n  return getTypedPropertyValueWithoutSchema(input, path);\n}\n\n/**\n * Returns the value of the property and the property type using a type schema.\n * @param input The base context (FHIR resource or backbone element).\n * @param path The property path.\n * @param property The property element definition.\n * @returns The value of the property and the property type.\n */\nfunction getTypedPropertyValueWithSchema(\n  input: TypedValue,\n  path: string,\n  property: ElementDefinition\n): TypedValue[] | TypedValue | undefined {\n  const types = property.type;\n  if (!types || types.length === 0) {\n    return undefined;\n  }\n\n  let resultValue: any = undefined;\n  let resultType = 'undefined';\n\n  if (types.length === 1) {\n    resultValue = input.value[path];\n    resultType = types[0].code as string;\n  } else {\n    for (const type of types) {\n      const path2 = path.replace('[x]', '') + capitalize(type.code as string);\n      if (path2 in input.value) {\n        resultValue = input.value[path2];\n        resultType = type.code as string;\n        break;\n      }\n    }\n  }\n\n  if (isEmpty(resultValue)) {\n    return undefined;\n  }\n\n  if (resultType === 'Element' || resultType === 'BackboneElement') {\n    resultType = buildTypeName(property.path?.split('.') as string[]);\n  }\n\n  if (Array.isArray(resultValue)) {\n    return resultValue.map((element) => toTypedValueWithType(element, resultType));\n  } else {\n    return toTypedValueWithType(resultValue, resultType);\n  }\n}\n\nfunction toTypedValueWithType(value: any, type: string): TypedValue {\n  if (type === 'Resource' && typeof value === 'object' && 'resourceType' in value) {\n    type = value.resourceType;\n  }\n  return { type, value };\n}\n\n/**\n * Returns the value of the property and the property type using a type schema.\n * Note that because the type schema is not available, this function may be inaccurate.\n * In some cases, that is the desired behavior.\n * @param typedValue The base context (FHIR resource or backbone element).\n * @param path The property path.\n * @returns The value of the property and the property type.\n */\nfunction getTypedPropertyValueWithoutSchema(\n  typedValue: TypedValue,\n  path: string\n): TypedValue[] | TypedValue | undefined {\n  const input = typedValue.value;\n  if (!input || typeof input !== 'object') {\n    return undefined;\n  }\n\n  let result: any = undefined;\n  if (path in input) {\n    result = (input as { [key: string]: unknown })[path];\n  } else {\n    // Only support property names that would be valid types\n    // Examples:\n    // value + valueString = ok, because \"string\" is valid\n    // value + valueDecimal = ok, because \"decimal\" is valid\n    // id + identifiier = not ok, because \"entifier\" is not a valid type\n    // resource + resourceType = not ok, because \"type\" is not a valid type\n    for (const propertyType in PropertyType) {\n      const propertyName = path + capitalize(propertyType);\n      if (propertyName in input) {\n        result = (input as { [key: string]: unknown })[propertyName];\n        break;\n      }\n    }\n  }\n\n  if (isEmpty(result)) {\n    return undefined;\n  }\n\n  if (Array.isArray(result)) {\n    return result.map(toTypedValue);\n  } else {\n    return toTypedValue(result);\n  }\n}\n\n/**\n * Removes duplicates in array using FHIRPath equality rules.\n * @param arr The input array.\n * @returns The result array with duplicates removed.\n */\nexport function removeDuplicates(arr: TypedValue[]): TypedValue[] {\n  const result: TypedValue[] = [];\n  for (const i of arr) {\n    let found = false;\n    for (const j of result) {\n      if (toJsBoolean(fhirPathEquals(i, j))) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\n/**\n * Returns a negated FHIRPath boolean expression.\n * @param input The input array.\n * @returns The negated type value array.\n */\nexport function fhirPathNot(input: TypedValue[]): TypedValue[] {\n  return booleanToTypedValue(!toJsBoolean(input));\n}\n\n/**\n * Determines if two arrays are equal according to FHIRPath equality rules.\n * @param x The first array.\n * @param y The second array.\n * @returns FHIRPath true if the arrays are equal.\n */\nexport function fhirPathArrayEquals(x: TypedValue[], y: TypedValue[]): TypedValue[] {\n  if (x.length === 0 || y.length === 0) {\n    return [];\n  }\n  if (x.length !== y.length) {\n    return booleanToTypedValue(false);\n  }\n  return booleanToTypedValue(x.every((val, index) => toJsBoolean(fhirPathEquals(val, y[index]))));\n}\n\n/**\n * Determines if two values are equal according to FHIRPath equality rules.\n * @param x The first value.\n * @param y The second value.\n * @returns True if equal.\n */\nexport function fhirPathEquals(x: TypedValue, y: TypedValue): TypedValue[] {\n  const xValue = x.value;\n  const yValue = y.value;\n  if (typeof xValue === 'number' && typeof yValue === 'number') {\n    return booleanToTypedValue(Math.abs(xValue - yValue) < 1e-8);\n  }\n  if (isQuantity(xValue) && isQuantity(yValue)) {\n    return booleanToTypedValue(isQuantityEquivalent(xValue, yValue));\n  }\n  if (typeof xValue === 'object' && typeof yValue === 'object') {\n    return booleanToTypedValue(deepEquals(x, y));\n  }\n  return booleanToTypedValue(xValue === yValue);\n}\n\n/**\n * Determines if two arrays are equivalent according to FHIRPath equality rules.\n * @param x The first array.\n * @param y The second array.\n * @returns FHIRPath true if the arrays are equivalent.\n */\nexport function fhirPathArrayEquivalent(x: TypedValue[], y: TypedValue[]): TypedValue[] {\n  if (x.length === 0 && y.length === 0) {\n    return booleanToTypedValue(true);\n  }\n  if (x.length !== y.length) {\n    return booleanToTypedValue(false);\n  }\n  x.sort(fhirPathEquivalentCompare);\n  y.sort(fhirPathEquivalentCompare);\n  return booleanToTypedValue(x.every((val, index) => toJsBoolean(fhirPathEquivalent(val, y[index]))));\n}\n\n/**\n * Determines if two values are equivalent according to FHIRPath equality rules.\n * @param x The first value.\n * @param y The second value.\n * @returns True if equivalent.\n */\nexport function fhirPathEquivalent(x: TypedValue, y: TypedValue): TypedValue[] {\n  const xValue = x.value;\n  const yValue = y.value;\n  if (typeof xValue === 'number' && typeof yValue === 'number') {\n    // Use more generous threshold than equality\n    // Decimal: values must be equal, comparison is done on values rounded to the precision of the least precise operand.\n    // Trailing zeroes after the decimal are ignored in determining precision.\n    return booleanToTypedValue(Math.abs(xValue - yValue) < 0.01);\n  }\n  if (isQuantity(xValue) && isQuantity(yValue)) {\n    return booleanToTypedValue(isQuantityEquivalent(xValue, yValue));\n  }\n  if (typeof xValue === 'object' && typeof yValue === 'object') {\n    return booleanToTypedValue(deepEquals(xValue, yValue));\n  }\n  if (typeof xValue === 'string' && typeof yValue === 'string') {\n    // String: the strings must be the same, ignoring case and locale, and normalizing whitespace\n    // (see String Equivalence for more details).\n    return booleanToTypedValue(xValue.toLowerCase() === yValue.toLowerCase());\n  }\n  return booleanToTypedValue(xValue === yValue);\n}\n\n/**\n * Returns the sort order of two values for FHIRPath array equivalence.\n * @param x The first value.\n * @param y The second value.\n * @returns The sort order of the values.\n */\nfunction fhirPathEquivalentCompare(x: TypedValue, y: TypedValue): number {\n  const xValue = x.value;\n  const yValue = y.value;\n  if (typeof xValue === 'number' && typeof yValue === 'number') {\n    return xValue - yValue;\n  }\n  if (typeof xValue === 'string' && typeof yValue === 'string') {\n    return xValue.localeCompare(yValue);\n  }\n  return 0;\n}\n\n/**\n * Determines if the typed value is the desired type.\n * @param typedValue The typed value to check.\n * @param desiredType The desired type name.\n * @returns True if the typed value is of the desired type.\n */\nexport function fhirPathIs(typedValue: TypedValue, desiredType: string): boolean {\n  const { value } = typedValue;\n  if (value === undefined || value === null) {\n    return false;\n  }\n\n  switch (desiredType) {\n    case 'Boolean':\n      return typeof value === 'boolean';\n    case 'Decimal':\n    case 'Integer':\n      return typeof value === 'number';\n    case 'Date':\n      return typeof value === 'string' && !!value.match(/^\\d{4}(-\\d{2}(-\\d{2})?)?/);\n    case 'DateTime':\n      return typeof value === 'string' && !!value.match(/^\\d{4}(-\\d{2}(-\\d{2})?)?T/);\n    case 'Time':\n      return typeof value === 'string' && !!value.match(/^T\\d/);\n    case 'Period':\n      return isPeriod(value);\n    case 'Quantity':\n      return isQuantity(value);\n    default:\n      return typeof value === 'object' && value?.resourceType === desiredType;\n  }\n}\n\n/**\n * Determines if the input is a Period object.\n * This is heuristic based, as we do not have strong typing at runtime.\n * @param input The input value.\n * @returns True if the input is a period.\n */\nexport function isPeriod(input: unknown): input is Period {\n  return !!(input && typeof input === 'object' && 'start' in input);\n}\n\n/**\n * Determines if the input is a Quantity object.\n * This is heuristic based, as we do not have strong typing at runtime.\n * @param input The input value.\n * @returns True if the input is a quantity.\n */\nexport function isQuantity(input: unknown): input is Quantity {\n  return !!(input && typeof input === 'object' && 'value' in input && typeof (input as Quantity).value === 'number');\n}\n\nexport function isQuantityEquivalent(x: Quantity, y: Quantity): boolean {\n  return (\n    Math.abs((x.value as number) - (y.value as number)) < 0.01 &&\n    (x.unit === y.unit || x.code === y.code || x.unit === y.code || x.code === y.unit)\n  );\n}\n\n/**\n * Resource equality.\n * See: https://dmitripavlutin.com/how-to-compare-objects-in-javascript/#4-deep-equality\n * @param object1 The first object.\n * @param object2 The second object.\n * @returns True if the objects are equal.\n */\nfunction deepEquals<T1 extends object, T2 extends object>(object1: T1, object2: T2): boolean {\n  const keys1 = Object.keys(object1) as (keyof T1)[];\n  const keys2 = Object.keys(object2) as (keyof T2)[];\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n  for (const key of keys1) {\n    const val1 = object1[key] as unknown;\n    const val2 = object2[key as unknown as keyof T2] as unknown;\n    if (isObject(val1) && isObject(val2)) {\n      if (!deepEquals(val1, val2)) {\n        return false;\n      }\n    } else {\n      if (val1 !== val2) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction isObject(obj: unknown): obj is object {\n  return obj !== null && typeof obj === 'object';\n}\n"],"names":[],"mappings":"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"}