import { ParserBuilder } from '../fhirlexer/parse.mjs';
import '../fhirlexer/tokenize.mjs';
import { PropertyType } from '../types.mjs';
import { LiteralAtom, SymbolAtom, EmptySetAtom, UnaryOperatorAtom, ArithemticOperatorAtom, DotAtom, UnionAtom, EqualsAtom, NotEqualsAtom, EquivalentAtom, NotEquivalentAtom, ConcatAtom, AndAtom, AsAtom, ContainsAtom, InAtom, IsAtom, OrAtom, XorAtom, FhirPathAtom, IndexerAtom, FunctionAtom } from './atoms.mjs';
import { parseDateString } from './date.mjs';
import { tokenize } from './tokenize.mjs';
import { toTypedValue } from './utils.mjs';

const PARENTHESES_PARSELET = {
    parse(parser) {
        const expr = parser.consumeAndParse();
        if (!parser.match(')')) {
            throw new Error('Parse error: expected `)` got `' + parser.peek()?.value + '`');
        }
        return expr;
    },
};
const INDEXER_PARSELET = {
    parse(parser, left) {
        const expr = parser.consumeAndParse();
        if (!parser.match(']')) {
            throw new Error('Parse error: expected `]`');
        }
        return new IndexerAtom(left, expr);
    },
    precedence: 2 /* OperatorPrecedence.Indexer */,
};
const FUNCTION_CALL_PARSELET = {
    parse(parser, left) {
        if (!(left instanceof SymbolAtom)) {
            throw new Error('Unexpected parentheses');
        }
        const args = [];
        while (!parser.match(')')) {
            args.push(parser.consumeAndParse());
            parser.match(',');
        }
        return new FunctionAtom(left.name, args); //, functions[left.name]);
    },
    precedence: 0 /* OperatorPrecedence.FunctionCall */,
};
function parseQuantity(str) {
    const parts = str.split(' ');
    const value = parseFloat(parts[0]);
    let unit = parts[1];
    if (unit && unit.startsWith("'") && unit.endsWith("'")) {
        unit = unit.substring(1, unit.length - 1);
    }
    else {
        unit = '{' + unit + '}';
    }
    return { value, unit };
}
function initFhirPathParserBuilder() {
    return new ParserBuilder()
        .registerPrefix('String', {
        parse: (_, token) => new LiteralAtom({ type: PropertyType.string, value: token.value }),
    })
        .registerPrefix('DateTime', {
        parse: (_, token) => new LiteralAtom({ type: PropertyType.dateTime, value: parseDateString(token.value) }),
    })
        .registerPrefix('Quantity', {
        parse: (_, token) => new LiteralAtom({ type: PropertyType.Quantity, value: parseQuantity(token.value) }),
    })
        .registerPrefix('Number', {
        parse: (_, token) => new LiteralAtom({ type: PropertyType.decimal, value: parseFloat(token.value) }),
    })
        .registerPrefix('true', { parse: () => new LiteralAtom({ type: PropertyType.boolean, value: true }) })
        .registerPrefix('false', { parse: () => new LiteralAtom({ type: PropertyType.boolean, value: false }) })
        .registerPrefix('Symbol', { parse: (_, token) => new SymbolAtom(token.value) })
        .registerPrefix('{}', { parse: () => new EmptySetAtom() })
        .registerPrefix('(', PARENTHESES_PARSELET)
        .registerInfix('[', INDEXER_PARSELET)
        .registerInfix('(', FUNCTION_CALL_PARSELET)
        .prefix('+', 3 /* OperatorPrecedence.UnaryAdd */, (_, right) => new UnaryOperatorAtom('+', right, (x) => x))
        .prefix('-', 3 /* OperatorPrecedence.UnarySubtract */, (_, right) => new ArithemticOperatorAtom('-', right, right, (_, y) => -y))
        .infixLeft('.', 1 /* OperatorPrecedence.Dot */, (left, _, right) => new DotAtom(left, right))
        .infixLeft('/', 4 /* OperatorPrecedence.Divide */, (left, _, right) => new ArithemticOperatorAtom('/', left, right, (x, y) => x / y))
        .infixLeft('*', 4 /* OperatorPrecedence.Multiply */, (left, _, right) => new ArithemticOperatorAtom('*', left, right, (x, y) => x * y))
        .infixLeft('+', 5 /* OperatorPrecedence.Add */, (left, _, right) => new ArithemticOperatorAtom('+', left, right, (x, y) => x + y))
        .infixLeft('-', 5 /* OperatorPrecedence.Subtract */, (left, _, right) => new ArithemticOperatorAtom('-', left, right, (x, y) => x - y))
        .infixLeft('|', 7 /* OperatorPrecedence.Union */, (left, _, right) => new UnionAtom(left, right))
        .infixLeft('=', 9 /* OperatorPrecedence.Equals */, (left, _, right) => new EqualsAtom(left, right))
        .infixLeft('!=', 9 /* OperatorPrecedence.Equals */, (left, _, right) => new NotEqualsAtom(left, right))
        .infixLeft('~', 9 /* OperatorPrecedence.Equivalent */, (left, _, right) => new EquivalentAtom(left, right))
        .infixLeft('!~', 9 /* OperatorPrecedence.NotEquivalent */, (left, _, right) => new NotEquivalentAtom(left, right))
        .infixLeft('<', 8 /* OperatorPrecedence.LessThan */, (left, _, right) => new ArithemticOperatorAtom('<', left, right, (x, y) => x < y))
        .infixLeft('<=', 8 /* OperatorPrecedence.LessThanOrEquals */, (left, _, right) => new ArithemticOperatorAtom('<=', left, right, (x, y) => x <= y))
        .infixLeft('>', 8 /* OperatorPrecedence.GreaterThan */, (left, _, right) => new ArithemticOperatorAtom('>', left, right, (x, y) => x > y))
        .infixLeft('>=', 8 /* OperatorPrecedence.GreaterThanOrEquals */, (left, _, right) => new ArithemticOperatorAtom('>=', left, right, (x, y) => x >= y))
        .infixLeft('&', 5 /* OperatorPrecedence.Ampersand */, (left, _, right) => new ConcatAtom(left, right))
        .infixLeft('and', 6 /* OperatorPrecedence.Is */, (left, _, right) => new AndAtom(left, right))
        .infixLeft('as', 6 /* OperatorPrecedence.Is */, (left, _, right) => new AsAtom(left, right))
        .infixLeft('contains', 6 /* OperatorPrecedence.Is */, (left, _, right) => new ContainsAtom(left, right))
        .infixLeft('div', 6 /* OperatorPrecedence.Is */, (left, _, right) => new ArithemticOperatorAtom('div', left, right, (x, y) => (x / y) | 0))
        .infixLeft('in', 6 /* OperatorPrecedence.Is */, (left, _, right) => new InAtom(left, right))
        .infixLeft('is', 6 /* OperatorPrecedence.Is */, (left, _, right) => new IsAtom(left, right))
        .infixLeft('mod', 6 /* OperatorPrecedence.Is */, (left, _, right) => new ArithemticOperatorAtom('mod', left, right, (x, y) => x % y))
        .infixLeft('or', 6 /* OperatorPrecedence.Is */, (left, _, right) => new OrAtom(left, right))
        .infixLeft('xor', 6 /* OperatorPrecedence.Is */, (left, _, right) => new XorAtom(left, right));
}
const fhirPathParserBuilder = initFhirPathParserBuilder();
/**
 * Parses a FHIRPath expression into an AST.
 * The result can be used to evaluate the expression against a resource or other object.
 * This method is useful if you know that you will evaluate the same expression many times
 * against different resources.
 * @param input The FHIRPath expression to parse.
 * @returns The AST representing the expression.
 */
function parseFhirPath(input) {
    return new FhirPathAtom(input, fhirPathParserBuilder.construct(tokenize(input)).consumeAndParse());
}
/**
 * Evaluates a FHIRPath expression against a resource or other object.
 * @param expression The FHIRPath expression to parse.
 * @param input The resource or object to evaluate the expression against.
 * @returns The result of the FHIRPath expression against the resource or object.
 */
function evalFhirPath(expression, input) {
    // eval requires a TypedValue array
    // As a convenience, we can accept array or non-array, and TypedValue or unknown value
    const array = Array.isArray(input) ? input : [input];
    for (let i = 0; i < array.length; i++) {
        const el = array[i];
        if (!(typeof el === 'object' && 'type' in el && 'value' in el)) {
            array[i] = toTypedValue(array[i]);
        }
    }
    return evalFhirPathTyped(expression, array).map((e) => e.value);
}
/**
 * Evaluates a FHIRPath expression against a resource or other object.
 * @param expression The FHIRPath expression to parse.
 * @param input The resource or object to evaluate the expression against.
 * @returns The result of the FHIRPath expression against the resource or object.
 */
function evalFhirPathTyped(expression, input) {
    return parseFhirPath(expression).eval(input);
}

export { evalFhirPath, evalFhirPathTyped, initFhirPathParserBuilder, parseFhirPath };
//# sourceMappingURL=parse.mjs.map
