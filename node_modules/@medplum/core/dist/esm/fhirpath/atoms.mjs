import { __classPrivateFieldGet } from '../node_modules/tslib/tslib.es6.mjs';
import { PrefixOperatorAtom, InfixOperatorAtom } from '../fhirlexer/parse.mjs';
import '../fhirlexer/tokenize.mjs';
import { PropertyType } from '../types.mjs';
import { functions } from './functions.mjs';
import { isQuantity, booleanToTypedValue, toTypedValue, removeDuplicates, fhirPathArrayEquals, fhirPathNot, fhirPathArrayEquivalent, fhirPathIs, toJsBoolean, getTypedPropertyValue } from './utils.mjs';

var _SymbolAtom_instances, _SymbolAtom_evalValue;
class FhirPathAtom {
    constructor(original, child) {
        this.original = original;
        this.child = child;
    }
    eval(context) {
        try {
            if (context.length > 0) {
                return context.map((e) => this.child.eval([e])).flat();
            }
            else {
                return this.child.eval([]);
            }
        }
        catch (error) {
            throw new Error(`FhirPathError on "${this.original}": ${error}`);
        }
    }
    toString() {
        return this.child.toString();
    }
}
class LiteralAtom {
    constructor(value) {
        this.value = value;
    }
    eval() {
        return [this.value];
    }
    toString() {
        const value = this.value.value;
        if (typeof value === 'string') {
            return `'${value}'`;
        }
        return value.toString();
    }
}
class SymbolAtom {
    constructor(name) {
        this.name = name;
        _SymbolAtom_instances.add(this);
    }
    eval(context) {
        if (this.name === '$this') {
            return context;
        }
        return context
            .map((e) => __classPrivateFieldGet(this, _SymbolAtom_instances, "m", _SymbolAtom_evalValue).call(this, e))
            .flat()
            .filter((e) => e?.value !== undefined);
    }
    toString() {
        return this.name;
    }
}
_SymbolAtom_instances = new WeakSet(), _SymbolAtom_evalValue = function _SymbolAtom_evalValue(typedValue) {
    const input = typedValue.value;
    if (!input || typeof input !== 'object') {
        return undefined;
    }
    if ('resourceType' in input && input.resourceType === this.name) {
        return typedValue;
    }
    return getTypedPropertyValue(typedValue, this.name);
};
class EmptySetAtom {
    eval() {
        return [];
    }
    toString() {
        return '{}';
    }
}
class UnaryOperatorAtom extends PrefixOperatorAtom {
    constructor(operator, child, impl) {
        super(operator, child);
        this.impl = impl;
    }
    eval(context) {
        return this.impl(this.child.eval(context));
    }
    toString() {
        return this.child.toString();
    }
}
class AsAtom extends InfixOperatorAtom {
    constructor(left, right) {
        super('as', left, right);
    }
    eval(context) {
        return functions.ofType(this.left.eval(context), this.right);
    }
}
class ArithemticOperatorAtom extends InfixOperatorAtom {
    constructor(operator, left, right, impl) {
        super(operator, left, right);
        this.impl = impl;
    }
    eval(context) {
        const leftEvalResult = this.left.eval(context);
        if (leftEvalResult.length !== 1) {
            return [];
        }
        const rightEvalResult = this.right.eval(context);
        if (rightEvalResult.length !== 1) {
            return [];
        }
        const leftValue = leftEvalResult[0].value;
        const rightValue = rightEvalResult[0].value;
        const leftNumber = isQuantity(leftValue) ? leftValue.value : leftValue;
        const rightNumber = isQuantity(rightValue) ? rightValue.value : rightValue;
        const result = this.impl(leftNumber, rightNumber);
        if (typeof result === 'boolean') {
            return booleanToTypedValue(result);
        }
        else if (isQuantity(leftValue)) {
            return [{ type: PropertyType.Quantity, value: { ...leftValue, value: result } }];
        }
        else {
            return [toTypedValue(result)];
        }
    }
}
class ConcatAtom extends InfixOperatorAtom {
    constructor(left, right) {
        super('&', left, right);
    }
    eval(context) {
        const leftValue = this.left.eval(context);
        const rightValue = this.right.eval(context);
        const result = [...leftValue, ...rightValue];
        if (result.length > 0 && result.every((e) => typeof e.value === 'string')) {
            return [{ type: PropertyType.string, value: result.map((e) => e.value).join('') }];
        }
        return result;
    }
}
class ContainsAtom extends InfixOperatorAtom {
    constructor(left, right) {
        super('contains', left, right);
    }
    eval(context) {
        const leftValue = this.left.eval(context);
        const rightValue = this.right.eval(context);
        return booleanToTypedValue(leftValue.some((e) => e.value === rightValue[0].value));
    }
}
class InAtom extends InfixOperatorAtom {
    constructor(left, right) {
        super('in', left, right);
    }
    eval(context) {
        const leftValue = this.left.eval(context);
        const rightValue = this.right.eval(context);
        return booleanToTypedValue(rightValue.some((e) => e.value === leftValue[0].value));
    }
}
class DotAtom extends InfixOperatorAtom {
    constructor(left, right) {
        super('.', left, right);
    }
    eval(context) {
        return this.right.eval(this.left.eval(context));
    }
    toString() {
        return `${this.left.toString()}.${this.right.toString()}`;
    }
}
class UnionAtom extends InfixOperatorAtom {
    constructor(left, right) {
        super('|', left, right);
    }
    eval(context) {
        const leftResult = this.left.eval(context);
        const rightResult = this.right.eval(context);
        return removeDuplicates([...leftResult, ...rightResult]);
    }
}
class EqualsAtom extends InfixOperatorAtom {
    constructor(left, right) {
        super('=', left, right);
    }
    eval(context) {
        const leftValue = this.left.eval(context);
        const rightValue = this.right.eval(context);
        return fhirPathArrayEquals(leftValue, rightValue);
    }
}
class NotEqualsAtom extends InfixOperatorAtom {
    constructor(left, right) {
        super('!=', left, right);
    }
    eval(context) {
        const leftValue = this.left.eval(context);
        const rightValue = this.right.eval(context);
        return fhirPathNot(fhirPathArrayEquals(leftValue, rightValue));
    }
}
class EquivalentAtom extends InfixOperatorAtom {
    constructor(left, right) {
        super('~', left, right);
    }
    eval(context) {
        const leftValue = this.left.eval(context);
        const rightValue = this.right.eval(context);
        return fhirPathArrayEquivalent(leftValue, rightValue);
    }
}
class NotEquivalentAtom extends InfixOperatorAtom {
    constructor(left, right) {
        super('!~', left, right);
    }
    eval(context) {
        const leftValue = this.left.eval(context);
        const rightValue = this.right.eval(context);
        return fhirPathNot(fhirPathArrayEquivalent(leftValue, rightValue));
    }
}
class IsAtom extends InfixOperatorAtom {
    constructor(left, right) {
        super('is', left, right);
    }
    eval(context) {
        const leftValue = this.left.eval(context);
        if (leftValue.length !== 1) {
            return [];
        }
        const typeName = this.right.name;
        return booleanToTypedValue(fhirPathIs(leftValue[0], typeName));
    }
}
/**
 * 6.5.1. and
 * Returns true if both operands evaluate to true,
 * false if either operand evaluates to false,
 * and the empty collection otherwise.
 */
class AndAtom extends InfixOperatorAtom {
    constructor(left, right) {
        super('and', left, right);
    }
    eval(context) {
        const leftValue = this.left.eval(context);
        const rightValue = this.right.eval(context);
        if (leftValue[0]?.value === true && rightValue[0]?.value === true) {
            return booleanToTypedValue(true);
        }
        if (leftValue[0]?.value === false || rightValue[0]?.value === false) {
            return booleanToTypedValue(false);
        }
        return [];
    }
}
class OrAtom extends InfixOperatorAtom {
    constructor(left, right) {
        super('or', left, right);
    }
    eval(context) {
        const leftValue = this.left.eval(context);
        if (toJsBoolean(leftValue)) {
            return leftValue;
        }
        const rightValue = this.right.eval(context);
        if (toJsBoolean(rightValue)) {
            return rightValue;
        }
        return [];
    }
}
/**
 * 6.5.4. xor
 * Returns true if exactly one of the operands evaluates to true,
 * false if either both operands evaluate to true or both operands evaluate to false,
 * and the empty collection otherwise.
 */
class XorAtom extends InfixOperatorAtom {
    constructor(left, right) {
        super('xor', left, right);
    }
    eval(context) {
        const leftResult = this.left.eval(context);
        const rightResult = this.right.eval(context);
        if (leftResult.length === 0 && rightResult.length === 0) {
            return [];
        }
        const leftValue = leftResult.length === 0 ? null : leftResult[0].value;
        const rightValue = rightResult.length === 0 ? null : rightResult[0].value;
        if ((leftValue === true && rightValue !== true) || (leftValue !== true && rightValue === true)) {
            return booleanToTypedValue(true);
        }
        if ((leftValue === true && rightValue === true) || (leftValue === false && rightValue === false)) {
            return booleanToTypedValue(false);
        }
        return [];
    }
}
class FunctionAtom {
    constructor(name, args) {
        this.name = name;
        this.args = args;
    }
    eval(context) {
        const impl = functions[this.name];
        if (!impl) {
            throw new Error('Unrecognized function: ' + this.name);
        }
        return impl(context, ...this.args);
    }
    toString() {
        return `${this.name}(${this.args.map((arg) => arg.toString()).join(', ')})`;
    }
}
class IndexerAtom {
    constructor(left, expr) {
        this.left = left;
        this.expr = expr;
    }
    eval(context) {
        const evalResult = this.expr.eval(context);
        if (evalResult.length !== 1) {
            return [];
        }
        const index = evalResult[0].value;
        if (typeof index !== 'number') {
            throw new Error(`Invalid indexer expression: should return integer}`);
        }
        const leftResult = this.left.eval(context);
        if (!(index in leftResult)) {
            return [];
        }
        return [leftResult[index]];
    }
    toString() {
        return `${this.left.toString()}[${this.expr.toString()}]`;
    }
}

export { AndAtom, ArithemticOperatorAtom, AsAtom, ConcatAtom, ContainsAtom, DotAtom, EmptySetAtom, EqualsAtom, EquivalentAtom, FhirPathAtom, FunctionAtom, InAtom, IndexerAtom, IsAtom, LiteralAtom, NotEqualsAtom, NotEquivalentAtom, OrAtom, SymbolAtom, UnaryOperatorAtom, UnionAtom, XorAtom };
//# sourceMappingURL=atoms.mjs.map
