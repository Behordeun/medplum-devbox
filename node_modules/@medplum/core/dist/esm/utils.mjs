import { formatHumanName } from './format.mjs';

/**
 * Creates a reference resource.
 * @param resource The FHIR reesource.
 * @returns A reference resource.
 */
function createReference(resource) {
    const reference = getReferenceString(resource);
    const display = getDisplayString(resource);
    return display === reference ? { reference } : { reference, display };
}
/**
 * Returns a reference string for a resource.
 * @param resource The FHIR resource.
 * @returns A reference string of the form resourceType/id.
 */
function getReferenceString(resource) {
    return resource.resourceType + '/' + resource.id;
}
/**
 * Returns the ID portion of a reference.
 * @param reference A FHIR reference.
 * @returns The ID portion of a reference.
 */
function resolveId(reference) {
    return reference?.reference?.split('/')[1];
}
/**
 * Returns true if the resource is a "ProfileResource".
 * @param resource The FHIR resource.
 * @returns True if the resource is a "ProfileResource".
 */
function isProfileResource(resource) {
    return (resource.resourceType === 'Patient' ||
        resource.resourceType === 'Practitioner' ||
        resource.resourceType === 'RelatedPerson');
}
/**
 * Returns a display string for the resource.
 * @param resource The input resource.
 * @return Human friendly display string.
 */
function getDisplayString(resource) {
    if (isProfileResource(resource)) {
        const profileName = getProfileResourceDisplayString(resource);
        if (profileName) {
            return profileName;
        }
    }
    if (resource.resourceType === 'Device') {
        const deviceName = getDeviceDisplayString(resource);
        if (deviceName) {
            return deviceName;
        }
    }
    if (resource.resourceType === 'Observation') {
        if ('code' in resource && resource.code?.text) {
            return resource.code.text;
        }
    }
    if (resource.resourceType === 'User') {
        if (resource.email) {
            return resource.email;
        }
    }
    if ('name' in resource && resource.name && typeof resource.name === 'string') {
        return resource.name;
    }
    return getReferenceString(resource);
}
/**
 * Returns a display string for a profile resource if one is found.
 * @param resource The profile resource.
 * @returns The display name if one is found.
 */
function getProfileResourceDisplayString(resource) {
    const names = resource.name;
    if (names && names.length > 0) {
        return formatHumanName(names[0]);
    }
    return undefined;
}
/**
 * Returns a display string for a device resource if one is found.
 * @param device The device resource.
 * @returns The display name if one is found.
 */
function getDeviceDisplayString(device) {
    const names = device.deviceName;
    if (names && names.length > 0) {
        return names[0].name;
    }
    return undefined;
}
/**
 * Returns an image URL for the resource, if one is available.
 * @param resource The input resource.
 * @returns The image URL for the resource or undefined.
 */
function getImageSrc(resource) {
    if (!('photo' in resource)) {
        return undefined;
    }
    const photo = resource.photo;
    if (!photo) {
        return undefined;
    }
    if (Array.isArray(photo)) {
        for (const p of photo) {
            const url = getPhotoImageSrc(p);
            if (url) {
                return url;
            }
        }
    }
    else {
        return getPhotoImageSrc(photo);
    }
    return undefined;
}
function getPhotoImageSrc(photo) {
    if (photo.url && photo.contentType && photo.contentType.startsWith('image/')) {
        return photo.url;
    }
    return undefined;
}
/**
 * Returns a Date property as a Date.
 * When working with JSON objects, Dates are often serialized as ISO-8601 strings.
 * When that happens, we need to safely convert to a proper Date object.
 * @param date The date property value, which could be a string or a Date object.
 * @returns A Date object.
 */
function getDateProperty(date) {
    return date ? new Date(date) : undefined;
}
/**
 * Calculates the age in years from the birth date.
 * @param birthDateStr The birth date or start date in ISO-8601 format YYYY-MM-DD.
 * @param endDateStr Optional end date in ISO-8601 format YYYY-MM-DD. Default value is today.
 * @returns The age in years, months, and days.
 */
function calculateAge(birthDateStr, endDateStr) {
    const startDate = new Date(birthDateStr);
    startDate.setUTCHours(0, 0, 0, 0);
    const endDate = endDateStr ? new Date(endDateStr) : new Date();
    endDate.setUTCHours(0, 0, 0, 0);
    const startYear = startDate.getUTCFullYear();
    const startMonth = startDate.getUTCMonth();
    const startDay = startDate.getUTCDate();
    const endYear = endDate.getUTCFullYear();
    const endMonth = endDate.getUTCMonth();
    const endDay = endDate.getUTCDate();
    let years = endYear - startYear;
    if (endMonth < startMonth || (endMonth === startMonth && endDay < startDay)) {
        years--;
    }
    let months = endYear * 12 + endMonth - (startYear * 12 + startMonth);
    if (endDay < startDay) {
        months--;
    }
    const days = Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));
    return { years, months, days };
}
/**
 * Calculates the age string for display using the age appropriate units.
 * If the age is greater than or equal to 2 years, then the age is displayed in years.
 * If the age is greater than or equal to 1 month, then the age is displayed in months.
 * Otherwise, the age is displayed in days.
 * @param birthDateStr The birth date or start date in ISO-8601 format YYYY-MM-DD.
 * @param endDateStr Optional end date in ISO-8601 format YYYY-MM-DD. Default value is today.
 * @returns The age string.
 */
function calculateAgeString(birthDateStr, endDateStr) {
    const { years, months, days } = calculateAge(birthDateStr, endDateStr);
    if (years >= 2) {
        return years.toString().padStart(3, '0') + 'Y';
    }
    else if (months >= 1) {
        return months.toString().padStart(3, '0') + 'M';
    }
    else {
        return days.toString().padStart(3, '0') + 'D';
    }
}
/**
 * Returns all questionnaire answers as a map by link ID.
 * @param response The questionnaire response resource.
 * @returns Questionnaire answers mapped by link ID.
 */
function getQuestionnaireAnswers(response) {
    const result = {};
    buildQuestionnaireAnswerItems(response.item, result);
    return result;
}
/**
 * Recursively builds the questionnaire answer items map.
 * @param item The current questionnaire response item.
 * @param result The cumulative result map.
 */
function buildQuestionnaireAnswerItems(items, result) {
    if (items) {
        for (const item of items) {
            if (item.linkId && item.answer && item.answer.length > 0) {
                result[item.linkId] = item.answer[0];
            }
            buildQuestionnaireAnswerItems(item.item, result);
        }
    }
}
/**
 * Returns the resource identifier for the given system.
 *
 * If multiple identifiers exist with the same system, the first one is returned.
 *
 * If the system is not found, then returns undefined.
 *
 * @param resource The resource to check.
 * @param system The identifier system.
 * @returns The identifier value if found; otherwise undefined.
 */
function getIdentifier(resource, system) {
    const identifiers = resource.identifier;
    if (!identifiers) {
        return undefined;
    }
    const array = Array.isArray(identifiers) ? identifiers : [identifiers];
    for (const identifier of array) {
        if (identifier.system === system) {
            return identifier.value;
        }
    }
    return undefined;
}
/**
 * Returns an extension value by extension URLs.
 * @param resource The base resource.
 * @param urls Array of extension URLs.  Each entry represents a nested extension.
 * @returns The extension value if found; undefined otherwise.
 */
function getExtensionValue(resource, ...urls) {
    // Let curr be the current resource or extension. Extensions can be nested.
    let curr = resource;
    // For each of the urls, try to find a matching nested extension.
    for (let i = 0; i < urls.length && curr; i++) {
        curr = curr?.extension?.find((e) => e.url === urls[i]);
    }
    return curr?.valueString;
}
/**
 * FHIR JSON stringify.
 * Removes properties with empty string values.
 * Removes objects with zero properties.
 * See: https://www.hl7.org/fhir/json.html
 * @param value The input value.
 * @param pretty Optional flag to pretty-print the JSON.
 * @returns The resulting JSON string.
 */
function stringify(value, pretty) {
    return JSON.stringify(value, stringifyReplacer, pretty ? 2 : undefined);
}
/**
 * Evaluates JSON key/value pairs for FHIR JSON stringify.
 * Removes properties with empty string values.
 * Removes objects with zero properties.
 * @param {string} k Property key.
 * @param {*} v Property value.
 */
function stringifyReplacer(k, v) {
    return !isArrayKey(k) && isEmpty(v) ? undefined : v;
}
/**
 * Returns true if the key is an array key.
 * @param k The property key.
 * @returns True if the key is an array key.
 */
function isArrayKey(k) {
    return !!k.match(/\d+$/);
}
/**
 * Returns true if the value is empty (null, undefined, empty string, or empty object).
 * @param v Any value.
 * @returns True if the value is an empty string or an empty object.
 */
function isEmpty(v) {
    if (v === null || v === undefined) {
        return true;
    }
    const t = typeof v;
    return (t === 'string' && v === '') || (t === 'object' && Object.keys(v).length === 0);
}
/**
 * Resource equality.
 * Ignores meta.versionId and meta.lastUpdated.
 * @param object1 The first object.
 * @param object2 The second object.
 * @returns True if the objects are equal.
 */
function deepEquals(object1, object2, path) {
    if (object1 === object2) {
        return true;
    }
    if (isEmpty(object1) && isEmpty(object2)) {
        return true;
    }
    if (isEmpty(object1) || isEmpty(object2)) {
        return false;
    }
    if (Array.isArray(object1) && Array.isArray(object2)) {
        return deepEqualsArray(object1, object2);
    }
    if (Array.isArray(object1) || Array.isArray(object2)) {
        return false;
    }
    if (isObject(object1) && isObject(object2)) {
        return deepEqualsObject(object1, object2, path);
    }
    if (isObject(object1) || isObject(object2)) {
        return false;
    }
    return false;
}
function deepEqualsArray(array1, array2) {
    if (array1.length !== array2.length) {
        return false;
    }
    for (let i = 0; i < array1.length; i++) {
        if (!deepEquals(array1[i], array2[i])) {
            return false;
        }
    }
    return true;
}
function deepEqualsObject(object1, object2, path) {
    const keySet = new Set();
    Object.keys(object1).forEach((k) => keySet.add(k));
    Object.keys(object2).forEach((k) => keySet.add(k));
    if (path === 'meta') {
        keySet.delete('versionId');
        keySet.delete('lastUpdated');
        keySet.delete('author');
    }
    for (const key of keySet) {
        const val1 = object1[key];
        const val2 = object2[key];
        if (!deepEquals(val1, val2, key)) {
            return false;
        }
    }
    return true;
}
/**
 * Creates a deep clone of the input value.
 *
 * Limitations:
 *  - Only supports JSON primitives and arrays.
 *  - Does not support Functions, lambdas, etc.
 *  - Does not support circular references.
 *
 * See: https://web.dev/structured-clone/
 * See: https://stackoverflow.com/questions/40488190/how-is-structured-clone-algorithm-different-from-deep-copy
 *
 * @param input The input to clone.
 * @returns A deep clone of the input.
 */
function deepClone(input) {
    return JSON.parse(JSON.stringify(input));
}
/**
 * Returns true if the input string is a UUID.
 * @param input The input string.
 * @returns True if the input string matches the UUID format.
 */
function isUUID(input) {
    return !!input.match(/^\w{8}-\w{4}-\w{4}-\w{4}-\w{12}$/i);
}
/**
 * Returns true if the input is an object.
 * @param object The candidate object.
 * @returns True if the input is a non-null non-undefined object.
 */
function isObject(obj) {
    return obj !== null && typeof obj === 'object';
}
/**
 * Returns true if the input array is an array of strings.
 * @param arr Input array.
 * @returns True if the input array is an array of strings.
 */
function isStringArray(arr) {
    return arr.every((e) => typeof e === 'string');
}
// Precompute hex octets
// See: https://stackoverflow.com/a/55200387
const byteToHex = [];
for (let n = 0; n < 256; n++) {
    byteToHex.push(n.toString(16).padStart(2, '0'));
}
/**
 * Converts an ArrayBuffer to hex string.
 * See: https://stackoverflow.com/a/55200387
 * @param arrayBuffer The input array buffer.
 * @returns The resulting hex string.
 */
function arrayBufferToHex(arrayBuffer) {
    const bytes = new Uint8Array(arrayBuffer);
    const result = new Array(bytes.length);
    for (let i = 0; i < bytes.length; i++) {
        result[i] = byteToHex[bytes[i]];
    }
    return result.join('');
}
/**
 * Converts an ArrayBuffer to a base-64 encoded string.
 * @param arrayBuffer The input array buffer.
 * @returns The base-64 encoded string.
 */
function arrayBufferToBase64(arrayBuffer) {
    const bytes = new Uint8Array(arrayBuffer);
    const result = [];
    for (let i = 0; i < bytes.length; i++) {
        result[i] = String.fromCharCode(bytes[i]);
    }
    return window.btoa(result.join(''));
}
function capitalize(word) {
    return word.charAt(0).toUpperCase() + word.substring(1);
}
function isLowerCase(c) {
    return c === c.toLowerCase() && c !== c.toUpperCase();
}
/**
 * Tries to find a code string for a given system within a given codeable concept.
 * @param concept The codeable concept.
 * @param system The system string.
 * @returns The code if found; otherwise undefined.
 */
function getCodeBySystem(concept, system) {
    return concept?.coding?.find((coding) => coding.system === system)?.code;
}
/**
 * Sets a code for a given system within a given codeable concept.
 * @param concept The codeable concept.
 * @param system The system string.
 * @param code The code value.
 */
function setCodeBySystem(concept, system, code) {
    if (!concept.coding) {
        concept.coding = [];
    }
    const coding = concept.coding?.find((c) => c.system === system);
    if (coding) {
        coding.code = code;
    }
    else {
        concept.coding?.push({ system, code });
    }
}
/**
 * Tries to find an observation interval for the given patient and value.
 * @param definition The observation definition.
 * @param patient The patient.
 * @param value The observation value.
 * @returns The observation interval if found; otherwise undefined.
 */
function findObservationInterval(definition, patient, value, category) {
    return definition.qualifiedInterval?.find((interval) => observationIntervalMatchesPatient(interval, patient) &&
        observationIntervalMatchesValue(interval, value, definition.quantitativeDetails?.decimalPrecision) &&
        (category === undefined || interval.category === category));
}
/**
 * Tries to find an observation reference range for the given patient and condition names.
 * @param definition The observation definition.
 * @param patient The patient.
 * @param names The condition names.
 * @returns The observation interval if found; otherwise undefined.
 */
function findObservationReferenceRange(definition, patient, names) {
    return definition.qualifiedInterval?.find((interval) => observationIntervalMatchesPatient(interval, patient) && names.includes(interval.condition));
}
/**
 * Returns true if the patient matches the observation interval.
 * @param interval The observation interval.
 * @param patient The patient.
 * @returns True if the patient matches the observation interval.
 */
function observationIntervalMatchesPatient(interval, patient) {
    return observationIntervalMatchesGender(interval, patient) && observationIntervalMatchesAge(interval, patient);
}
/**
 * Returns true if the patient gender matches the observation interval.
 * @param interval The observation interval.
 * @param patient The patient.
 * @returns True if the patient gender matches the observation interval.
 */
function observationIntervalMatchesGender(interval, patient) {
    return !interval.gender || interval.gender === patient.gender;
}
/**
 * Returns true if the patient age matches the observation interval.
 * @param interval The observation interval.
 * @param patient The patient.
 * @returns True if the patient age matches the observation interval.
 */
function observationIntervalMatchesAge(interval, patient) {
    return !interval.age || matchesRange(calculateAge(patient.birthDate).years, interval.age);
}
/**
 * Returns true if the value matches the observation interval.
 * @param interval The observation interval.
 * @param value The observation value.
 * @param precision Optional precision in number of digits.
 * @returns True if the value matches the observation interval.
 */
function observationIntervalMatchesValue(interval, value, precision) {
    return !!interval.range && matchesRange(value, interval.range, precision);
}
/**
 * Returns true if the value is in the range accounting for precision.
 * @param value The numeric value.
 * @param range The numeric range.
 * @param precision Optional precision in number of digits.
 * @returns True if the value is within the range.
 */
function matchesRange(value, range, precision) {
    return ((range.low?.value === undefined || preciseGreaterThanOrEquals(value, range.low.value, precision)) &&
        (range.high?.value === undefined || preciseLessThanOrEquals(value, range.high.value, precision)));
}
/**
 * Returns the input number rounded to the specified number of digits.
 * @param a The input number.
 * @param precision The precision in number of digits.
 * @returns The number rounded to the specified number of digits.
 */
function preciseRound(a, precision) {
    return parseFloat(a.toFixed(precision));
}
/**
 * Returns true if the two numbers are equal to the given precision.
 * @param a The first number.
 * @param b The second number.
 * @param precision Optional precision in number of digits.
 * @returns True if the two numbers are equal to the given precision.
 */
function preciseEquals(a, b, precision) {
    return toPreciseInteger(a, precision) === toPreciseInteger(b, precision);
}
/**
 * Returns true if the first number is less than the second number to the given precision.
 * @param a The first number.
 * @param b The second number.
 * @param precision Optional precision in number of digits.
 * @returns True if the first number is less than the second number to the given precision.
 */
function preciseLessThan(a, b, precision) {
    return toPreciseInteger(a, precision) < toPreciseInteger(b, precision);
}
/**
 * Returns true if the first number is greater than the second number to the given precision.
 * @param a The first number.
 * @param b The second number.
 * @param precision Optional precision in number of digits.
 * @returns True if the first number is greater than the second number to the given precision.
 */
function preciseGreaterThan(a, b, precision) {
    return toPreciseInteger(a, precision) > toPreciseInteger(b, precision);
}
/**
 * Returns true if the first number is less than or equal to the second number to the given precision.
 * @param a The first number.
 * @param b The second number.
 * @param precision Optional precision in number of digits.
 * @returns True if the first number is less than or equal to the second number to the given precision.
 */
function preciseLessThanOrEquals(a, b, precision) {
    return toPreciseInteger(a, precision) <= toPreciseInteger(b, precision);
}
/**
 * Returns true if the first number is greater than or equal to the second number to the given precision.
 * @param a The first number.
 * @param b The second number.
 * @param precision Optional precision in number of digits.
 * @returns True if the first number is greater than or equal to the second number to the given precision.
 */
function preciseGreaterThanOrEquals(a, b, precision) {
    return toPreciseInteger(a, precision) >= toPreciseInteger(b, precision);
}
/**
 * Returns an integer representation of the number with the given precision.
 * For example, if precision is 2, then 1.2345 will be returned as 123.
 * @param a The number.
 * @param precision Optional precision in number of digits.
 * @returns The integer with the given precision.
 */
function toPreciseInteger(a, precision) {
    if (precision === undefined) {
        return a;
    }
    return Math.round(a * Math.pow(10, precision));
}

export { arrayBufferToBase64, arrayBufferToHex, calculateAge, calculateAgeString, capitalize, createReference, deepClone, deepEquals, findObservationInterval, findObservationReferenceRange, getCodeBySystem, getDateProperty, getDisplayString, getExtensionValue, getIdentifier, getImageSrc, getQuestionnaireAnswers, getReferenceString, isEmpty, isLowerCase, isObject, isProfileResource, isStringArray, isUUID, matchesRange, preciseEquals, preciseGreaterThan, preciseGreaterThanOrEquals, preciseLessThan, preciseLessThanOrEquals, preciseRound, resolveId, setCodeBySystem, stringify };
//# sourceMappingURL=utils.mjs.map
