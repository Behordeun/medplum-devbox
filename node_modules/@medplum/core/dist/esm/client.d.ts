import { Binary, Bundle, Communication, ExtractResource, OperationOutcome, Project, ProjectMembership, ProjectSecret, Reference, Resource, ResourceType, UserConfiguration, ValueSet } from '@medplum/fhirtypes';
/** @ts-ignore */
import type { CustomTableLayout, TDocumentDefinitions, TFontDictionary } from 'pdfmake/interfaces';
import { EventTarget } from './eventtarget';
import { Hl7Message } from './hl7';
import { ReadablePromise } from './readablepromise';
import { IndexedStructureDefinition } from './types';
import { ProfileResource } from './utils';
export declare const MEDPLUM_VERSION: string | undefined;
/**
 * The MedplumClientOptions interface defines configuration options for MedplumClient.
 *
 * All configuration settings are optional.
 */
export interface MedplumClientOptions {
    /**
     * Base server URL.
     *
     * Default value is https://api.medplum.com/
     *
     * Use this to point to a custom Medplum deployment.
     */
    baseUrl?: string;
    /**
     * OAuth2 authorize URL.
     *
     * Default value is baseUrl + "/oauth2/authorize".
     *
     * Use this if you want to use a separate OAuth server.
     */
    authorizeUrl?: string;
    /**
     * OAuth2 token URL.
     *
     * Default value is baseUrl + "/oauth2/token".
     *
     * Use this if you want to use a separate OAuth server.
     */
    tokenUrl?: string;
    /**
     * OAuth2 logout URL.
     *
     * Default value is baseUrl + "/oauth2/logout".
     *
     * Use this if you want to use a separate OAuth server.
     */
    logoutUrl?: string;
    /**
     * The client ID.
     *
     * Client ID can be used for SMART-on-FHIR customization.
     */
    clientId?: string;
    /**
     * Number of resources to store in the cache.
     *
     * Default value is 1000.
     *
     * Consider using this for performance of displaying Patient or Practitioner resources.
     */
    resourceCacheSize?: number;
    /**
     * The length of time in milliseconds to cache resources.
     *
     * Default value is 10000 (10 seconds).
     *
     * Cache time of zero disables all caching.
     *
     * For any individual request, the cache behavior can be overridden by setting the cache property on request options.
     *
     * See: https://developer.mozilla.org/en-US/docs/Web/API/Request/cache
     */
    cacheTime?: number;
    /**
     * Fetch implementation.
     *
     * Default is window.fetch (if available).
     *
     * For nodejs applications, consider the 'node-fetch' package.
     */
    fetch?: FetchLike;
    /**
     * Create PDF implementation.
     *
     * Default is none, and PDF generation is disabled.
     *
     * In browser environments, import the client-side pdfmake library.
     *
     * ```html
     * <script src="pdfmake.min.js"></script>
     * <script>
     * async function createPdf(docDefinition, tableLayouts, fonts) {
     *   return new Promise((resolve) => {
     *     pdfMake.createPdf(docDefinition, tableLayouts, fonts).getBlob(resolve);
     *   });
     * }
     * </script>
     * ```
     *
     * In nodejs applications:
     *
     * ```ts
     * import type { CustomTableLayout, TDocumentDefinitions, TFontDictionary } from 'pdfmake/interfaces';
     * function createPdf(
     *   docDefinition: TDocumentDefinitions,
     *   tableLayouts?: { [name: string]: CustomTableLayout },
     *   fonts?: TFontDictionary
     * ): Promise<Buffer> {
     *   return new Promise((resolve, reject) => {
     *     const printer = new PdfPrinter(fonts || {});
     *     const pdfDoc = printer.createPdfKitDocument(docDefinition, { tableLayouts });
     *     const chunks: Uint8Array[] = [];
     *     pdfDoc.on('data', (chunk: Uint8Array) => chunks.push(chunk));
     *     pdfDoc.on('end', () => resolve(Buffer.concat(chunks)));
     *     pdfDoc.on('error', reject);
     *     pdfDoc.end();
     *   });
     * }
     * ```
     */
    createPdf?: CreatePdfFunction;
    /**
     * Callback for when the client is unauthenticated.
     *
     * Default is do nothing.
     *
     * For client side applications, consider redirecting to a sign in page.
     */
    onUnauthenticated?: () => void;
}
export interface FetchLike {
    (url: string, options?: any): Promise<any>;
}
export interface CreatePdfFunction {
    (docDefinition: TDocumentDefinitions, tableLayouts?: {
        [name: string]: CustomTableLayout;
    } | undefined, fonts?: TFontDictionary | undefined): Promise<any>;
}
export interface BaseLoginRequest {
    readonly projectId?: string;
    readonly clientId?: string;
    readonly resourceType?: string;
    readonly scope?: string;
    readonly nonce?: string;
    readonly codeChallenge?: string;
    readonly codeChallengeMethod?: string;
    readonly googleClientId?: string;
    readonly launch?: string;
}
export interface EmailPasswordLoginRequest extends BaseLoginRequest {
    readonly email: string;
    readonly password: string;
    readonly remember?: boolean;
}
export interface NewUserRequest {
    readonly firstName: string;
    readonly lastName: string;
    readonly email: string;
    readonly password: string;
    readonly recaptchaToken: string;
    readonly recaptchaSiteKey?: string;
    readonly remember?: boolean;
    readonly projectId?: string;
}
export interface NewProjectRequest {
    readonly login: string;
    readonly projectName: string;
}
export interface NewPatientRequest {
    readonly login: string;
    readonly projectId: string;
}
export interface GoogleCredentialResponse {
    readonly clientId: string;
    readonly credential: string;
}
export interface GoogleLoginRequest extends BaseLoginRequest {
    readonly googleClientId: string;
    readonly googleCredential: string;
    readonly createUser?: boolean;
}
export interface LoginAuthenticationResponse {
    readonly login: string;
    readonly mfaRequired?: boolean;
    readonly code?: string;
    readonly memberships?: ProjectMembership[];
}
export interface LoginProfileResponse {
    readonly login: string;
    readonly scope: string;
}
export interface LoginScopeResponse {
    readonly login: string;
    readonly code: string;
}
export interface LoginState {
    readonly project: Reference<Project>;
    readonly profile: Reference<ProfileResource>;
    readonly accessToken: string;
    readonly refreshToken: string;
}
export interface TokenResponse {
    readonly token_type: string;
    readonly id_token: string;
    readonly access_token: string;
    readonly refresh_token: string;
    readonly expires_in: number;
    readonly project: Reference<Project>;
    readonly profile: Reference<ProfileResource>;
}
export interface BotEvent<T = Resource | Hl7Message | string | Record<string, any>> {
    readonly contentType: string;
    readonly input: T;
    readonly secrets: Record<string, ProjectSecret>;
}
/**
 * JSONPatch patch operation.
 * Compatible with fast-json-patch Operation.
 */
export interface PatchOperation {
    readonly op: 'add' | 'remove' | 'replace' | 'copy' | 'move' | 'test';
    readonly path: string;
    readonly value?: any;
}
/**
 * Email address definition.
 * Compatible with nodemailer Mail.Address.
 */
export interface MailAddress {
    readonly name: string;
    readonly address: string;
}
/**
 * Email attachment definition.
 * Compatible with nodemailer Mail.Options.
 */
export interface MailAttachment {
    /** String, Buffer or a Stream contents for the attachmentent */
    readonly content?: string;
    /** path to a file or an URL (data uris are allowed as well) if you want to stream the file instead of including it (better for larger attachments) */
    readonly path?: string;
    /** filename to be reported as the name of the attached file, use of unicode is allowed. If you do not want to use a filename, set this value as false, otherwise a filename is generated automatically */
    readonly filename?: string | false;
    /** optional content type for the attachment, if not set will be derived from the filename property */
    readonly contentType?: string;
}
/**
 * Email message definition.
 * Compatible with nodemailer Mail.Options.
 */
export interface MailOptions {
    /** The e-mail address of the sender. All e-mail addresses can be plain 'sender@server.com' or formatted 'Sender Name <sender@server.com>' */
    readonly from?: string | MailAddress;
    /** An e-mail address that will appear on the Sender: field */
    readonly sender?: string | MailAddress;
    /** Comma separated list or an array of recipients e-mail addresses that will appear on the To: field */
    readonly to?: string | MailAddress | string[] | MailAddress[];
    /** Comma separated list or an array of recipients e-mail addresses that will appear on the Cc: field */
    readonly cc?: string | MailAddress | string[] | MailAddress[];
    /** Comma separated list or an array of recipients e-mail addresses that will appear on the Bcc: field */
    readonly bcc?: string | MailAddress | string[] | MailAddress[];
    /** An e-mail address that will appear on the Reply-To: field */
    readonly replyTo?: string | MailAddress;
    /** The subject of the e-mail */
    readonly subject?: string;
    /** The plaintext version of the message */
    readonly text?: string;
    /** The HTML version of the message */
    readonly html?: string;
    /** An array of attachment objects */
    readonly attachments?: MailAttachment[];
}
/**
 * The MedplumClient class provides a client for the Medplum FHIR server.
 *
 * The client can be used in the browser, in a NodeJS application, or in a Medplum Bot.
 *
 * The client provides helpful methods for common operations such as:
 *   1) Authenticating
 *   2) Creating resources
 *   2) Reading resources
 *   3) Updating resources
 *   5) Deleting resources
 *   6) Searching
 *   7) Making GraphQL queries
 *
 * Here is a quick example of how to use the client:
 *
 * ```typescript
 * import { MedplumClient } from '@medplum/core';
 * const medplum = new MedplumClient();
 * ```
 *
 * Create a `Patient`:
 *
 * ```typescript
 * const patient = await medplum.createResource({
 *   resourceType: 'Patient',
 *   name: [{
 *     given: ['Alice'],
 *     family: 'Smith'
 *   }]
 * });
 * ```
 *
 * Read a `Patient` by ID:
 *
 * ```typescript
 * const patient = await medplum.readResource('Patient', '123');
 * console.log(patient.name[0].given[0]);
 * ```
 *
 * Search for a `Patient` by name:
 *
 * ```typescript
 * const bundle = await medplum.search('Patient', 'name=Alice');
 * console.log(bundle.total);
 * ```
 *
 *  <head>
 *    <meta name="algolia:pageRank" content="100" />
 *  </head>

 */
export declare class MedplumClient extends EventTarget {
    #private;
    constructor(options?: MedplumClientOptions);
    /**
     * Returns the current base URL for all API requests.
     * By default, this is set to `https://api.medplum.com/`.
     * This can be overridden by setting the `baseUrl` option when creating the client.
     * @category HTTP
     * @returns The current base URL for all API requests.
     */
    getBaseUrl(): string;
    /**
     * Clears all auth state including local storage and session storage.
     * @category Authentication
     */
    clear(): void;
    /**
     * Invalidates any cached values or cached requests for the given URL.
     * @category Caching
     * @param url The URL to invalidate.
     */
    invalidateUrl(url: URL | string): void;
    /**
     * Invalidates all cached search results or cached requests for the given resourceType.
     * @category Caching
     * @param resourceType The resource type to invalidate.
     */
    invalidateSearches<K extends ResourceType>(resourceType: K): void;
    /**
     * Makes an HTTP GET request to the specified URL.
     *
     * This is a lower level method for custom requests.
     * For common operations, we recommend using higher level methods
     * such as `readResource()`, `search()`, etc.
     *
     * @category HTTP
     * @param url The target URL.
     * @param options Optional fetch options.
     * @returns Promise to the response content.
     */
    get<T = any>(url: URL | string, options?: RequestInit): ReadablePromise<T>;
    /**
     * Makes an HTTP POST request to the specified URL.
     *
     * This is a lower level method for custom requests.
     * For common operations, we recommend using higher level methods
     * such as `createResource()`.
     *
     * @category HTTP
     * @param url The target URL.
     * @param body The content body. Strings and `File` objects are passed directly. Other objects are converted to JSON.
     * @param contentType The content type to be included in the "Content-Type" header.
     * @param options Optional fetch options.
     * @returns Promise to the response content.
     */
    post(url: URL | string, body: any, contentType?: string, options?: RequestInit): Promise<any>;
    /**
     * Makes an HTTP PUT request to the specified URL.
     *
     * This is a lower level method for custom requests.
     * For common operations, we recommend using higher level methods
     * such as `updateResource()`.
     *
     * @category HTTP
     * @param url The target URL.
     * @param body The content body. Strings and `File` objects are passed directly. Other objects are converted to JSON.
     * @param contentType The content type to be included in the "Content-Type" header.
     * @param options Optional fetch options.
     * @returns Promise to the response content.
     */
    put(url: URL | string, body: any, contentType?: string, options?: RequestInit): Promise<any>;
    /**
     * Makes an HTTP PATCH request to the specified URL.
     *
     * This is a lower level method for custom requests.
     * For common operations, we recommend using higher level methods
     * such as `patchResource()`.
     *
     * @category HTTP
     * @param url The target URL.
     * @param operations Array of JSONPatch operations.
     * @param options Optional fetch options.
     * @returns Promise to the response content.
     */
    patch(url: URL | string, operations: PatchOperation[], options?: RequestInit): Promise<any>;
    /**
     * Makes an HTTP DELETE request to the specified URL.
     *
     *
     * This is a lower level method for custom requests.
     * For common operations, we recommend using higher level methods
     * such as `deleteResource()`.
     *
     * @category HTTP
     * @param url The target URL.
     * @param options Optional fetch options.
     * @returns Promise to the response content.
     */
    delete(url: URL | string, options?: RequestInit): Promise<any>;
    /**
     * Initiates a new user flow.
     *
     * This method is part of the two different user registration flows:
     * 1) New Practitioner and new Project
     * 2) New Patient registration
     *
     * @category Authentication
     * @param newUserRequest Register request including email and password.
     * @returns Promise to the authentication response.
     */
    startNewUser(newUserRequest: NewUserRequest): Promise<LoginAuthenticationResponse>;
    /**
     * Initiates a new project flow.
     *
     * This requires a partial login from `startNewUser` or `startNewGoogleUser`.
     *
     * @param newProjectRequest Register request including email and password.
     * @returns Promise to the authentication response.
     */
    startNewProject(newProjectRequest: NewProjectRequest): Promise<LoginAuthenticationResponse>;
    /**
     * Initiates a new patient flow.
     *
     * This requires a partial login from `startNewUser` or `startNewGoogleUser`.
     *
     * @param newPatientRequest Register request including email and password.
     * @returns Promise to the authentication response.
     */
    startNewPatient(newPatientRequest: NewPatientRequest): Promise<LoginAuthenticationResponse>;
    /**
     * Initiates a user login flow.
     * @category Authentication
     * @param loginRequest Login request including email and password.
     * @returns Promise to the authentication response.
     */
    startLogin(loginRequest: EmailPasswordLoginRequest): Promise<LoginAuthenticationResponse>;
    /**
     * Tries to sign in with Google authentication.
     * The response parameter is the result of a Google authentication.
     * See: https://developers.google.com/identity/gsi/web/guides/handle-credential-responses-js-functions
     * @category Authentication
     * @param loginRequest Login request including Google credential response.
     * @returns Promise to the authentication response.
     */
    startGoogleLogin(loginRequest: GoogleLoginRequest): Promise<LoginAuthenticationResponse>;
    getCodeChallenge(loginRequest: BaseLoginRequest): {
        codeChallenge?: string;
        codeChallengeMethod?: string;
    };
    /**
     * Signs out locally.
     * Does not invalidate tokens with the server.
     * @category Authentication
     */
    signOut(): void;
    /**
     * Tries to sign in the user.
     * Returns true if the user is signed in.
     * This may result in navigating away to the sign in page.
     * @category Authentication
     */
    signInWithRedirect(): Promise<ProfileResource | void>;
    /**
     * Tries to sign out the user.
     * See: https://docs.aws.amazon.com/cognito/latest/developerguide/logout-endpoint.html
     * @category Authentication
     */
    signOutWithRedirect(): void;
    /**
     * Builds a FHIR URL from a collection of URL path components.
     * For example, `buildUrl('/Patient', '123')` returns `fhir/R4/Patient/123`.
     * @category HTTP
     * @param path The path component of the URL.
     * @returns The well-formed FHIR URL.
     */
    fhirUrl(...path: string[]): URL;
    /**
     * Builds a FHIR search URL from a search query or structured query object.
     * @category HTTP
     * @category Search
     * @param query The FHIR search query or structured query object.
     * @returns The well-formed FHIR URL.
     */
    fhirSearchUrl(resourceType: ResourceType, query: URLSearchParams | string | undefined): URL;
    /**
     * Sends a FHIR search request.
     *
     * Example using a FHIR search string:
     *
     * ```typescript
     * const bundle = await client.search('Patient', 'name=Alice');
     * console.log(bundle);
     * ```
     *
     * The return value is a FHIR bundle:
     *
     * ```json
     * {
     *    "resourceType": "Bundle",
     *    "type": "searchset",
     *    "entry": [
     *       {
     *          "resource": {
     *             "resourceType": "Patient",
     *             "name": [
     *                {
     *                   "given": [
     *                      "George"
     *                   ],
     *                   "family": "Washington"
     *                }
     *             ],
     *          }
     *       }
     *    ]
     * }
     * ```
     *
     * To query the count of a search, use the summary feature like so:
     *
     * ```typescript
     * const patients = medplum.search('Patient', '_summary=count');
     * ```
     *
     * See FHIR search for full details: https://www.hl7.org/fhir/search.html
     *
     * @category Search
     * @param resourceType The FHIR resource type.
     * @param query The search query as either a string or a structured search object.
     * @param options Optional fetch options.
     * @returns Promise to the search result bundle.
     */
    search<K extends ResourceType>(resourceType: K, query?: URLSearchParams | string, options?: RequestInit): ReadablePromise<Bundle<ExtractResource<K>>>;
    /**
     * Sends a FHIR search request for a single resource.
     *
     * This is a convenience method for `search()` that returns the first resource rather than a `Bundle`.
     *
     * Example using a FHIR search string:
     *
     * ```typescript
     * const patient = await client.searchOne('Patient', 'identifier=123');
     * console.log(patient);
     * ```
     *
     * The return value is the resource, if available; otherwise, undefined.
     *
     * See FHIR search for full details: https://www.hl7.org/fhir/search.html
     *
     * @category Search
     * @param resourceType The FHIR resource type.
     * @param query The search query as either a string or a structured search object.
     * @param options Optional fetch options.
     * @returns Promise to the search result bundle.
     */
    searchOne<K extends ResourceType>(resourceType: K, query?: URLSearchParams | string, options?: RequestInit): ReadablePromise<ExtractResource<K> | undefined>;
    /**
     * Sends a FHIR search request for an array of resources.
     *
     * This is a convenience method for `search()` that returns the resources as an array rather than a `Bundle`.
     *
     * Example using a FHIR search string:
     *
     * ```typescript
     * const patients = await client.searchResources('Patient', 'name=Alice');
     * console.log(patients);
     * ```
     *
     * The return value is an array of resources.
     *
     * See FHIR search for full details: https://www.hl7.org/fhir/search.html
     *
     * @category Search
     * @param resourceType The FHIR resource type.
     * @param query The search query as either a string or a structured search object.
     * @param options Optional fetch options.
     * @returns Promise to the search result bundle.
     */
    searchResources<K extends ResourceType>(resourceType: K, query?: URLSearchParams | string, options?: RequestInit): ReadablePromise<ExtractResource<K>[]>;
    /**
     * Searches a ValueSet resource using the "expand" operation.
     * See: https://www.hl7.org/fhir/operation-valueset-expand.html
     *
     * @category Search
     * @param system The ValueSet system url.
     * @param filter The search string.
     * @param options Optional fetch options.
     * @returns Promise to expanded ValueSet.
     */
    searchValueSet(system: string, filter: string, options?: RequestInit): ReadablePromise<ValueSet>;
    /**
     * Returns a cached resource if it is available.
     * @category Caching
     * @param resourceType The FHIR resource type.
     * @param id The FHIR resource ID.
     * @returns The resource if it is available in the cache; undefined otherwise.
     */
    getCached<K extends ResourceType>(resourceType: K, id: string): ExtractResource<K> | undefined;
    /**
     * Returns a cached resource if it is available.
     * @category Caching
     * @param resourceType The FHIR resource type.
     * @param id The FHIR resource ID.
     * @returns The resource if it is available in the cache; undefined otherwise.
     */
    getCachedReference<T extends Resource>(reference: Reference<T>): T | undefined;
    /**
     * Reads a resource by resource type and ID.
     *
     * Example:
     *
     * ```typescript
     * const patient = await medplum.readResource('Patient', '123');
     * console.log(patient);
     * ```
     *
     * See the FHIR "read" operation for full details: https://www.hl7.org/fhir/http.html#read
     *
     * @category Read
     * @param resourceType The FHIR resource type.
     * @param id The resource ID.
     * @param options Optional fetch options.
     * @returns The resource if available; undefined otherwise.
     */
    readResource<K extends ResourceType>(resourceType: K, id: string, options?: RequestInit): ReadablePromise<ExtractResource<K>>;
    /**
     * Reads a resource by `Reference`.
     *
     * This is a convenience method for `readResource()` that accepts a `Reference` object.
     *
     * Example:
     *
     * ```typescript
     * const serviceRequest = await medplum.readResource('ServiceRequest', '123');
     * const patient = await medplum.readReference(serviceRequest.subject);
     * console.log(patient);
     * ```
     *
     * See the FHIR "read" operation for full details: https://www.hl7.org/fhir/http.html#read
     *
     * @category Read
     * @param reference The FHIR reference object.
     * @param options Optional fetch options.
     * @returns The resource if available; undefined otherwise.
     */
    readReference<T extends Resource>(reference: Reference<T>, options?: RequestInit): ReadablePromise<T>;
    /**
     * Returns a cached schema for a resource type.
     * If the schema is not cached, returns undefined.
     * It is assumed that a client will call requestSchema before using this method.
     * @category Schema
     * @returns The schema if immediately available, undefined otherwise.
     * @deprecated Use globalSchema instead.
     */
    getSchema(): IndexedStructureDefinition;
    /**
     * Requests the schema for a resource type.
     * If the schema is already cached, the promise is resolved immediately.
     * @category Schema
     * @param resourceType The FHIR resource type.
     * @returns Promise to a schema with the requested resource type.
     */
    requestSchema(resourceType: string): Promise<IndexedStructureDefinition>;
    /**
     * Reads resource history by resource type and ID.
     *
     * The return value is a bundle of all versions of the resource.
     *
     * Example:
     *
     * ```typescript
     * const history = await medplum.readHistory('Patient', '123');
     * console.log(history);
     * ```
     *
     * See the FHIR "history" operation for full details: https://www.hl7.org/fhir/http.html#history
     *
     * @category Read
     * @param resourceType The FHIR resource type.
     * @param id The resource ID.
     * @param options Optional fetch options.
     * @returns Promise to the resource history.
     */
    readHistory<K extends ResourceType>(resourceType: K, id: string, options?: RequestInit): ReadablePromise<Bundle<ExtractResource<K>>>;
    /**
     * Reads a specific version of a resource by resource type, ID, and version ID.
     *
     * Example:
     *
     * ```typescript
     * const version = await medplum.readVersion('Patient', '123', '456');
     * console.log(version);
     * ```
     *
     * See the FHIR "vread" operation for full details: https://www.hl7.org/fhir/http.html#vread
     *
     * @category Read
     * @param resourceType The FHIR resource type.
     * @param id The resource ID.
     * @param vid The version ID.
     * @param options Optional fetch options.
     * @returns The resource if available; undefined otherwise.
     */
    readVersion<K extends ResourceType>(resourceType: K, id: string, vid: string, options?: RequestInit): ReadablePromise<ExtractResource<K>>;
    /**
     * Executes the Patient "everything" operation for a patient.
     *
     * Example:
     *
     * ```typescript
     * const bundle = await medplum.readPatientEverything('123');
     * console.log(bundle);
     * ```
     *
     * See the FHIR "patient-everything" operation for full details: https://hl7.org/fhir/operation-patient-everything.html
     *
     * @category Read
     * @param id The Patient Id
     * @param options Optional fetch options.
     * @returns A Bundle of all Resources related to the Patient
     */
    readPatientEverything(id: string, options?: RequestInit): ReadablePromise<Bundle>;
    /**
     * Creates a new FHIR resource.
     *
     * The return value is the newly created resource, including the ID and meta.
     *
     * Example:
     *
     * ```typescript
     * const result = await medplum.createResource({
     *   resourceType: 'Patient',
     *   name: [{
     *    family: 'Smith',
     *    given: ['John']
     *   }]
     * });
     * console.log(result.id);
     * ```
     *
     * See the FHIR "create" operation for full details: https://www.hl7.org/fhir/http.html#create
     *
     * @category Create
     * @param resource The FHIR resource to create.
     * @returns The result of the create operation.
     */
    createResource<T extends Resource>(resource: T): Promise<T>;
    /**
     * Conditionally create a new FHIR resource only if some equivalent resource does not already exist on the server.
     *
     * The return value is the existing resource or the newly created resource, including the ID and meta.
     *
     * Example:
     *
     * ```typescript
     * const result = await medplum.createResourceIfNoneExist(
     *   {
     *     resourceType: 'Patient',
     *     identifier: [{
     *      system: 'http://example.com/mrn',
     *      value: '123'
     *     }]
     *     name: [{
     *      family: 'Smith',
     *      given: ['John']
     *     }]
     *   },
     *   'identifier=123'
     * );
     * console.log(result.id);
     * ```
     *
     * This method is syntactic sugar for:
     *
     * ```typescript
     * return searchOne(resourceType, query) ?? createResource(resource);
     * ```
     *
     * The query parameter only contains the search parameters (what would be in the URL following the "?").
     *
     * See the FHIR "conditional create" operation for full details: https://www.hl7.org/fhir/http.html#ccreate
     *
     * @category Create
     * @param resource The FHIR resource to create.
     * @param query The search query for an equivalent resource (should not include resource type or "?").
     * @returns The result of the create operation.
     */
    createResourceIfNoneExist<T extends Resource>(resource: T, query: string): Promise<T>;
    /**
     * Creates a FHIR `Binary` resource with the provided data content.
     *
     * The return value is the newly created resource, including the ID and meta.
     *
     * The `data` parameter can be a string or a `File` object.
     *
     * A `File` object often comes from a `<input type="file">` element.
     *
     * Example:
     *
     * ```typescript
     * const result = await medplum.createBinary(myFile, 'test.jpg', 'image/jpeg');
     * console.log(result.id);
     * ```
     *
     * See the FHIR "create" operation for full details: https://www.hl7.org/fhir/http.html#create
     *
     * @category Create
     * @param data The binary data to upload.
     * @param filename Optional filename for the binary.
     * @param contentType Content type for the binary.
     * @returns The result of the create operation.
     */
    createBinary(data: string | File | Blob | Uint8Array, filename: string | undefined, contentType: string, onProgress?: (e: ProgressEvent) => void): Promise<Binary>;
    uploadwithProgress(url: URL, data: string | File | Blob | Uint8Array, contentType: string, onProgress: (e: ProgressEvent) => void): Promise<any>;
    /**
     * Creates a PDF as a FHIR `Binary` resource based on pdfmake document definition.
     *
     * The return value is the newly created resource, including the ID and meta.
     *
     * The `docDefinition` parameter is a pdfmake document definition.
     *
     * Example:
     *
     * ```typescript
     * const result = await medplum.createPdf({
     *   content: ['Hello world']
     * });
     * console.log(result.id);
     * ```
     *
     * See the pdfmake document definition for full details: https://pdfmake.github.io/docs/0.1/document-definition-object/
     *
     * @category Media
     * @param docDefinition The PDF document definition.
     * @returns The result of the create operation.
     */
    createPdf(docDefinition: TDocumentDefinitions, filename?: string, tableLayouts?: {
        [name: string]: CustomTableLayout;
    }, fonts?: TFontDictionary): Promise<Binary>;
    /**
     * Creates a FHIR `Communication` resource with the provided data content.
     *
     * This is a convenience method to handle commmon cases where a `Communication` resource is created with a `payload`.
     *
     * @category Create
     * @param resource The FHIR resource to comment on.
     * @param text The text of the comment.
     * @returns The result of the create operation.
     */
    createComment(resource: Resource, text: string): Promise<Communication>;
    /**
     * Updates a FHIR resource.
     *
     * The return value is the updated resource, including the ID and meta.
     *
     * Example:
     *
     * ```typescript
     * const result = await medplum.updateResource({
     *   resourceType: 'Patient',
     *   id: '123',
     *   name: [{
     *    family: 'Smith',
     *    given: ['John']
     *   }]
     * });
     * console.log(result.meta.versionId);
     * ```
     *
     * See the FHIR "update" operation for full details: https://www.hl7.org/fhir/http.html#update
     *
     * @category Write
     * @param resource The FHIR resource to update.
     * @returns The result of the update operation.
     */
    updateResource<T extends Resource>(resource: T): Promise<T>;
    /**
     * Updates a FHIR resource using JSONPatch operations.
     *
     * The return value is the updated resource, including the ID and meta.
     *
     * Example:
     *
     * ```typescript
     * const result = await medplum.patchResource('Patient', '123', [
     *   {op: 'replace', path: '/name/0/family', value: 'Smith'},
     * ]);
     * console.log(result.meta.versionId);
     * ```
     *
     * See the FHIR "update" operation for full details: https://www.hl7.org/fhir/http.html#patch
     *
     * See the JSONPatch specification for full details: https://tools.ietf.org/html/rfc6902
     *
     * @category Write
     * @param resourceType The FHIR resource type.
     * @param id The resource ID.
     * @param operations The JSONPatch operations.
     * @returns The result of the patch operations.
     */
    patchResource<K extends ResourceType>(resourceType: K, id: string, operations: PatchOperation[]): Promise<ExtractResource<K>>;
    /**
     * Deletes a FHIR resource by resource type and ID.
     *
     * Example:
     *
     * ```typescript
     * await medplum.deleteResource('Patient', '123');
     * ```
     *
     * See the FHIR "delete" operation for full details: https://www.hl7.org/fhir/http.html#delete
     *
     * @category Delete
     * @param resourceType The FHIR resource type.
     * @param id The resource ID.
     * @returns The result of the delete operation.
     */
    deleteResource(resourceType: ResourceType, id: string): Promise<any>;
    /**
     * Executes the validate operation with the provided resource.
     *
     * Example:
     *
     * ```typescript
     * const result = await medplum.validateResource({
     *   resourceType: 'Patient',
     *   name: [{ given: ['Alice'], family: 'Smith' }],
     * });
     * ```
     *
     * See the FHIR "$validate" operation for full details: https://www.hl7.org/fhir/resource-operation-validate.html
     *
     * @param resource The FHIR resource.
     * @returns The validate operation outcome.
     */
    validateResource<T extends Resource>(resource: T): Promise<OperationOutcome>;
    /**
     * Executes a batch or transaction of FHIR operations.
     *
     * Example:
     *
     * ```typescript
     * await medplum.executeBatch({
     *   "resourceType": "Bundle",
     *   "type": "transaction",
     *   "entry": [
     *     {
     *       "fullUrl": "urn:uuid:61ebe359-bfdc-4613-8bf2-c5e300945f0a",
     *       "resource": {
     *         "resourceType": "Patient",
     *         "name": [{ "use": "official", "given": ["Alice"], "family": "Smith" }],
     *         "gender": "female",
     *         "birthDate": "1974-12-25"
     *       },
     *       "request": {
     *         "method": "POST",
     *         "url": "Patient"
     *       }
     *     },
     *     {
     *       "fullUrl": "urn:uuid:88f151c0-a954-468a-88bd-5ae15c08e059",
     *       "resource": {
     *         "resourceType": "Patient",
     *         "identifier": [{ "system": "http:/example.org/fhir/ids", "value": "234234" }],
     *         "name": [{ "use": "official", "given": ["Bob"], "family": "Jones" }],
     *         "gender": "male",
     *         "birthDate": "1974-12-25"
     *       },
     *       "request": {
     *         "method": "POST",
     *         "url": "Patient",
     *         "ifNoneExist": "identifier=http:/example.org/fhir/ids|234234"
     *       }
     *     }
     *   ]
     * });
     * ```
     *
     * See The FHIR "batch/transaction" section for full details: https://hl7.org/fhir/http.html#transaction
     * @category Batch
     * @param bundle The FHIR batch/transaction bundle.
     * @returns The FHIR batch/transaction response bundle.
     */
    executeBatch(bundle: Bundle): Promise<Bundle>;
    /**
     * Sends an email using the Medplum Email API.
     *
     * Builds the email using nodemailer MailComposer.
     *
     * Examples:
     *
     * Send a simple text email:
     *
     * ```typescript
     * await medplum.sendEmail({
     *   to: 'alice@example.com',
     *   cc: 'bob@example.com',
     *   subject: 'Hello',
     *   text: 'Hello Alice',
     * });
     * ```
     *
     * Send an email with a `Binary` attachment:
     *
     * ```typescript
     * await medplum.sendEmail({
     *   to: 'alice@example.com',
     *   subject: 'Email with attachment',
     *   text: 'See the attached report',
     *   attachments: [{
     *     filename: 'report.pdf',
     *     path: "Binary/" + binary.id
     *   }]
     * });
     * ```
     *
     * See options here: https://nodemailer.com/extras/mailcomposer/
     * @category Media
     * @param options The MailComposer options.
     * @returns Promise to the operation outcome.
     */
    sendEmail(email: MailOptions): Promise<OperationOutcome>;
    /**
     * Executes a GraphQL query.
     *
     * Example:
     *
     * ```typescript
     * const result = await medplum.graphql(`{
     *   Patient(id: "123") {
     *     resourceType
     *     id
     *     name {
     *       given
     *       family
     *     }
     *   }
     * }`);
     * ```
     *
     * Advanced queries such as named operations and variable substitution are supported:
     *
     * ```typescript
     * const result = await medplum.graphql(
     *   `query GetPatientById($patientId: ID!) {
     *     Patient(id: $patientId) {
     *       resourceType
     *       id
     *       name {
     *         given
     *         family
     *       }
     *     }
     *   }`,
     *   'GetPatientById',
     *   { patientId: '123' }
     * );
     * ```
     *
     * See the GraphQL documentation for more details: https://graphql.org/learn/
     *
     * See the FHIR GraphQL documentation for FHIR specific details: https://www.hl7.org/fhir/graphql.html
     *
     * @category Read
     * @param query The GraphQL query.
     * @param operationName Optional GraphQL operation name.
     * @param variables Optional GraphQL variables.
     * @param options Optional fetch options.
     * @returns The GraphQL result.
     */
    graphql(query: string, operationName?: string | null, variables?: any, options?: RequestInit): Promise<any>;
    /**
     *
     * Executes the $graph operation on this resource to fetch a Bundle of resources linked to the target resource
     * according to a graph definition
  
     * @category Read
     * @param resourceType The FHIR resource type.
     * @param id The resource ID.
     * @param graphName `name` parameter of the GraphDefinition
     * @returns A Bundle
     */
    readResourceGraph<K extends ResourceType>(resourceType: K, id: string, graphName: string): ReadablePromise<Bundle<Resource>>;
    /**
     * @category Authentication
     * @returns The Login State
     */
    getActiveLogin(): LoginState | undefined;
    /**
     * @category Authentication
     */
    setActiveLogin(login: LoginState): Promise<void>;
    /**
     * @category Authentication
     */
    getAccessToken(): string | undefined;
    /**
     * @category Authentication
     */
    setAccessToken(accessToken: string): void;
    /**
     * @category Authentication
     */
    getLogins(): LoginState[];
    /**
     * @category Authentication
     */
    isLoading(): boolean;
    /**
     * @category User Profile
     */
    getProfile(): ProfileResource | undefined;
    /**
     * @category User Profile
     */
    getProfileAsync(): Promise<ProfileResource | undefined>;
    /**
     * @category User Profile
     */
    getUserConfiguration(): UserConfiguration | undefined;
    /**
     * Downloads the URL as a blob.
     *
     * @category Read
     * @param url The URL to request.
     * @returns Promise to the response body as a blob.
     */
    download(url: URL | string, options?: RequestInit): Promise<Blob>;
    /**
     * Starts a new PKCE flow.
     * These PKCE values are stateful, and must survive redirects and page refreshes.
     */
    startPkce(): Promise<void>;
    /**
     * Processes an OAuth authorization code.
     * See: https://openid.net/specs/openid-connect-core-1_0.html#TokenRequest
     * @param code The authorization code received by URL parameter.
     */
    processCode(code: string): Promise<ProfileResource>;
    /**
     * Starts a new OAuth2 client credentials flow.
     * See: https://datatracker.ietf.org/doc/html/rfc6749#section-4.4
     * @category Authentication
     * @param clientId The client ID.
     * @param clientSecret The client secret.
     * @returns Promise that resolves to the client profile.
     */
    startClientLogin(clientId: string, clientSecret: string): Promise<ProfileResource>;
}
