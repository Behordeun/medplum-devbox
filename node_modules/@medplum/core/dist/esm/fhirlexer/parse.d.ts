import { TypedValue } from '../types';
import { Token } from './tokenize';
export interface Atom {
    eval(context: TypedValue[]): TypedValue[];
}
export declare abstract class PrefixOperatorAtom implements Atom {
    readonly operator: string;
    readonly child: Atom;
    constructor(operator: string, child: Atom);
    abstract eval(context: TypedValue[]): TypedValue[];
    toString(): string;
}
export declare abstract class InfixOperatorAtom implements Atom {
    readonly operator: string;
    readonly left: Atom;
    readonly right: Atom;
    constructor(operator: string, left: Atom, right: Atom);
    abstract eval(context: TypedValue[]): TypedValue[];
    toString(): string;
}
export interface PrefixParselet {
    parse(parser: Parser, token: Token): Atom;
}
export interface InfixParselet {
    precedence: number;
    parse?(parser: Parser, left: Atom, token: Token): Atom;
}
export declare class ParserBuilder {
    #private;
    registerInfix(tokenType: string, parselet: InfixParselet): ParserBuilder;
    registerPrefix(tokenType: string, parselet: PrefixParselet): ParserBuilder;
    prefix(tokenType: string, precedence: number, builder: (token: Token, right: Atom) => Atom): ParserBuilder;
    infixLeft(tokenType: string, precedence: number, builder: (left: Atom, token: Token, right: Atom) => Atom): ParserBuilder;
    construct(input: Token[]): Parser;
}
export declare class Parser {
    #private;
    constructor(tokens: Token[], prefixParselets: Record<string, PrefixParselet>, infixParselets: Record<string, InfixParselet>);
    hasMore(): boolean;
    match(expected: string): boolean;
    consumeAndParse(precedence?: number): Atom;
    getPrecedence(): number;
    consume(expectedId?: string, expectedValue?: string): Token;
    peek(): Token | undefined;
    removeComments(): void;
    getInfixParselet(token: Token): InfixParselet | undefined;
}
