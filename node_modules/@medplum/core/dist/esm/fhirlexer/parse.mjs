import { __classPrivateFieldGet, __classPrivateFieldSet } from '../node_modules/tslib/tslib.es6.mjs';

var _ParserBuilder_prefixParselets, _ParserBuilder_infixParselets, _Parser_tokens, _Parser_prefixParselets, _Parser_infixParselets;
class PrefixOperatorAtom {
    constructor(operator, child) {
        this.operator = operator;
        this.child = child;
    }
    toString() {
        return `${this.operator}(${this.child.toString()})`;
    }
}
class InfixOperatorAtom {
    constructor(operator, left, right) {
        this.operator = operator;
        this.left = left;
        this.right = right;
    }
    toString() {
        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;
    }
}
class ParserBuilder {
    constructor() {
        _ParserBuilder_prefixParselets.set(this, {});
        _ParserBuilder_infixParselets.set(this, {});
    }
    registerInfix(tokenType, parselet) {
        __classPrivateFieldGet(this, _ParserBuilder_infixParselets, "f")[tokenType] = parselet;
        return this;
    }
    registerPrefix(tokenType, parselet) {
        __classPrivateFieldGet(this, _ParserBuilder_prefixParselets, "f")[tokenType] = parselet;
        return this;
    }
    prefix(tokenType, precedence, builder) {
        return this.registerPrefix(tokenType, {
            parse(parser, token) {
                const right = parser.consumeAndParse(precedence);
                return builder(token, right);
            },
        });
    }
    infixLeft(tokenType, precedence, builder) {
        return this.registerInfix(tokenType, {
            parse(parser, left, token) {
                const right = parser.consumeAndParse(precedence);
                return builder(left, token, right);
            },
            precedence,
        });
    }
    construct(input) {
        return new Parser(input, __classPrivateFieldGet(this, _ParserBuilder_prefixParselets, "f"), __classPrivateFieldGet(this, _ParserBuilder_infixParselets, "f"));
    }
}
_ParserBuilder_prefixParselets = new WeakMap(), _ParserBuilder_infixParselets = new WeakMap();
class Parser {
    constructor(tokens, prefixParselets, infixParselets) {
        _Parser_tokens.set(this, void 0);
        _Parser_prefixParselets.set(this, void 0);
        _Parser_infixParselets.set(this, void 0);
        __classPrivateFieldSet(this, _Parser_tokens, tokens, "f");
        __classPrivateFieldSet(this, _Parser_prefixParselets, prefixParselets, "f");
        __classPrivateFieldSet(this, _Parser_infixParselets, infixParselets, "f");
    }
    hasMore() {
        return __classPrivateFieldGet(this, _Parser_tokens, "f").length > 0;
    }
    match(expected) {
        const token = this.peek();
        if (token?.id !== expected) {
            return false;
        }
        this.consume();
        return true;
    }
    consumeAndParse(precedence = Infinity) {
        const token = this.consume();
        const prefix = __classPrivateFieldGet(this, _Parser_prefixParselets, "f")[token.id];
        if (!prefix) {
            throw Error(`Parse error at "${token.value}" (line ${token.line}, column ${token.column}). No matching prefix parselet.`);
        }
        let left = prefix.parse(this, token);
        while (precedence > this.getPrecedence()) {
            const next = this.consume();
            const infix = this.getInfixParselet(next);
            left = infix.parse(this, left, next);
        }
        return left;
    }
    getPrecedence() {
        const nextToken = this.peek();
        if (!nextToken) {
            return Infinity;
        }
        const parser = this.getInfixParselet(nextToken);
        if (parser) {
            return parser.precedence;
        }
        return Infinity;
    }
    consume(expectedId, expectedValue) {
        if (!__classPrivateFieldGet(this, _Parser_tokens, "f").length) {
            throw Error('Cant consume unknown more tokens.');
        }
        if (expectedId && this.peek()?.id !== expectedId) {
            const actual = this.peek();
            throw Error(`Expected ${expectedId} but got "${actual.id}" at line ${actual.line} column ${actual.column}.`);
        }
        if (expectedValue && this.peek()?.value !== expectedValue) {
            const actual = this.peek();
            throw Error(`Expected "${expectedValue}" but got "${actual.value}" at line ${actual.line} column ${actual.column}.`);
        }
        return __classPrivateFieldGet(this, _Parser_tokens, "f").shift();
    }
    peek() {
        return __classPrivateFieldGet(this, _Parser_tokens, "f").length > 0 ? __classPrivateFieldGet(this, _Parser_tokens, "f")[0] : undefined;
    }
    removeComments() {
        __classPrivateFieldSet(this, _Parser_tokens, __classPrivateFieldGet(this, _Parser_tokens, "f").filter((t) => t.id !== 'Comment'), "f");
    }
    getInfixParselet(token) {
        return __classPrivateFieldGet(this, _Parser_infixParselets, "f")[token.id === 'Symbol' ? token.value : token.id];
    }
}
_Parser_tokens = new WeakMap(), _Parser_prefixParselets = new WeakMap(), _Parser_infixParselets = new WeakMap();

export { InfixOperatorAtom, Parser, ParserBuilder, PrefixOperatorAtom };
//# sourceMappingURL=parse.mjs.map
