import { __classPrivateFieldSet, __classPrivateFieldGet } from './node_modules/tslib/tslib.es6.mjs';
import { LRUCache } from './cache.mjs';
import { getRandomString, encryptSHA256 } from './crypto.mjs';
import { EventTarget } from './eventtarget.mjs';
import { parseJWTPayload } from './jwt.mjs';
import { ReadablePromise } from './readablepromise.mjs';
import { ClientStorage } from './storage.mjs';
import { globalSchema, indexStructureDefinition, indexSearchParameter } from './types.mjs';
import { createReference, arrayBufferToBase64 } from './utils.mjs';

// PKCE auth based on:
// https://aws.amazon.com/blogs/security/how-to-add-authentication-single-page-web-application-with-amazon-cognito-oauth2-implementation/
var _MedplumClient_instances, _MedplumClient_fetch, _MedplumClient_createPdf, _MedplumClient_storage, _MedplumClient_requestCache, _MedplumClient_cacheTime, _MedplumClient_baseUrl, _MedplumClient_authorizeUrl, _MedplumClient_tokenUrl, _MedplumClient_logoutUrl, _MedplumClient_onUnauthenticated, _MedplumClient_clientId, _MedplumClient_clientSecret, _MedplumClient_accessToken, _MedplumClient_refreshToken, _MedplumClient_refreshPromise, _MedplumClient_profilePromise, _MedplumClient_profile, _MedplumClient_config, _MedplumClient_addLogin, _MedplumClient_refreshProfile, _MedplumClient_getCacheEntry, _MedplumClient_setCacheEntry, _MedplumClient_request, _MedplumClient_addFetchOptionsDefaults, _MedplumClient_setRequestContentType, _MedplumClient_setRequestBody, _MedplumClient_handleUnauthenticated, _MedplumClient_requestAuthorization, _MedplumClient_refresh, _MedplumClient_fetchTokens, _MedplumClient_verifyTokens, _MedplumClient_setupStorageListener;
const MEDPLUM_VERSION = "1.0.6-5860113c";
const DEFAULT_BASE_URL = 'https://api.medplum.com/';
const DEFAULT_RESOURCE_CACHE_SIZE = 1000;
const DEFAULT_CACHE_TIME = 60000; // 60 seconds
const JSON_CONTENT_TYPE = 'application/json';
const FHIR_CONTENT_TYPE = 'application/fhir+json';
const PATCH_CONTENT_TYPE = 'application/json-patch+json';
/**
 * The MedplumClient class provides a client for the Medplum FHIR server.
 *
 * The client can be used in the browser, in a NodeJS application, or in a Medplum Bot.
 *
 * The client provides helpful methods for common operations such as:
 *   1) Authenticating
 *   2) Creating resources
 *   2) Reading resources
 *   3) Updating resources
 *   5) Deleting resources
 *   6) Searching
 *   7) Making GraphQL queries
 *
 * Here is a quick example of how to use the client:
 *
 * ```typescript
 * import { MedplumClient } from '@medplum/core';
 * const medplum = new MedplumClient();
 * ```
 *
 * Create a `Patient`:
 *
 * ```typescript
 * const patient = await medplum.createResource({
 *   resourceType: 'Patient',
 *   name: [{
 *     given: ['Alice'],
 *     family: 'Smith'
 *   }]
 * });
 * ```
 *
 * Read a `Patient` by ID:
 *
 * ```typescript
 * const patient = await medplum.readResource('Patient', '123');
 * console.log(patient.name[0].given[0]);
 * ```
 *
 * Search for a `Patient` by name:
 *
 * ```typescript
 * const bundle = await medplum.search('Patient', 'name=Alice');
 * console.log(bundle.total);
 * ```
 *
 *  <head>
 *    <meta name="algolia:pageRank" content="100" />
 *  </head>

 */
class MedplumClient extends EventTarget {
    constructor(options) {
        super();
        _MedplumClient_instances.add(this);
        _MedplumClient_fetch.set(this, void 0);
        _MedplumClient_createPdf.set(this, void 0);
        _MedplumClient_storage.set(this, void 0);
        _MedplumClient_requestCache.set(this, void 0);
        _MedplumClient_cacheTime.set(this, void 0);
        _MedplumClient_baseUrl.set(this, void 0);
        _MedplumClient_authorizeUrl.set(this, void 0);
        _MedplumClient_tokenUrl.set(this, void 0);
        _MedplumClient_logoutUrl.set(this, void 0);
        _MedplumClient_onUnauthenticated.set(this, void 0);
        _MedplumClient_clientId.set(this, void 0);
        _MedplumClient_clientSecret.set(this, void 0);
        _MedplumClient_accessToken.set(this, void 0);
        _MedplumClient_refreshToken.set(this, void 0);
        _MedplumClient_refreshPromise.set(this, void 0);
        _MedplumClient_profilePromise.set(this, void 0);
        _MedplumClient_profile.set(this, void 0);
        _MedplumClient_config.set(this, void 0);
        if (options?.baseUrl) {
            if (!options.baseUrl.startsWith('http')) {
                throw new Error('Base URL must start with http or https');
            }
        }
        __classPrivateFieldSet(this, _MedplumClient_fetch, options?.fetch || window.fetch.bind(window), "f");
        __classPrivateFieldSet(this, _MedplumClient_createPdf, options?.createPdf, "f");
        __classPrivateFieldSet(this, _MedplumClient_storage, new ClientStorage(), "f");
        __classPrivateFieldSet(this, _MedplumClient_requestCache, new LRUCache(options?.resourceCacheSize ?? DEFAULT_RESOURCE_CACHE_SIZE), "f");
        __classPrivateFieldSet(this, _MedplumClient_cacheTime, options?.cacheTime ?? DEFAULT_CACHE_TIME, "f");
        __classPrivateFieldSet(this, _MedplumClient_baseUrl, ensureTrailingSlash(options?.baseUrl) || DEFAULT_BASE_URL, "f");
        __classPrivateFieldSet(this, _MedplumClient_clientId, options?.clientId || '', "f");
        __classPrivateFieldSet(this, _MedplumClient_authorizeUrl, options?.authorizeUrl || __classPrivateFieldGet(this, _MedplumClient_baseUrl, "f") + 'oauth2/authorize', "f");
        __classPrivateFieldSet(this, _MedplumClient_tokenUrl, options?.tokenUrl || __classPrivateFieldGet(this, _MedplumClient_baseUrl, "f") + 'oauth2/token', "f");
        __classPrivateFieldSet(this, _MedplumClient_logoutUrl, options?.logoutUrl || __classPrivateFieldGet(this, _MedplumClient_baseUrl, "f") + 'oauth2/logout', "f");
        __classPrivateFieldSet(this, _MedplumClient_onUnauthenticated, options?.onUnauthenticated, "f");
        const activeLogin = this.getActiveLogin();
        if (activeLogin) {
            __classPrivateFieldSet(this, _MedplumClient_accessToken, activeLogin.accessToken, "f");
            __classPrivateFieldSet(this, _MedplumClient_refreshToken, activeLogin.refreshToken, "f");
            __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_refreshProfile).call(this).catch(console.log);
        }
        __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_setupStorageListener).call(this);
    }
    /**
     * Returns the current base URL for all API requests.
     * By default, this is set to `https://api.medplum.com/`.
     * This can be overridden by setting the `baseUrl` option when creating the client.
     * @category HTTP
     * @returns The current base URL for all API requests.
     */
    getBaseUrl() {
        return __classPrivateFieldGet(this, _MedplumClient_baseUrl, "f");
    }
    /**
     * Clears all auth state including local storage and session storage.
     * @category Authentication
     */
    clear() {
        __classPrivateFieldGet(this, _MedplumClient_storage, "f").clear();
        __classPrivateFieldGet(this, _MedplumClient_requestCache, "f").clear();
        __classPrivateFieldSet(this, _MedplumClient_accessToken, undefined, "f");
        __classPrivateFieldSet(this, _MedplumClient_refreshToken, undefined, "f");
        __classPrivateFieldSet(this, _MedplumClient_profile, undefined, "f");
        __classPrivateFieldSet(this, _MedplumClient_config, undefined, "f");
        this.dispatchEvent({ type: 'change' });
    }
    /**
     * Invalidates any cached values or cached requests for the given URL.
     * @category Caching
     * @param url The URL to invalidate.
     */
    invalidateUrl(url) {
        url = url.toString();
        __classPrivateFieldGet(this, _MedplumClient_requestCache, "f").delete(url);
    }
    /**
     * Invalidates all cached search results or cached requests for the given resourceType.
     * @category Caching
     * @param resourceType The resource type to invalidate.
     */
    invalidateSearches(resourceType) {
        const url = 'fhir/R4/' + resourceType;
        for (const key of __classPrivateFieldGet(this, _MedplumClient_requestCache, "f").keys()) {
            if (key.endsWith(url) || key.includes(url + '?')) {
                __classPrivateFieldGet(this, _MedplumClient_requestCache, "f").delete(key);
            }
        }
    }
    /**
     * Makes an HTTP GET request to the specified URL.
     *
     * This is a lower level method for custom requests.
     * For common operations, we recommend using higher level methods
     * such as `readResource()`, `search()`, etc.
     *
     * @category HTTP
     * @param url The target URL.
     * @param options Optional fetch options.
     * @returns Promise to the response content.
     */
    get(url, options = {}) {
        url = url.toString();
        const cached = __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_getCacheEntry).call(this, url, options);
        if (cached) {
            return cached.value;
        }
        const promise = new ReadablePromise(__classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_request).call(this, 'GET', url, options));
        __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_setCacheEntry).call(this, url, promise);
        return promise;
    }
    /**
     * Makes an HTTP POST request to the specified URL.
     *
     * This is a lower level method for custom requests.
     * For common operations, we recommend using higher level methods
     * such as `createResource()`.
     *
     * @category HTTP
     * @param url The target URL.
     * @param body The content body. Strings and `File` objects are passed directly. Other objects are converted to JSON.
     * @param contentType The content type to be included in the "Content-Type" header.
     * @param options Optional fetch options.
     * @returns Promise to the response content.
     */
    post(url, body, contentType, options = {}) {
        url = url.toString();
        if (body) {
            __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_setRequestBody).call(this, options, body);
        }
        if (contentType) {
            __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_setRequestContentType).call(this, options, contentType);
        }
        this.invalidateUrl(url);
        return __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_request).call(this, 'POST', url, options);
    }
    /**
     * Makes an HTTP PUT request to the specified URL.
     *
     * This is a lower level method for custom requests.
     * For common operations, we recommend using higher level methods
     * such as `updateResource()`.
     *
     * @category HTTP
     * @param url The target URL.
     * @param body The content body. Strings and `File` objects are passed directly. Other objects are converted to JSON.
     * @param contentType The content type to be included in the "Content-Type" header.
     * @param options Optional fetch options.
     * @returns Promise to the response content.
     */
    put(url, body, contentType, options = {}) {
        url = url.toString();
        if (body) {
            __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_setRequestBody).call(this, options, body);
        }
        if (contentType) {
            __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_setRequestContentType).call(this, options, contentType);
        }
        this.invalidateUrl(url);
        return __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_request).call(this, 'PUT', url, options);
    }
    /**
     * Makes an HTTP PATCH request to the specified URL.
     *
     * This is a lower level method for custom requests.
     * For common operations, we recommend using higher level methods
     * such as `patchResource()`.
     *
     * @category HTTP
     * @param url The target URL.
     * @param operations Array of JSONPatch operations.
     * @param options Optional fetch options.
     * @returns Promise to the response content.
     */
    patch(url, operations, options = {}) {
        url = url.toString();
        __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_setRequestBody).call(this, options, operations);
        __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_setRequestContentType).call(this, options, PATCH_CONTENT_TYPE);
        this.invalidateUrl(url);
        return __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_request).call(this, 'PATCH', url, options);
    }
    /**
     * Makes an HTTP DELETE request to the specified URL.
     *
     *
     * This is a lower level method for custom requests.
     * For common operations, we recommend using higher level methods
     * such as `deleteResource()`.
     *
     * @category HTTP
     * @param url The target URL.
     * @param options Optional fetch options.
     * @returns Promise to the response content.
     */
    delete(url, options = {}) {
        url = url.toString();
        this.invalidateUrl(url);
        return __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_request).call(this, 'DELETE', url, options);
    }
    /**
     * Initiates a new user flow.
     *
     * This method is part of the two different user registration flows:
     * 1) New Practitioner and new Project
     * 2) New Patient registration
     *
     * @category Authentication
     * @param newUserRequest Register request including email and password.
     * @returns Promise to the authentication response.
     */
    async startNewUser(newUserRequest) {
        await this.startPkce();
        return this.post('auth/newuser', {
            ...newUserRequest,
            codeChallengeMethod: 'S256',
            codeChallenge: sessionStorage.getItem('codeChallenge'),
        });
    }
    /**
     * Initiates a new project flow.
     *
     * This requires a partial login from `startNewUser` or `startNewGoogleUser`.
     *
     * @param newProjectRequest Register request including email and password.
     * @returns Promise to the authentication response.
     */
    async startNewProject(newProjectRequest) {
        return this.post('auth/newproject', newProjectRequest);
    }
    /**
     * Initiates a new patient flow.
     *
     * This requires a partial login from `startNewUser` or `startNewGoogleUser`.
     *
     * @param newPatientRequest Register request including email and password.
     * @returns Promise to the authentication response.
     */
    async startNewPatient(newPatientRequest) {
        return this.post('auth/newpatient', newPatientRequest);
    }
    /**
     * Initiates a user login flow.
     * @category Authentication
     * @param loginRequest Login request including email and password.
     * @returns Promise to the authentication response.
     */
    async startLogin(loginRequest) {
        const { codeChallenge, codeChallengeMethod } = this.getCodeChallenge(loginRequest);
        return this.post('auth/login', {
            ...loginRequest,
            clientId: loginRequest.clientId ?? __classPrivateFieldGet(this, _MedplumClient_clientId, "f"),
            scope: loginRequest.scope,
            codeChallengeMethod,
            codeChallenge,
        });
    }
    /**
     * Tries to sign in with Google authentication.
     * The response parameter is the result of a Google authentication.
     * See: https://developers.google.com/identity/gsi/web/guides/handle-credential-responses-js-functions
     * @category Authentication
     * @param loginRequest Login request including Google credential response.
     * @returns Promise to the authentication response.
     */
    async startGoogleLogin(loginRequest) {
        const { codeChallenge, codeChallengeMethod } = this.getCodeChallenge(loginRequest);
        return this.post('auth/google', {
            ...loginRequest,
            clientId: loginRequest.clientId ?? __classPrivateFieldGet(this, _MedplumClient_clientId, "f"),
            scope: loginRequest.scope,
            codeChallengeMethod,
            codeChallenge,
        });
    }
    getCodeChallenge(loginRequest) {
        if (loginRequest.codeChallenge) {
            return {
                codeChallenge: loginRequest.codeChallenge,
                codeChallengeMethod: loginRequest.codeChallengeMethod,
            };
        }
        const codeChallenge = sessionStorage.getItem('codeChallenge');
        if (codeChallenge) {
            return {
                codeChallenge,
                codeChallengeMethod: 'S256',
            };
        }
        return {};
    }
    /**
     * Signs out locally.
     * Does not invalidate tokens with the server.
     * @category Authentication
     */
    signOut() {
        this.clear();
    }
    /**
     * Tries to sign in the user.
     * Returns true if the user is signed in.
     * This may result in navigating away to the sign in page.
     * @category Authentication
     */
    async signInWithRedirect() {
        const urlParams = new URLSearchParams(window.location.search);
        const code = urlParams.get('code');
        if (!code) {
            await __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_requestAuthorization).call(this);
            return undefined;
        }
        else {
            return this.processCode(code);
        }
    }
    /**
     * Tries to sign out the user.
     * See: https://docs.aws.amazon.com/cognito/latest/developerguide/logout-endpoint.html
     * @category Authentication
     */
    signOutWithRedirect() {
        window.location.assign(__classPrivateFieldGet(this, _MedplumClient_logoutUrl, "f"));
    }
    /**
     * Builds a FHIR URL from a collection of URL path components.
     * For example, `buildUrl('/Patient', '123')` returns `fhir/R4/Patient/123`.
     * @category HTTP
     * @param path The path component of the URL.
     * @returns The well-formed FHIR URL.
     */
    fhirUrl(...path) {
        return new URL(__classPrivateFieldGet(this, _MedplumClient_baseUrl, "f") + 'fhir/R4/' + path.join('/'));
    }
    /**
     * Builds a FHIR search URL from a search query or structured query object.
     * @category HTTP
     * @category Search
     * @param query The FHIR search query or structured query object.
     * @returns The well-formed FHIR URL.
     */
    fhirSearchUrl(resourceType, query) {
        const url = this.fhirUrl(resourceType);
        if (query) {
            url.search = query.toString();
        }
        return url;
    }
    /**
     * Sends a FHIR search request.
     *
     * Example using a FHIR search string:
     *
     * ```typescript
     * const bundle = await client.search('Patient', 'name=Alice');
     * console.log(bundle);
     * ```
     *
     * The return value is a FHIR bundle:
     *
     * ```json
     * {
     *    "resourceType": "Bundle",
     *    "type": "searchset",
     *    "entry": [
     *       {
     *          "resource": {
     *             "resourceType": "Patient",
     *             "name": [
     *                {
     *                   "given": [
     *                      "George"
     *                   ],
     *                   "family": "Washington"
     *                }
     *             ],
     *          }
     *       }
     *    ]
     * }
     * ```
     *
     * To query the count of a search, use the summary feature like so:
     *
     * ```typescript
     * const patients = medplum.search('Patient', '_summary=count');
     * ```
     *
     * See FHIR search for full details: https://www.hl7.org/fhir/search.html
     *
     * @category Search
     * @param resourceType The FHIR resource type.
     * @param query The search query as either a string or a structured search object.
     * @param options Optional fetch options.
     * @returns Promise to the search result bundle.
     */
    search(resourceType, query, options = {}) {
        return this.get(this.fhirSearchUrl(resourceType, query), options);
    }
    /**
     * Sends a FHIR search request for a single resource.
     *
     * This is a convenience method for `search()` that returns the first resource rather than a `Bundle`.
     *
     * Example using a FHIR search string:
     *
     * ```typescript
     * const patient = await client.searchOne('Patient', 'identifier=123');
     * console.log(patient);
     * ```
     *
     * The return value is the resource, if available; otherwise, undefined.
     *
     * See FHIR search for full details: https://www.hl7.org/fhir/search.html
     *
     * @category Search
     * @param resourceType The FHIR resource type.
     * @param query The search query as either a string or a structured search object.
     * @param options Optional fetch options.
     * @returns Promise to the search result bundle.
     */
    searchOne(resourceType, query, options = {}) {
        const url = this.fhirSearchUrl(resourceType, query);
        url.searchParams.set('_count', '1');
        url.searchParams.sort();
        const cacheKey = url.toString() + '-searchOne';
        const cached = __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_getCacheEntry).call(this, cacheKey, options);
        if (cached) {
            return cached.value;
        }
        const promise = new ReadablePromise(this.search(resourceType, url.searchParams, options).then((b) => b.entry?.[0]?.resource));
        __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_setCacheEntry).call(this, cacheKey, promise);
        return promise;
    }
    /**
     * Sends a FHIR search request for an array of resources.
     *
     * This is a convenience method for `search()` that returns the resources as an array rather than a `Bundle`.
     *
     * Example using a FHIR search string:
     *
     * ```typescript
     * const patients = await client.searchResources('Patient', 'name=Alice');
     * console.log(patients);
     * ```
     *
     * The return value is an array of resources.
     *
     * See FHIR search for full details: https://www.hl7.org/fhir/search.html
     *
     * @category Search
     * @param resourceType The FHIR resource type.
     * @param query The search query as either a string or a structured search object.
     * @param options Optional fetch options.
     * @returns Promise to the search result bundle.
     */
    searchResources(resourceType, query, options = {}) {
        const url = this.fhirSearchUrl(resourceType, query);
        const cacheKey = url.toString() + '-searchResources';
        const cached = __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_getCacheEntry).call(this, cacheKey, options);
        if (cached) {
            return cached.value;
        }
        const promise = new ReadablePromise(this.search(resourceType, query, options).then((b) => b.entry?.map((e) => e.resource) ?? []));
        __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_setCacheEntry).call(this, cacheKey, promise);
        return promise;
    }
    /**
     * Searches a ValueSet resource using the "expand" operation.
     * See: https://www.hl7.org/fhir/operation-valueset-expand.html
     *
     * @category Search
     * @param system The ValueSet system url.
     * @param filter The search string.
     * @param options Optional fetch options.
     * @returns Promise to expanded ValueSet.
     */
    searchValueSet(system, filter, options = {}) {
        const url = this.fhirUrl('ValueSet', '$expand');
        url.searchParams.set('url', system);
        url.searchParams.set('filter', filter);
        return this.get(url.toString(), options);
    }
    /**
     * Returns a cached resource if it is available.
     * @category Caching
     * @param resourceType The FHIR resource type.
     * @param id The FHIR resource ID.
     * @returns The resource if it is available in the cache; undefined otherwise.
     */
    getCached(resourceType, id) {
        const cached = __classPrivateFieldGet(this, _MedplumClient_requestCache, "f").get(this.fhirUrl(resourceType, id).toString())?.value;
        return cached && cached.isOk() ? cached.read() : undefined;
    }
    /**
     * Returns a cached resource if it is available.
     * @category Caching
     * @param resourceType The FHIR resource type.
     * @param id The FHIR resource ID.
     * @returns The resource if it is available in the cache; undefined otherwise.
     */
    getCachedReference(reference) {
        const refString = reference.reference;
        if (!refString) {
            return undefined;
        }
        const [resourceType, id] = refString.split('/');
        if (!resourceType || !id) {
            return undefined;
        }
        return this.getCached(resourceType, id);
    }
    /**
     * Reads a resource by resource type and ID.
     *
     * Example:
     *
     * ```typescript
     * const patient = await medplum.readResource('Patient', '123');
     * console.log(patient);
     * ```
     *
     * See the FHIR "read" operation for full details: https://www.hl7.org/fhir/http.html#read
     *
     * @category Read
     * @param resourceType The FHIR resource type.
     * @param id The resource ID.
     * @param options Optional fetch options.
     * @returns The resource if available; undefined otherwise.
     */
    readResource(resourceType, id, options = {}) {
        return this.get(this.fhirUrl(resourceType, id), options);
    }
    /**
     * Reads a resource by `Reference`.
     *
     * This is a convenience method for `readResource()` that accepts a `Reference` object.
     *
     * Example:
     *
     * ```typescript
     * const serviceRequest = await medplum.readResource('ServiceRequest', '123');
     * const patient = await medplum.readReference(serviceRequest.subject);
     * console.log(patient);
     * ```
     *
     * See the FHIR "read" operation for full details: https://www.hl7.org/fhir/http.html#read
     *
     * @category Read
     * @param reference The FHIR reference object.
     * @param options Optional fetch options.
     * @returns The resource if available; undefined otherwise.
     */
    readReference(reference, options = {}) {
        const refString = reference?.reference;
        if (!refString) {
            return new ReadablePromise(Promise.reject(new Error('Missing reference')));
        }
        const [resourceType, id] = refString.split('/');
        if (!resourceType || !id) {
            return new ReadablePromise(Promise.reject(new Error('Invalid reference')));
        }
        return this.readResource(resourceType, id, options);
    }
    /**
     * Returns a cached schema for a resource type.
     * If the schema is not cached, returns undefined.
     * It is assumed that a client will call requestSchema before using this method.
     * @category Schema
     * @returns The schema if immediately available, undefined otherwise.
     * @deprecated Use globalSchema instead.
     */
    getSchema() {
        return globalSchema;
    }
    /**
     * Requests the schema for a resource type.
     * If the schema is already cached, the promise is resolved immediately.
     * @category Schema
     * @param resourceType The FHIR resource type.
     * @returns Promise to a schema with the requested resource type.
     */
    async requestSchema(resourceType) {
        if (resourceType in globalSchema.types) {
            return globalSchema;
        }
        const query = `{
      StructureDefinitionList(name: "${resourceType}") {
        name,
        description,
        snapshot {
          element {
            id,
            path,
            min,
            max,
            type {
              code,
              targetProfile
            },
            binding {
              valueSet
            },
            definition
          }
        }
      }
      SearchParameterList(base: "${resourceType}", _count: 100) {
        base,
        code,
        type,
        expression,
        target
      }
    }`.replace(/\s+/g, ' ');
        const response = (await this.graphql(query));
        for (const structureDefinition of response.data.StructureDefinitionList) {
            indexStructureDefinition(structureDefinition);
        }
        for (const searchParameter of response.data.SearchParameterList) {
            indexSearchParameter(searchParameter);
        }
        return globalSchema;
    }
    /**
     * Reads resource history by resource type and ID.
     *
     * The return value is a bundle of all versions of the resource.
     *
     * Example:
     *
     * ```typescript
     * const history = await medplum.readHistory('Patient', '123');
     * console.log(history);
     * ```
     *
     * See the FHIR "history" operation for full details: https://www.hl7.org/fhir/http.html#history
     *
     * @category Read
     * @param resourceType The FHIR resource type.
     * @param id The resource ID.
     * @param options Optional fetch options.
     * @returns Promise to the resource history.
     */
    readHistory(resourceType, id, options = {}) {
        return this.get(this.fhirUrl(resourceType, id, '_history'), options);
    }
    /**
     * Reads a specific version of a resource by resource type, ID, and version ID.
     *
     * Example:
     *
     * ```typescript
     * const version = await medplum.readVersion('Patient', '123', '456');
     * console.log(version);
     * ```
     *
     * See the FHIR "vread" operation for full details: https://www.hl7.org/fhir/http.html#vread
     *
     * @category Read
     * @param resourceType The FHIR resource type.
     * @param id The resource ID.
     * @param vid The version ID.
     * @param options Optional fetch options.
     * @returns The resource if available; undefined otherwise.
     */
    readVersion(resourceType, id, vid, options = {}) {
        return this.get(this.fhirUrl(resourceType, id, '_history', vid), options);
    }
    /**
     * Executes the Patient "everything" operation for a patient.
     *
     * Example:
     *
     * ```typescript
     * const bundle = await medplum.readPatientEverything('123');
     * console.log(bundle);
     * ```
     *
     * See the FHIR "patient-everything" operation for full details: https://hl7.org/fhir/operation-patient-everything.html
     *
     * @category Read
     * @param id The Patient Id
     * @param options Optional fetch options.
     * @returns A Bundle of all Resources related to the Patient
     */
    readPatientEverything(id, options = {}) {
        return this.get(this.fhirUrl('Patient', id, '$everything'), options);
    }
    /**
     * Creates a new FHIR resource.
     *
     * The return value is the newly created resource, including the ID and meta.
     *
     * Example:
     *
     * ```typescript
     * const result = await medplum.createResource({
     *   resourceType: 'Patient',
     *   name: [{
     *    family: 'Smith',
     *    given: ['John']
     *   }]
     * });
     * console.log(result.id);
     * ```
     *
     * See the FHIR "create" operation for full details: https://www.hl7.org/fhir/http.html#create
     *
     * @category Create
     * @param resource The FHIR resource to create.
     * @returns The result of the create operation.
     */
    createResource(resource) {
        if (!resource.resourceType) {
            throw new Error('Missing resourceType');
        }
        this.invalidateSearches(resource.resourceType);
        return this.post(this.fhirUrl(resource.resourceType), resource);
    }
    /**
     * Conditionally create a new FHIR resource only if some equivalent resource does not already exist on the server.
     *
     * The return value is the existing resource or the newly created resource, including the ID and meta.
     *
     * Example:
     *
     * ```typescript
     * const result = await medplum.createResourceIfNoneExist(
     *   {
     *     resourceType: 'Patient',
     *     identifier: [{
     *      system: 'http://example.com/mrn',
     *      value: '123'
     *     }]
     *     name: [{
     *      family: 'Smith',
     *      given: ['John']
     *     }]
     *   },
     *   'identifier=123'
     * );
     * console.log(result.id);
     * ```
     *
     * This method is syntactic sugar for:
     *
     * ```typescript
     * return searchOne(resourceType, query) ?? createResource(resource);
     * ```
     *
     * The query parameter only contains the search parameters (what would be in the URL following the "?").
     *
     * See the FHIR "conditional create" operation for full details: https://www.hl7.org/fhir/http.html#ccreate
     *
     * @category Create
     * @param resource The FHIR resource to create.
     * @param query The search query for an equivalent resource (should not include resource type or "?").
     * @returns The result of the create operation.
     */
    async createResourceIfNoneExist(resource, query) {
        return ((await this.searchOne(resource.resourceType, query)) ?? this.createResource(resource));
    }
    /**
     * Creates a FHIR `Binary` resource with the provided data content.
     *
     * The return value is the newly created resource, including the ID and meta.
     *
     * The `data` parameter can be a string or a `File` object.
     *
     * A `File` object often comes from a `<input type="file">` element.
     *
     * Example:
     *
     * ```typescript
     * const result = await medplum.createBinary(myFile, 'test.jpg', 'image/jpeg');
     * console.log(result.id);
     * ```
     *
     * See the FHIR "create" operation for full details: https://www.hl7.org/fhir/http.html#create
     *
     * @category Create
     * @param data The binary data to upload.
     * @param filename Optional filename for the binary.
     * @param contentType Content type for the binary.
     * @returns The result of the create operation.
     */
    createBinary(data, filename, contentType, onProgress) {
        const url = this.fhirUrl('Binary');
        if (filename) {
            url.searchParams.set('_filename', filename);
        }
        if (onProgress) {
            return this.uploadwithProgress(url, data, contentType, onProgress);
        }
        else {
            return this.post(url, data, contentType);
        }
    }
    uploadwithProgress(url, data, contentType, onProgress) {
        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.responseType = 'json';
            xhr.onabort = () => reject(new Error('Request aborted'));
            xhr.onerror = () => reject(new Error('Request error'));
            if (onProgress) {
                xhr.upload.onprogress = (e) => onProgress(e);
                xhr.upload.onload = (e) => onProgress(e);
            }
            xhr.onload = () => {
                if (xhr.status >= 200 && xhr.status < 300) {
                    resolve(xhr.response);
                }
                else {
                    reject(new Error(xhr.statusText));
                }
            };
            xhr.open('POST', url);
            xhr.withCredentials = true;
            xhr.setRequestHeader('Authorization', 'Bearer ' + __classPrivateFieldGet(this, _MedplumClient_accessToken, "f"));
            xhr.setRequestHeader('Cache-Control', 'no-cache, no-store, max-age=0');
            xhr.setRequestHeader('Content-Type', contentType);
            xhr.setRequestHeader('X-Medplum', 'extended');
            xhr.send(data);
        });
    }
    /**
     * Creates a PDF as a FHIR `Binary` resource based on pdfmake document definition.
     *
     * The return value is the newly created resource, including the ID and meta.
     *
     * The `docDefinition` parameter is a pdfmake document definition.
     *
     * Example:
     *
     * ```typescript
     * const result = await medplum.createPdf({
     *   content: ['Hello world']
     * });
     * console.log(result.id);
     * ```
     *
     * See the pdfmake document definition for full details: https://pdfmake.github.io/docs/0.1/document-definition-object/
     *
     * @category Media
     * @param docDefinition The PDF document definition.
     * @returns The result of the create operation.
     */
    async createPdf(docDefinition, filename, tableLayouts, fonts) {
        if (!__classPrivateFieldGet(this, _MedplumClient_createPdf, "f")) {
            throw new Error('PDF creation not enabled');
        }
        const blob = await __classPrivateFieldGet(this, _MedplumClient_createPdf, "f").call(this, docDefinition, tableLayouts, fonts);
        return this.createBinary(blob, filename, 'application/pdf');
    }
    /**
     * Creates a FHIR `Communication` resource with the provided data content.
     *
     * This is a convenience method to handle commmon cases where a `Communication` resource is created with a `payload`.
     *
     * @category Create
     * @param resource The FHIR resource to comment on.
     * @param text The text of the comment.
     * @returns The result of the create operation.
     */
    createComment(resource, text) {
        const profile = this.getProfile();
        let encounter = undefined;
        let subject = undefined;
        if (resource.resourceType === 'Encounter') {
            encounter = createReference(resource);
            subject = resource.subject;
        }
        if (resource.resourceType === 'ServiceRequest') {
            encounter = resource.encounter;
            subject = resource.subject;
        }
        if (resource.resourceType === 'Patient') {
            subject = createReference(resource);
        }
        return this.createResource({
            resourceType: 'Communication',
            basedOn: [createReference(resource)],
            encounter,
            subject,
            sender: profile ? createReference(profile) : undefined,
            sent: new Date().toISOString(),
            payload: [{ contentString: text }],
        });
    }
    /**
     * Updates a FHIR resource.
     *
     * The return value is the updated resource, including the ID and meta.
     *
     * Example:
     *
     * ```typescript
     * const result = await medplum.updateResource({
     *   resourceType: 'Patient',
     *   id: '123',
     *   name: [{
     *    family: 'Smith',
     *    given: ['John']
     *   }]
     * });
     * console.log(result.meta.versionId);
     * ```
     *
     * See the FHIR "update" operation for full details: https://www.hl7.org/fhir/http.html#update
     *
     * @category Write
     * @param resource The FHIR resource to update.
     * @returns The result of the update operation.
     */
    async updateResource(resource) {
        if (!resource.resourceType) {
            throw new Error('Missing resourceType');
        }
        if (!resource.id) {
            throw new Error('Missing id');
        }
        this.invalidateSearches(resource.resourceType);
        const result = await this.put(this.fhirUrl(resource.resourceType, resource.id), resource);
        // On 304 not modified, result will be undefined
        // Return the user input instead
        return result ?? resource;
    }
    /**
     * Updates a FHIR resource using JSONPatch operations.
     *
     * The return value is the updated resource, including the ID and meta.
     *
     * Example:
     *
     * ```typescript
     * const result = await medplum.patchResource('Patient', '123', [
     *   {op: 'replace', path: '/name/0/family', value: 'Smith'},
     * ]);
     * console.log(result.meta.versionId);
     * ```
     *
     * See the FHIR "update" operation for full details: https://www.hl7.org/fhir/http.html#patch
     *
     * See the JSONPatch specification for full details: https://tools.ietf.org/html/rfc6902
     *
     * @category Write
     * @param resourceType The FHIR resource type.
     * @param id The resource ID.
     * @param operations The JSONPatch operations.
     * @returns The result of the patch operations.
     */
    patchResource(resourceType, id, operations) {
        this.invalidateSearches(resourceType);
        return this.patch(this.fhirUrl(resourceType, id), operations);
    }
    /**
     * Deletes a FHIR resource by resource type and ID.
     *
     * Example:
     *
     * ```typescript
     * await medplum.deleteResource('Patient', '123');
     * ```
     *
     * See the FHIR "delete" operation for full details: https://www.hl7.org/fhir/http.html#delete
     *
     * @category Delete
     * @param resourceType The FHIR resource type.
     * @param id The resource ID.
     * @returns The result of the delete operation.
     */
    deleteResource(resourceType, id) {
        this.invalidateSearches(resourceType);
        return this.delete(this.fhirUrl(resourceType, id));
    }
    /**
     * Executes the validate operation with the provided resource.
     *
     * Example:
     *
     * ```typescript
     * const result = await medplum.validateResource({
     *   resourceType: 'Patient',
     *   name: [{ given: ['Alice'], family: 'Smith' }],
     * });
     * ```
     *
     * See the FHIR "$validate" operation for full details: https://www.hl7.org/fhir/resource-operation-validate.html
     *
     * @param resource The FHIR resource.
     * @returns The validate operation outcome.
     */
    validateResource(resource) {
        return this.post(this.fhirUrl(resource.resourceType, '$validate'), resource);
    }
    /**
     * Executes a batch or transaction of FHIR operations.
     *
     * Example:
     *
     * ```typescript
     * await medplum.executeBatch({
     *   "resourceType": "Bundle",
     *   "type": "transaction",
     *   "entry": [
     *     {
     *       "fullUrl": "urn:uuid:61ebe359-bfdc-4613-8bf2-c5e300945f0a",
     *       "resource": {
     *         "resourceType": "Patient",
     *         "name": [{ "use": "official", "given": ["Alice"], "family": "Smith" }],
     *         "gender": "female",
     *         "birthDate": "1974-12-25"
     *       },
     *       "request": {
     *         "method": "POST",
     *         "url": "Patient"
     *       }
     *     },
     *     {
     *       "fullUrl": "urn:uuid:88f151c0-a954-468a-88bd-5ae15c08e059",
     *       "resource": {
     *         "resourceType": "Patient",
     *         "identifier": [{ "system": "http:/example.org/fhir/ids", "value": "234234" }],
     *         "name": [{ "use": "official", "given": ["Bob"], "family": "Jones" }],
     *         "gender": "male",
     *         "birthDate": "1974-12-25"
     *       },
     *       "request": {
     *         "method": "POST",
     *         "url": "Patient",
     *         "ifNoneExist": "identifier=http:/example.org/fhir/ids|234234"
     *       }
     *     }
     *   ]
     * });
     * ```
     *
     * See The FHIR "batch/transaction" section for full details: https://hl7.org/fhir/http.html#transaction
     * @category Batch
     * @param bundle The FHIR batch/transaction bundle.
     * @returns The FHIR batch/transaction response bundle.
     */
    executeBatch(bundle) {
        return this.post('fhir/R4', bundle);
    }
    /**
     * Sends an email using the Medplum Email API.
     *
     * Builds the email using nodemailer MailComposer.
     *
     * Examples:
     *
     * Send a simple text email:
     *
     * ```typescript
     * await medplum.sendEmail({
     *   to: 'alice@example.com',
     *   cc: 'bob@example.com',
     *   subject: 'Hello',
     *   text: 'Hello Alice',
     * });
     * ```
     *
     * Send an email with a `Binary` attachment:
     *
     * ```typescript
     * await medplum.sendEmail({
     *   to: 'alice@example.com',
     *   subject: 'Email with attachment',
     *   text: 'See the attached report',
     *   attachments: [{
     *     filename: 'report.pdf',
     *     path: "Binary/" + binary.id
     *   }]
     * });
     * ```
     *
     * See options here: https://nodemailer.com/extras/mailcomposer/
     * @category Media
     * @param options The MailComposer options.
     * @returns Promise to the operation outcome.
     */
    sendEmail(email) {
        return this.post('email/v1/send', email, 'application/json');
    }
    /**
     * Executes a GraphQL query.
     *
     * Example:
     *
     * ```typescript
     * const result = await medplum.graphql(`{
     *   Patient(id: "123") {
     *     resourceType
     *     id
     *     name {
     *       given
     *       family
     *     }
     *   }
     * }`);
     * ```
     *
     * Advanced queries such as named operations and variable substitution are supported:
     *
     * ```typescript
     * const result = await medplum.graphql(
     *   `query GetPatientById($patientId: ID!) {
     *     Patient(id: $patientId) {
     *       resourceType
     *       id
     *       name {
     *         given
     *         family
     *       }
     *     }
     *   }`,
     *   'GetPatientById',
     *   { patientId: '123' }
     * );
     * ```
     *
     * See the GraphQL documentation for more details: https://graphql.org/learn/
     *
     * See the FHIR GraphQL documentation for FHIR specific details: https://www.hl7.org/fhir/graphql.html
     *
     * @category Read
     * @param query The GraphQL query.
     * @param operationName Optional GraphQL operation name.
     * @param variables Optional GraphQL variables.
     * @param options Optional fetch options.
     * @returns The GraphQL result.
     */
    graphql(query, operationName, variables, options) {
        return this.post(this.fhirUrl('$graphql'), { query, operationName, variables }, JSON_CONTENT_TYPE, options);
    }
    /**
     *
     * Executes the $graph operation on this resource to fetch a Bundle of resources linked to the target resource
     * according to a graph definition
  
     * @category Read
     * @param resourceType The FHIR resource type.
     * @param id The resource ID.
     * @param graphName `name` parameter of the GraphDefinition
     * @returns A Bundle
     */
    readResourceGraph(resourceType, id, graphName) {
        return this.get(`${this.fhirUrl(resourceType, id)}/$graph?graph=${graphName}`);
    }
    /**
     * @category Authentication
     * @returns The Login State
     */
    getActiveLogin() {
        return __classPrivateFieldGet(this, _MedplumClient_storage, "f").getObject('activeLogin');
    }
    /**
     * @category Authentication
     */
    async setActiveLogin(login) {
        __classPrivateFieldSet(this, _MedplumClient_accessToken, login.accessToken, "f");
        __classPrivateFieldSet(this, _MedplumClient_refreshToken, login.refreshToken, "f");
        __classPrivateFieldSet(this, _MedplumClient_profile, undefined, "f");
        __classPrivateFieldSet(this, _MedplumClient_config, undefined, "f");
        __classPrivateFieldGet(this, _MedplumClient_storage, "f").setObject('activeLogin', login);
        __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_addLogin).call(this, login);
        __classPrivateFieldGet(this, _MedplumClient_requestCache, "f").clear();
        __classPrivateFieldSet(this, _MedplumClient_refreshPromise, undefined, "f");
        await __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_refreshProfile).call(this);
    }
    /**
     * @category Authentication
     */
    getAccessToken() {
        return __classPrivateFieldGet(this, _MedplumClient_accessToken, "f");
    }
    /**
     * @category Authentication
     */
    setAccessToken(accessToken) {
        __classPrivateFieldSet(this, _MedplumClient_accessToken, accessToken, "f");
        __classPrivateFieldSet(this, _MedplumClient_refreshToken, undefined, "f");
        __classPrivateFieldSet(this, _MedplumClient_profile, undefined, "f");
        __classPrivateFieldSet(this, _MedplumClient_config, undefined, "f");
    }
    /**
     * @category Authentication
     */
    getLogins() {
        return __classPrivateFieldGet(this, _MedplumClient_storage, "f").getObject('logins') ?? [];
    }
    /**
     * @category Authentication
     */
    isLoading() {
        return !!__classPrivateFieldGet(this, _MedplumClient_profilePromise, "f");
    }
    /**
     * @category User Profile
     */
    getProfile() {
        return __classPrivateFieldGet(this, _MedplumClient_profile, "f");
    }
    /**
     * @category User Profile
     */
    async getProfileAsync() {
        if (__classPrivateFieldGet(this, _MedplumClient_profilePromise, "f")) {
            await __classPrivateFieldGet(this, _MedplumClient_profilePromise, "f");
        }
        return this.getProfile();
    }
    /**
     * @category User Profile
     */
    getUserConfiguration() {
        return __classPrivateFieldGet(this, _MedplumClient_config, "f");
    }
    /**
     * Downloads the URL as a blob.
     *
     * @category Read
     * @param url The URL to request.
     * @returns Promise to the response body as a blob.
     */
    async download(url, options = {}) {
        if (__classPrivateFieldGet(this, _MedplumClient_refreshPromise, "f")) {
            await __classPrivateFieldGet(this, _MedplumClient_refreshPromise, "f");
        }
        __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_addFetchOptionsDefaults).call(this, options);
        const response = await __classPrivateFieldGet(this, _MedplumClient_fetch, "f").call(this, url.toString(), options);
        return response.blob();
    }
    /**
     * Starts a new PKCE flow.
     * These PKCE values are stateful, and must survive redirects and page refreshes.
     */
    async startPkce() {
        const pkceState = getRandomString();
        sessionStorage.setItem('pkceState', pkceState);
        const codeVerifier = getRandomString();
        sessionStorage.setItem('codeVerifier', codeVerifier);
        const arrayHash = await encryptSHA256(codeVerifier);
        const codeChallenge = arrayBufferToBase64(arrayHash).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
        sessionStorage.setItem('codeChallenge', codeChallenge);
    }
    /**
     * Processes an OAuth authorization code.
     * See: https://openid.net/specs/openid-connect-core-1_0.html#TokenRequest
     * @param code The authorization code received by URL parameter.
     */
    processCode(code) {
        const formBody = new URLSearchParams();
        formBody.set('grant_type', 'authorization_code');
        formBody.set('client_id', __classPrivateFieldGet(this, _MedplumClient_clientId, "f"));
        formBody.set('code', code);
        formBody.set('redirect_uri', getBaseUrl());
        const codeVerifier = sessionStorage.getItem('codeVerifier');
        if (codeVerifier) {
            formBody.set('code_verifier', codeVerifier);
        }
        return __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_fetchTokens).call(this, formBody);
    }
    /**
     * Starts a new OAuth2 client credentials flow.
     * See: https://datatracker.ietf.org/doc/html/rfc6749#section-4.4
     * @category Authentication
     * @param clientId The client ID.
     * @param clientSecret The client secret.
     * @returns Promise that resolves to the client profile.
     */
    async startClientLogin(clientId, clientSecret) {
        __classPrivateFieldSet(this, _MedplumClient_clientId, clientId, "f");
        __classPrivateFieldSet(this, _MedplumClient_clientSecret, clientSecret, "f");
        const formBody = new URLSearchParams();
        formBody.set('grant_type', 'client_credentials');
        formBody.set('client_id', clientId);
        formBody.set('client_secret', clientSecret);
        return __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_fetchTokens).call(this, formBody);
    }
}
_MedplumClient_fetch = new WeakMap(), _MedplumClient_createPdf = new WeakMap(), _MedplumClient_storage = new WeakMap(), _MedplumClient_requestCache = new WeakMap(), _MedplumClient_cacheTime = new WeakMap(), _MedplumClient_baseUrl = new WeakMap(), _MedplumClient_authorizeUrl = new WeakMap(), _MedplumClient_tokenUrl = new WeakMap(), _MedplumClient_logoutUrl = new WeakMap(), _MedplumClient_onUnauthenticated = new WeakMap(), _MedplumClient_clientId = new WeakMap(), _MedplumClient_clientSecret = new WeakMap(), _MedplumClient_accessToken = new WeakMap(), _MedplumClient_refreshToken = new WeakMap(), _MedplumClient_refreshPromise = new WeakMap(), _MedplumClient_profilePromise = new WeakMap(), _MedplumClient_profile = new WeakMap(), _MedplumClient_config = new WeakMap(), _MedplumClient_instances = new WeakSet(), _MedplumClient_addLogin = function _MedplumClient_addLogin(newLogin) {
    const logins = this.getLogins().filter((login) => login.profile?.reference !== newLogin.profile?.reference);
    logins.push(newLogin);
    __classPrivateFieldGet(this, _MedplumClient_storage, "f").setObject('logins', logins);
}, _MedplumClient_refreshProfile = async function _MedplumClient_refreshProfile() {
    __classPrivateFieldSet(this, _MedplumClient_profilePromise, new Promise((resolve, reject) => {
        this.get('auth/me')
            .then((result) => {
            __classPrivateFieldSet(this, _MedplumClient_profilePromise, undefined, "f");
            __classPrivateFieldSet(this, _MedplumClient_profile, result.profile, "f");
            __classPrivateFieldSet(this, _MedplumClient_config, result.config, "f");
            this.dispatchEvent({ type: 'change' });
            resolve(__classPrivateFieldGet(this, _MedplumClient_profile, "f"));
        })
            .catch(reject);
    }), "f");
    return __classPrivateFieldGet(this, _MedplumClient_profilePromise, "f");
}, _MedplumClient_getCacheEntry = function _MedplumClient_getCacheEntry(key, options) {
    if (__classPrivateFieldGet(this, _MedplumClient_cacheTime, "f") <= 0 || options?.cache === 'no-cache' || options?.cache === 'reload') {
        return undefined;
    }
    const entry = __classPrivateFieldGet(this, _MedplumClient_requestCache, "f").get(key);
    if (!entry || entry.requestTime + __classPrivateFieldGet(this, _MedplumClient_cacheTime, "f") < Date.now()) {
        return undefined;
    }
    return entry;
}, _MedplumClient_setCacheEntry = function _MedplumClient_setCacheEntry(key, value) {
    if (__classPrivateFieldGet(this, _MedplumClient_cacheTime, "f") > 0) {
        __classPrivateFieldGet(this, _MedplumClient_requestCache, "f").set(key, { requestTime: Date.now(), value });
    }
}, _MedplumClient_request = 
/**
 * Makes an HTTP request.
 * @param {string} method
 * @param {string} url
 * @param {string=} contentType
 * @param {Object=} body
 */
async function _MedplumClient_request(method, url, options = {}) {
    if (__classPrivateFieldGet(this, _MedplumClient_refreshPromise, "f")) {
        await __classPrivateFieldGet(this, _MedplumClient_refreshPromise, "f");
    }
    if (!url.startsWith('http')) {
        url = __classPrivateFieldGet(this, _MedplumClient_baseUrl, "f") + url;
    }
    options.method = method;
    __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_addFetchOptionsDefaults).call(this, options);
    const response = await __classPrivateFieldGet(this, _MedplumClient_fetch, "f").call(this, url, options);
    if (response.status === 401) {
        // Refresh and try again
        return __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_handleUnauthenticated).call(this, method, url, options);
    }
    if (response.status === 204 || response.status === 304) {
        // No content or change
        return undefined;
    }
    const obj = await response.json();
    if (response.status >= 400) {
        throw obj;
    }
    return obj;
}, _MedplumClient_addFetchOptionsDefaults = function _MedplumClient_addFetchOptionsDefaults(options) {
    if (!options.headers) {
        options.headers = {};
    }
    const headers = options.headers;
    headers['X-Medplum'] = 'extended';
    if (!headers['Content-Type']) {
        headers['Content-Type'] = FHIR_CONTENT_TYPE;
    }
    if (__classPrivateFieldGet(this, _MedplumClient_accessToken, "f")) {
        headers['Authorization'] = 'Bearer ' + __classPrivateFieldGet(this, _MedplumClient_accessToken, "f");
    }
    if (!options.cache) {
        options.cache = 'no-cache';
    }
    if (!options.credentials) {
        options.credentials = 'include';
    }
}, _MedplumClient_setRequestContentType = function _MedplumClient_setRequestContentType(options, contentType) {
    if (!options.headers) {
        options.headers = {};
    }
    const headers = options.headers;
    headers['Content-Type'] = contentType;
}, _MedplumClient_setRequestBody = function _MedplumClient_setRequestBody(options, data) {
    if (typeof data === 'string' ||
        (typeof Blob !== 'undefined' && data instanceof Blob) ||
        (typeof File !== 'undefined' && data instanceof File) ||
        (typeof Uint8Array !== 'undefined' && data instanceof Uint8Array)) {
        options.body = data;
    }
    else if (data) {
        options.body = JSON.stringify(data);
    }
}, _MedplumClient_handleUnauthenticated = function _MedplumClient_handleUnauthenticated(method, url, options) {
    if (__classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_refresh).call(this)) {
        return __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_request).call(this, method, url, options);
    }
    this.clear();
    if (__classPrivateFieldGet(this, _MedplumClient_onUnauthenticated, "f")) {
        __classPrivateFieldGet(this, _MedplumClient_onUnauthenticated, "f").call(this);
    }
    return Promise.reject(new Error('Unauthenticated'));
}, _MedplumClient_requestAuthorization = 
/**
 * Redirects the user to the login screen for authorization.
 * Clears all auth state including local storage and session storage.
 * See: https://openid.net/specs/openid-connect-core-1_0.html#AuthorizationEndpoint
 */
async function _MedplumClient_requestAuthorization() {
    await this.startPkce();
    const url = new URL(__classPrivateFieldGet(this, _MedplumClient_authorizeUrl, "f"));
    url.searchParams.set('response_type', 'code');
    url.searchParams.set('state', sessionStorage.getItem('pkceState'));
    url.searchParams.set('client_id', __classPrivateFieldGet(this, _MedplumClient_clientId, "f"));
    url.searchParams.set('redirect_uri', getBaseUrl());
    url.searchParams.set('code_challenge_method', 'S256');
    url.searchParams.set('code_challenge', sessionStorage.getItem('codeChallenge'));
    window.location.assign(url.toString());
}, _MedplumClient_refresh = function _MedplumClient_refresh() {
    if (__classPrivateFieldGet(this, _MedplumClient_refreshPromise, "f")) {
        return __classPrivateFieldGet(this, _MedplumClient_refreshPromise, "f");
    }
    if (__classPrivateFieldGet(this, _MedplumClient_refreshToken, "f")) {
        const formBody = new URLSearchParams();
        formBody.set('grant_type', 'refresh_token');
        formBody.set('client_id', __classPrivateFieldGet(this, _MedplumClient_clientId, "f"));
        formBody.set('refresh_token', __classPrivateFieldGet(this, _MedplumClient_refreshToken, "f"));
        __classPrivateFieldSet(this, _MedplumClient_refreshPromise, __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_fetchTokens).call(this, formBody), "f");
        return __classPrivateFieldGet(this, _MedplumClient_refreshPromise, "f");
    }
    if (__classPrivateFieldGet(this, _MedplumClient_clientId, "f") && __classPrivateFieldGet(this, _MedplumClient_clientSecret, "f")) {
        __classPrivateFieldSet(this, _MedplumClient_refreshPromise, this.startClientLogin(__classPrivateFieldGet(this, _MedplumClient_clientId, "f"), __classPrivateFieldGet(this, _MedplumClient_clientSecret, "f")), "f");
        return __classPrivateFieldGet(this, _MedplumClient_refreshPromise, "f");
    }
    return undefined;
}, _MedplumClient_fetchTokens = 
/**
 * Makes a POST request to the tokens endpoint.
 * See: https://openid.net/specs/openid-connect-core-1_0.html#TokenEndpoint
 * @param formBody Token parameters in URL encoded format.
 */
async function _MedplumClient_fetchTokens(formBody) {
    return __classPrivateFieldGet(this, _MedplumClient_fetch, "f").call(this, __classPrivateFieldGet(this, _MedplumClient_tokenUrl, "f"), {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: formBody,
        credentials: 'include',
    })
        .then((response) => {
        if (!response.ok) {
            throw new Error('Failed to fetch tokens');
        }
        return response.json();
    })
        .then((tokens) => __classPrivateFieldGet(this, _MedplumClient_instances, "m", _MedplumClient_verifyTokens).call(this, tokens))
        .then(() => this.getProfile());
}, _MedplumClient_verifyTokens = 
/**
 * Verifies the tokens received from the auth server.
 * Validates the JWT against the JWKS.
 * See: https://openid.net/specs/openid-connect-core-1_0.html#TokenEndpoint
 * @param tokens
 */
async function _MedplumClient_verifyTokens(tokens) {
    const token = tokens.access_token;
    // Verify token has not expired
    const tokenPayload = parseJWTPayload(token);
    if (Date.now() >= tokenPayload.exp * 1000) {
        this.clear();
        throw new Error('Token expired');
    }
    // Verify app_client_id
    if (__classPrivateFieldGet(this, _MedplumClient_clientId, "f") && tokenPayload.client_id !== __classPrivateFieldGet(this, _MedplumClient_clientId, "f")) {
        this.clear();
        throw new Error('Token was not issued for this audience');
    }
    await this.setActiveLogin({
        accessToken: token,
        refreshToken: tokens.refresh_token,
        project: tokens.project,
        profile: tokens.profile,
    });
}, _MedplumClient_setupStorageListener = function _MedplumClient_setupStorageListener() {
    try {
        window.addEventListener('storage', (e) => {
            if (e.key === null || e.key === 'activeLogin') {
                // Storage events fire when different tabs make changes.
                // On storage clear (key === null) or activeLogin change (key === 'activeLogin')
                // Refresh the page to ensure the active login is up to date.
                window.location.reload();
            }
        });
    }
    catch (err) {
        // Silently ignore if this environment does not support storage events
    }
};
/**
 * Returns the base URL for the current page.
 * @category HTTP
 */
function getBaseUrl() {
    return window.location.protocol + '//' + window.location.host + '/';
}
function ensureTrailingSlash(url) {
    if (!url) {
        return url;
    }
    return url.endsWith('/') ? url : url + '/';
}

export { MEDPLUM_VERSION, MedplumClient };
//# sourceMappingURL=client.mjs.map
