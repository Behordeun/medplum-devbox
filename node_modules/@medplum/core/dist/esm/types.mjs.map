{"version":3,"file":"types.mjs","sources":["../../src/types.ts"],"sourcesContent":["import {\n  Bundle,\n  BundleEntry,\n  ElementDefinition,\n  Resource,\n  SearchParameter,\n  StructureDefinition,\n} from '@medplum/fhirtypes';\nimport baseSchema from './base-schema.json';\nimport { SearchParameterDetails } from './searchparams';\nimport { capitalize } from './utils';\n\nexport interface TypedValue {\n  readonly type: string;\n  readonly value: any;\n}\n\n/**\n * List of property types.\n * http://www.hl7.org/fhir/valueset-defined-types.html\n * The list here includes additions found from StructureDefinition resources.\n */\nexport enum PropertyType {\n  Address = 'Address',\n  Age = 'Age',\n  Annotation = 'Annotation',\n  Attachment = 'Attachment',\n  BackboneElement = 'BackboneElement',\n  CodeableConcept = 'CodeableConcept',\n  Coding = 'Coding',\n  ContactDetail = 'ContactDetail',\n  ContactPoint = 'ContactPoint',\n  Contributor = 'Contributor',\n  Count = 'Count',\n  DataRequirement = 'DataRequirement',\n  Distance = 'Distance',\n  Dosage = 'Dosage',\n  Duration = 'Duration',\n  Expression = 'Expression',\n  Extension = 'Extension',\n  HumanName = 'HumanName',\n  Identifier = 'Identifier',\n  MarketingStatus = 'MarketingStatus',\n  Meta = 'Meta',\n  Money = 'Money',\n  Narrative = 'Narrative',\n  ParameterDefinition = 'ParameterDefinition',\n  Period = 'Period',\n  Population = 'Population',\n  ProdCharacteristic = 'ProdCharacteristic',\n  ProductShelfLife = 'ProductShelfLife',\n  Quantity = 'Quantity',\n  Range = 'Range',\n  Ratio = 'Ratio',\n  Reference = 'Reference',\n  RelatedArtifact = 'RelatedArtifact',\n  SampledData = 'SampledData',\n  Signature = 'Signature',\n  SubstanceAmount = 'SubstanceAmount',\n  SystemString = 'http://hl7.org/fhirpath/System.String',\n  Timing = 'Timing',\n  TriggerDefinition = 'TriggerDefinition',\n  UsageContext = 'UsageContext',\n  base64Binary = 'base64Binary',\n  boolean = 'boolean',\n  canonical = 'canonical',\n  code = 'code',\n  date = 'date',\n  dateTime = 'dateTime',\n  decimal = 'decimal',\n  id = 'id',\n  instant = 'instant',\n  integer = 'integer',\n  markdown = 'markdown',\n  oid = 'oid',\n  positiveInt = 'positiveInt',\n  string = 'string',\n  time = 'time',\n  unsignedInt = 'unsignedInt',\n  uri = 'uri',\n  url = 'url',\n  uuid = 'uuid',\n}\n\n/**\n * An IndexedStructureDefinition is a lookup-optimized version of a StructureDefinition.\n *\n * StructureDefinition resources contain schema information for other resource types.\n * These schemas can be used to automatically generate user interface elements for\n * resources.\n *\n * However, a StructureDefinition resource is not optimized for realtime lookups.  All\n * resource types, sub types, and property definitions are stored in a flat array of\n * ElementDefinition objects.  Therefore, to lookup the schema for a property (i.e., \"Patient.name\")\n * requires a linear scan of all ElementDefinition objects\n *\n * A StructureDefinition resource contains information about one or more types.\n * For example, the \"Patient\" StructureDefinition includes \"Patient\", \"Patient_Contact\",\n * \"Patient_Communication\", and \"Patient_Link\".  This is inefficient.\n *\n * Instead, we create an indexed version of the StructureDefinition, called IndexedStructureDefinition.\n * In an IndexedStructureDefinition, retrieving a property definition is a hashtable lookup.\n *\n * The hierarchy is:\n *   IndexedStructureDefinition - top level for one resource type\n *   TypeSchema - one per resource type and all contained BackboneElements\n *   PropertySchema - one per property/field\n */\nexport interface IndexedStructureDefinition {\n  types: { [resourceType: string]: TypeSchema };\n}\n\n/**\n * An indexed TypeSchema.\n *\n * Example:  The IndexedStructureDefinition for \"Patient\" would include the following TypeSchemas:\n *   1) Patient\n *   2) Patient_Contact\n *   3) Patient_Communication\n *   4) Patient_Link\n */\nexport interface TypeSchema {\n  structureDefinition: StructureDefinition;\n  elementDefinition: ElementDefinition;\n  display: string;\n  properties: { [name: string]: ElementDefinition };\n  searchParams?: { [code: string]: SearchParameter };\n  searchParamsDetails?: { [code: string]: SearchParameterDetails };\n  description?: string;\n  parentType?: string;\n}\n\n/**\n * Creates a new empty IndexedStructureDefinition.\n * @returns The empty IndexedStructureDefinition.\n * @deprecated Use globalSchema\n */\nexport function createSchema(): IndexedStructureDefinition {\n  return { types: {} };\n}\n\nfunction createTypeSchema(\n  typeName: string,\n  structureDefinition: StructureDefinition,\n  elementDefinition: ElementDefinition\n): TypeSchema {\n  return {\n    structureDefinition,\n    elementDefinition,\n    display: typeName,\n    description: elementDefinition.definition,\n    properties: {},\n  };\n}\n\n/**\n * Indexes a bundle of StructureDefinitions for faster lookup.\n * @param bundle A FHIR bundle StructureDefinition resources.\n * @see {@link IndexedStructureDefinition} for more details on indexed StructureDefinitions.\n */\nexport function indexStructureDefinitionBundle(bundle: Bundle): void {\n  for (const entry of bundle.entry as BundleEntry[]) {\n    const resource = entry.resource as Resource;\n    if (resource.resourceType === 'StructureDefinition') {\n      indexStructureDefinition(resource);\n    }\n  }\n}\n\n/**\n * Indexes a StructureDefinition for fast lookup.\n * @param structureDefinition The original StructureDefinition.\n * @see {@link IndexedStructureDefinition} for more details on indexed StructureDefinitions.\n */\nexport function indexStructureDefinition(structureDefinition: StructureDefinition): void {\n  const typeName = structureDefinition.name;\n  if (!typeName) {\n    return;\n  }\n\n  const elements = structureDefinition.snapshot?.element;\n  if (elements) {\n    // First pass, build types\n    elements.forEach((element) => indexType(structureDefinition, element));\n\n    // Second pass, build properties\n    elements.forEach((element) => indexProperty(element));\n  }\n}\n\n/**\n * Indexes TypeSchema from an ElementDefinition.\n * In the common case, there will be many ElementDefinition instances per TypeSchema.\n * Only the first occurrence is saved.\n * @param structureDefinition The parent type structure definition.\n * @param elementDefinition The element definition.\n * @see {@link IndexedStructureDefinition} for more details on indexed StructureDefinitions.\n */\nfunction indexType(structureDefinition: StructureDefinition, elementDefinition: ElementDefinition): void {\n  const path = elementDefinition.path as string;\n  const typeCode = elementDefinition.type?.[0]?.code;\n  if (typeCode !== undefined && typeCode !== 'Element' && typeCode !== 'BackboneElement') {\n    return;\n  }\n  const parts = path.split('.');\n  const typeName = buildTypeName(parts);\n  globalSchema.types[typeName] = createTypeSchema(typeName, structureDefinition, elementDefinition);\n  globalSchema.types[typeName].parentType = buildTypeName(parts.slice(0, parts.length - 1));\n}\n\n/**\n * Indexes PropertySchema from an ElementDefinition.\n * @param element The input ElementDefinition.\n * @see {@link IndexedStructureDefinition} for more details on indexed StructureDefinitions.\n */\nfunction indexProperty(element: ElementDefinition): void {\n  const path = element.path as string;\n  const parts = path.split('.');\n  if (parts.length === 1) {\n    return;\n  }\n  const typeName = buildTypeName(parts.slice(0, parts.length - 1));\n  const typeSchema = globalSchema.types[typeName];\n  if (!typeSchema) {\n    return;\n  }\n  const key = parts[parts.length - 1];\n  typeSchema.properties[key] = element;\n}\n\n/**\n * Indexes a bundle of SearchParameter resources for faster lookup.\n * @param bundle A FHIR bundle SearchParameter resources.\n * @see {@link IndexedStructureDefinition} for more details on indexed StructureDefinitions.\n */\nexport function indexSearchParameterBundle(bundle: Bundle<SearchParameter>): void {\n  for (const entry of bundle.entry as BundleEntry[]) {\n    const resource = entry.resource as SearchParameter;\n    if (resource.resourceType === 'SearchParameter') {\n      indexSearchParameter(resource);\n    }\n  }\n}\n\n/**\n * Indexes a SearchParameter resource for fast lookup.\n * Indexes by SearchParameter.code, which is the query string parameter name.\n * @param searchParam The SearchParameter resource.\n * @see {@link IndexedStructureDefinition} for more details on indexed StructureDefinitions.\n */\nexport function indexSearchParameter(searchParam: SearchParameter): void {\n  if (!searchParam.base) {\n    return;\n  }\n\n  for (const resourceType of searchParam.base) {\n    const typeSchema = globalSchema.types[resourceType];\n    if (!typeSchema) {\n      continue;\n    }\n\n    if (!typeSchema.searchParams) {\n      typeSchema.searchParams = {\n        _id: {\n          base: [resourceType],\n          code: '_id',\n          type: 'token',\n          expression: resourceType + '.id',\n        } as SearchParameter,\n        _lastUpdated: {\n          base: [resourceType],\n          code: '_lastUpdated',\n          type: 'date',\n          expression: resourceType + '.meta.lastUpdated',\n        } as SearchParameter,\n        _compartment: {\n          base: [resourceType],\n          code: '_compartment',\n          type: 'reference',\n          expression: resourceType + '.meta.compartment',\n        } as SearchParameter,\n      };\n    }\n\n    typeSchema.searchParams[searchParam.code as string] = searchParam;\n  }\n}\n\nexport function buildTypeName(components: string[]): string {\n  if (components.length === 1) {\n    return components[0];\n  }\n  return components.map(capitalize).join('');\n}\n\nexport function getPropertyDisplayName(path: string): string {\n  // Get the property name, which is the remainder after the last period\n  // For example, for path \"Patient.birthDate\"\n  // the property name is \"birthDate\"\n  const propertyName = path.replaceAll('[x]', '').split('.').pop() as string;\n\n  // Special case for ID\n  if (propertyName === 'id') {\n    return 'ID';\n  }\n\n  // Split by capital letters\n  // Capitalize the first letter of each word\n  // Join together with spaces in between\n  // Then normalize whitespace to single space character\n  // For example, for property name \"birthDate\",\n  // the display name is \"Birth Date\".\n  return propertyName\n    .split(/(?=[A-Z])/)\n    .map(capitalize)\n    .join(' ')\n    .replace('_', ' ')\n    .replace(/\\s+/g, ' ');\n}\n\n/**\n * Returns an element definition by type and property name.\n * Handles content references.\n * @param typeName The type name.\n * @param propertyName The property name.\n * @returns The element definition if found.\n */\nexport function getElementDefinition(typeName: string, propertyName: string): ElementDefinition | undefined {\n  const typeSchema = globalSchema.types[typeName];\n  if (!typeSchema) {\n    return undefined;\n  }\n\n  const property = typeSchema.properties[propertyName] ?? typeSchema.properties[propertyName + '[x]'];\n  if (!property) {\n    return undefined;\n  }\n\n  if (property.contentReference) {\n    // Content references start with a \"#\"\n    // Remove the \"#\" character\n    const contentReference = property.contentReference.substring(1).split('.');\n    const referencePropertyName = contentReference.pop() as string;\n    const referenceTypeName = buildTypeName(contentReference);\n    return getElementDefinition(referenceTypeName, referencePropertyName);\n  }\n\n  return property;\n}\n\n/**\n * Global schema singleton.\n */\nexport const globalSchema = baseSchema as unknown as IndexedStructureDefinition;\n"],"names":[],"mappings":"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"}