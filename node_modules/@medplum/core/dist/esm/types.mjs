import baseSchema from './base-schema.json.mjs';
import { capitalize } from './utils.mjs';

/**
 * List of property types.
 * http://www.hl7.org/fhir/valueset-defined-types.html
 * The list here includes additions found from StructureDefinition resources.
 */
var PropertyType;
(function (PropertyType) {
    PropertyType["Address"] = "Address";
    PropertyType["Age"] = "Age";
    PropertyType["Annotation"] = "Annotation";
    PropertyType["Attachment"] = "Attachment";
    PropertyType["BackboneElement"] = "BackboneElement";
    PropertyType["CodeableConcept"] = "CodeableConcept";
    PropertyType["Coding"] = "Coding";
    PropertyType["ContactDetail"] = "ContactDetail";
    PropertyType["ContactPoint"] = "ContactPoint";
    PropertyType["Contributor"] = "Contributor";
    PropertyType["Count"] = "Count";
    PropertyType["DataRequirement"] = "DataRequirement";
    PropertyType["Distance"] = "Distance";
    PropertyType["Dosage"] = "Dosage";
    PropertyType["Duration"] = "Duration";
    PropertyType["Expression"] = "Expression";
    PropertyType["Extension"] = "Extension";
    PropertyType["HumanName"] = "HumanName";
    PropertyType["Identifier"] = "Identifier";
    PropertyType["MarketingStatus"] = "MarketingStatus";
    PropertyType["Meta"] = "Meta";
    PropertyType["Money"] = "Money";
    PropertyType["Narrative"] = "Narrative";
    PropertyType["ParameterDefinition"] = "ParameterDefinition";
    PropertyType["Period"] = "Period";
    PropertyType["Population"] = "Population";
    PropertyType["ProdCharacteristic"] = "ProdCharacteristic";
    PropertyType["ProductShelfLife"] = "ProductShelfLife";
    PropertyType["Quantity"] = "Quantity";
    PropertyType["Range"] = "Range";
    PropertyType["Ratio"] = "Ratio";
    PropertyType["Reference"] = "Reference";
    PropertyType["RelatedArtifact"] = "RelatedArtifact";
    PropertyType["SampledData"] = "SampledData";
    PropertyType["Signature"] = "Signature";
    PropertyType["SubstanceAmount"] = "SubstanceAmount";
    PropertyType["SystemString"] = "http://hl7.org/fhirpath/System.String";
    PropertyType["Timing"] = "Timing";
    PropertyType["TriggerDefinition"] = "TriggerDefinition";
    PropertyType["UsageContext"] = "UsageContext";
    PropertyType["base64Binary"] = "base64Binary";
    PropertyType["boolean"] = "boolean";
    PropertyType["canonical"] = "canonical";
    PropertyType["code"] = "code";
    PropertyType["date"] = "date";
    PropertyType["dateTime"] = "dateTime";
    PropertyType["decimal"] = "decimal";
    PropertyType["id"] = "id";
    PropertyType["instant"] = "instant";
    PropertyType["integer"] = "integer";
    PropertyType["markdown"] = "markdown";
    PropertyType["oid"] = "oid";
    PropertyType["positiveInt"] = "positiveInt";
    PropertyType["string"] = "string";
    PropertyType["time"] = "time";
    PropertyType["unsignedInt"] = "unsignedInt";
    PropertyType["uri"] = "uri";
    PropertyType["url"] = "url";
    PropertyType["uuid"] = "uuid";
})(PropertyType || (PropertyType = {}));
/**
 * Creates a new empty IndexedStructureDefinition.
 * @returns The empty IndexedStructureDefinition.
 * @deprecated Use globalSchema
 */
function createSchema() {
    return { types: {} };
}
function createTypeSchema(typeName, structureDefinition, elementDefinition) {
    return {
        structureDefinition,
        elementDefinition,
        display: typeName,
        description: elementDefinition.definition,
        properties: {},
    };
}
/**
 * Indexes a bundle of StructureDefinitions for faster lookup.
 * @param bundle A FHIR bundle StructureDefinition resources.
 * @see {@link IndexedStructureDefinition} for more details on indexed StructureDefinitions.
 */
function indexStructureDefinitionBundle(bundle) {
    for (const entry of bundle.entry) {
        const resource = entry.resource;
        if (resource.resourceType === 'StructureDefinition') {
            indexStructureDefinition(resource);
        }
    }
}
/**
 * Indexes a StructureDefinition for fast lookup.
 * @param structureDefinition The original StructureDefinition.
 * @see {@link IndexedStructureDefinition} for more details on indexed StructureDefinitions.
 */
function indexStructureDefinition(structureDefinition) {
    const typeName = structureDefinition.name;
    if (!typeName) {
        return;
    }
    const elements = structureDefinition.snapshot?.element;
    if (elements) {
        // First pass, build types
        elements.forEach((element) => indexType(structureDefinition, element));
        // Second pass, build properties
        elements.forEach((element) => indexProperty(element));
    }
}
/**
 * Indexes TypeSchema from an ElementDefinition.
 * In the common case, there will be many ElementDefinition instances per TypeSchema.
 * Only the first occurrence is saved.
 * @param structureDefinition The parent type structure definition.
 * @param elementDefinition The element definition.
 * @see {@link IndexedStructureDefinition} for more details on indexed StructureDefinitions.
 */
function indexType(structureDefinition, elementDefinition) {
    const path = elementDefinition.path;
    const typeCode = elementDefinition.type?.[0]?.code;
    if (typeCode !== undefined && typeCode !== 'Element' && typeCode !== 'BackboneElement') {
        return;
    }
    const parts = path.split('.');
    const typeName = buildTypeName(parts);
    globalSchema.types[typeName] = createTypeSchema(typeName, structureDefinition, elementDefinition);
    globalSchema.types[typeName].parentType = buildTypeName(parts.slice(0, parts.length - 1));
}
/**
 * Indexes PropertySchema from an ElementDefinition.
 * @param element The input ElementDefinition.
 * @see {@link IndexedStructureDefinition} for more details on indexed StructureDefinitions.
 */
function indexProperty(element) {
    const path = element.path;
    const parts = path.split('.');
    if (parts.length === 1) {
        return;
    }
    const typeName = buildTypeName(parts.slice(0, parts.length - 1));
    const typeSchema = globalSchema.types[typeName];
    if (!typeSchema) {
        return;
    }
    const key = parts[parts.length - 1];
    typeSchema.properties[key] = element;
}
/**
 * Indexes a bundle of SearchParameter resources for faster lookup.
 * @param bundle A FHIR bundle SearchParameter resources.
 * @see {@link IndexedStructureDefinition} for more details on indexed StructureDefinitions.
 */
function indexSearchParameterBundle(bundle) {
    for (const entry of bundle.entry) {
        const resource = entry.resource;
        if (resource.resourceType === 'SearchParameter') {
            indexSearchParameter(resource);
        }
    }
}
/**
 * Indexes a SearchParameter resource for fast lookup.
 * Indexes by SearchParameter.code, which is the query string parameter name.
 * @param searchParam The SearchParameter resource.
 * @see {@link IndexedStructureDefinition} for more details on indexed StructureDefinitions.
 */
function indexSearchParameter(searchParam) {
    if (!searchParam.base) {
        return;
    }
    for (const resourceType of searchParam.base) {
        const typeSchema = globalSchema.types[resourceType];
        if (!typeSchema) {
            continue;
        }
        if (!typeSchema.searchParams) {
            typeSchema.searchParams = {
                _id: {
                    base: [resourceType],
                    code: '_id',
                    type: 'token',
                    expression: resourceType + '.id',
                },
                _lastUpdated: {
                    base: [resourceType],
                    code: '_lastUpdated',
                    type: 'date',
                    expression: resourceType + '.meta.lastUpdated',
                },
                _compartment: {
                    base: [resourceType],
                    code: '_compartment',
                    type: 'reference',
                    expression: resourceType + '.meta.compartment',
                },
            };
        }
        typeSchema.searchParams[searchParam.code] = searchParam;
    }
}
function buildTypeName(components) {
    if (components.length === 1) {
        return components[0];
    }
    return components.map(capitalize).join('');
}
function getPropertyDisplayName(path) {
    // Get the property name, which is the remainder after the last period
    // For example, for path "Patient.birthDate"
    // the property name is "birthDate"
    const propertyName = path.replaceAll('[x]', '').split('.').pop();
    // Special case for ID
    if (propertyName === 'id') {
        return 'ID';
    }
    // Split by capital letters
    // Capitalize the first letter of each word
    // Join together with spaces in between
    // Then normalize whitespace to single space character
    // For example, for property name "birthDate",
    // the display name is "Birth Date".
    return propertyName
        .split(/(?=[A-Z])/)
        .map(capitalize)
        .join(' ')
        .replace('_', ' ')
        .replace(/\s+/g, ' ');
}
/**
 * Returns an element definition by type and property name.
 * Handles content references.
 * @param typeName The type name.
 * @param propertyName The property name.
 * @returns The element definition if found.
 */
function getElementDefinition(typeName, propertyName) {
    const typeSchema = globalSchema.types[typeName];
    if (!typeSchema) {
        return undefined;
    }
    const property = typeSchema.properties[propertyName] ?? typeSchema.properties[propertyName + '[x]'];
    if (!property) {
        return undefined;
    }
    if (property.contentReference) {
        // Content references start with a "#"
        // Remove the "#" character
        const contentReference = property.contentReference.substring(1).split('.');
        const referencePropertyName = contentReference.pop();
        const referenceTypeName = buildTypeName(contentReference);
        return getElementDefinition(referenceTypeName, referencePropertyName);
    }
    return property;
}
/**
 * Global schema singleton.
 */
const globalSchema = baseSchema;

export { PropertyType, buildTypeName, createSchema, getElementDefinition, getPropertyDisplayName, globalSchema, indexSearchParameter, indexSearchParameterBundle, indexStructureDefinition, indexStructureDefinitionBundle };
//# sourceMappingURL=types.mjs.map
