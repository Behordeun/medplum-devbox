import { createStyles, Center, Loader, Group, Button, Text, Table, Menu, UnstyledButton, Pagination } from '@mantine/core';
import { formatSearchQuery, globalSchema, DEFAULT_SEARCH_COUNT } from '@medplum/core';
import { IconFilter, IconColumns, IconFilePlus, IconTableExport, IconTrash, IconBoxMultiple, IconAdjustmentsHorizontal } from '@tabler/icons';
import React, { useState, useRef, useEffect } from 'react';
import { Container } from '../Container/Container.mjs';
import { useMedplum } from '../MedplumProvider/MedplumProvider.mjs';
import { SearchFieldEditor } from '../SearchFieldEditor/SearchFieldEditor.mjs';
import { SearchFilterEditor } from '../SearchFilterEditor/SearchFilterEditor.mjs';
import { SearchFilterValueDialog } from '../SearchFilterValueDialog/SearchFilterValueDialog.mjs';
import { SearchFilterValueDisplay } from '../SearchFilterValueDisplay/SearchFilterValueDisplay.mjs';
import { SearchPopupMenu } from '../SearchPopupMenu/SearchPopupMenu.mjs';
import { isCheckboxCell, killEvent } from '../utils/dom.mjs';
import { getFieldDefinitions } from './SearchControlField.mjs';
import { buildFieldNameString, renderValue, setPage, addFilter, getOpString } from './SearchUtils.mjs';

class SearchChangeEvent extends Event {
    constructor(definition) {
        super('change');
        this.definition = definition;
    }
}
class SearchLoadEvent extends Event {
    constructor(response) {
        super('load');
        this.response = response;
    }
}
class SearchClickEvent extends Event {
    constructor(resource, browserEvent) {
        super('click');
        this.resource = resource;
        this.browserEvent = browserEvent;
    }
}
const useStyles = createStyles((theme) => ({
    root: {
        maxWidth: '100%',
        overflow: 'auto',
        textAlign: 'left',
        marginBottom: '20px',
    },
    table: {
        cursor: 'pointer',
    },
    tr: {
        '&:hover': {
            backgroundColor: theme.colorScheme === 'dark' ? theme.colors.dark[7] : theme.colors.gray[0],
        },
    },
    th: {
        padding: '0 !important',
    },
    control: {
        width: '100%',
        padding: `${theme.spacing.xs}px ${theme.spacing.md}px`,
        '&:hover': {
            backgroundColor: theme.colorScheme === 'dark' ? theme.colors.dark[6] : theme.colors.gray[0],
        },
    },
    icon: {
        width: 21,
        height: 21,
        borderRadius: 21,
    },
}));
/**
 * The SearchControl component represents the embeddable search table control.
 * It includes the table, rows, headers, sorting, etc.
 * It does not include the field editor, filter editor, pagination buttons.
 */
function SearchControl(props) {
    const { classes } = useStyles();
    const medplum = useMedplum();
    const [schemaLoaded, setSchemaLoaded] = useState(false);
    const [outcome, setOutcome] = useState();
    const { search, onLoad } = props;
    const [state, setState] = useState({
        selected: {},
        fieldEditorVisible: false,
        filterEditorVisible: false,
        filterDialogVisible: false,
    });
    const stateRef = useRef(state);
    stateRef.current = state;
    useEffect(() => {
        setOutcome(undefined);
        medplum
            .search(search.resourceType, formatSearchQuery({ ...search, total: 'accurate', fields: undefined }))
            .then((response) => {
            setState({ ...stateRef.current, searchResponse: response });
            if (onLoad) {
                onLoad(new SearchLoadEvent(response));
            }
        })
            .catch((reason) => {
            setState({ ...stateRef.current, searchResponse: undefined });
            setOutcome(reason);
        });
    }, [medplum, search, onLoad]);
    function handleSingleCheckboxClick(e, id) {
        e.stopPropagation();
        const el = e.target;
        const checked = el.checked;
        const newSelected = { ...stateRef.current.selected };
        if (checked) {
            newSelected[id] = true;
        }
        else {
            delete newSelected[id];
        }
        setState({ ...stateRef.current, selected: newSelected });
    }
    function handleAllCheckboxClick(e) {
        e.stopPropagation();
        const el = e.target;
        const checked = el.checked;
        const newSelected = {};
        const searchResponse = stateRef.current?.searchResponse;
        if (checked && searchResponse?.entry) {
            searchResponse.entry.forEach((entry) => {
                if (entry.resource?.id) {
                    newSelected[entry.resource.id] = true;
                }
            });
        }
        setState({ ...stateRef.current, selected: newSelected });
    }
    function isAllSelected() {
        const state = stateRef.current;
        if (!state.searchResponse?.entry || state.searchResponse.entry.length === 0) {
            return false;
        }
        for (const e of state.searchResponse.entry) {
            if (e.resource?.id && !state.selected[e.resource.id]) {
                return false;
            }
        }
        return true;
    }
    /**
     * Emits a change event to the optional change listener.
     * @param newSearch The new search definition.
     */
    function emitSearchChange(newSearch) {
        if (props.onChange) {
            props.onChange(new SearchChangeEvent(newSearch));
        }
    }
    /**
     * Handles a click on a order row.
     *
     * @param e The click event.
     * @param resource The FHIR resource.
     */
    function handleRowClick(e, resource) {
        if (isCheckboxCell(e.target)) {
            // Ignore clicks on checkboxes
            return;
        }
        if (e.button === 2) {
            // Ignore right clicks
            return;
        }
        killEvent(e);
        if (e.button !== 1 && props.onClick) {
            props.onClick(new SearchClickEvent(resource, e));
        }
        if (e.button === 1 && props.onAuxClick) {
            props.onAuxClick(new SearchClickEvent(resource, e));
        }
    }
    useEffect(() => {
        setSchemaLoaded(false);
        medplum
            .requestSchema(props.search.resourceType)
            .then(() => setSchemaLoaded(true))
            .catch(console.log);
    }, [medplum, props.search.resourceType]);
    const typeSchema = schemaLoaded && globalSchema?.types?.[props.search.resourceType];
    if (!typeSchema) {
        return (React.createElement(Center, { style: { width: '100%', height: '100%' } },
            React.createElement(Loader, null)));
    }
    const checkboxColumn = props.checkboxesEnabled;
    const fields = getFieldDefinitions(search);
    const resourceType = search.resourceType;
    const lastResult = state.searchResponse;
    const entries = lastResult?.entry;
    const resources = entries?.map((e) => e.resource);
    const buttonVariant = 'subtle';
    const buttonColor = 'gray';
    const iconSize = 16;
    const isMobile = window.innerWidth < 768;
    return (React.createElement("div", { className: classes.root, "data-testid": "search-control" },
        !props.hideToolbar && (React.createElement(Group, { position: "apart", mb: "xl" },
            React.createElement(Group, { spacing: 2 },
                React.createElement(Button, { compact: true, variant: buttonVariant, color: buttonColor, leftIcon: React.createElement(IconFilter, { size: iconSize }), onClick: () => setState({ ...stateRef.current, fieldEditorVisible: true }) }, "Fields"),
                React.createElement(Button, { compact: true, variant: buttonVariant, color: buttonColor, leftIcon: React.createElement(IconColumns, { size: iconSize }), onClick: () => setState({ ...stateRef.current, filterEditorVisible: true }) }, "Filters"),
                props.onNew && (React.createElement(Button, { compact: true, variant: buttonVariant, color: buttonColor, leftIcon: React.createElement(IconFilePlus, { size: iconSize }), onClick: props.onNew }, "New...")),
                !isMobile && props.onExport && (React.createElement(Button, { compact: true, variant: buttonVariant, color: buttonColor, leftIcon: React.createElement(IconTableExport, { size: iconSize }), onClick: props.onExport }, "Export...")),
                !isMobile && props.onDelete && (React.createElement(Button, { compact: true, variant: buttonVariant, color: buttonColor, leftIcon: React.createElement(IconTrash, { size: iconSize }), onClick: () => props.onDelete(Object.keys(state.selected)) }, "Delete...")),
                !isMobile && props.onBulk && (React.createElement(Button, { compact: true, variant: buttonVariant, color: buttonColor, leftIcon: React.createElement(IconBoxMultiple, { size: iconSize }), onClick: () => props.onBulk(Object.keys(state.selected)) }, "Bulk..."))),
            lastResult && (React.createElement(Text, { size: "xs", color: "dimmed" },
                getStart(search, lastResult.total),
                "-",
                getEnd(search, lastResult.total),
                " of",
                ' ',
                lastResult.total?.toLocaleString())))),
        React.createElement(Table, { className: classes.table },
            React.createElement("thead", null,
                React.createElement("tr", null,
                    checkboxColumn && (React.createElement("th", null,
                        React.createElement("input", { type: "checkbox", value: "checked", "aria-label": "all-checkbox", "data-testid": "all-checkbox", checked: isAllSelected(), onChange: (e) => handleAllCheckboxClick(e) }))),
                    fields.map((field) => (React.createElement("th", { key: field.name },
                        React.createElement(Menu, { shadow: "md", width: 240, position: "bottom-end" },
                            React.createElement(Menu.Target, null,
                                React.createElement(UnstyledButton, { className: classes.control },
                                    React.createElement(Group, { position: "apart", noWrap: true },
                                        React.createElement(Text, { weight: 500, size: "sm" }, buildFieldNameString(field.name)),
                                        React.createElement(Center, { className: classes.icon },
                                            React.createElement(IconAdjustmentsHorizontal, { size: 14, stroke: 1.5 }))))),
                            React.createElement(SearchPopupMenu, { search: props.search, searchParams: field.searchParams, onPrompt: (searchParam, filter) => {
                                    setState({
                                        ...stateRef.current,
                                        filterDialogVisible: true,
                                        filterDialogSearchParam: searchParam,
                                        filterDialogFilter: filter,
                                    });
                                }, onChange: (result) => {
                                    emitSearchChange(result);
                                } })))))),
                !props.hideFilters && (React.createElement("tr", null,
                    checkboxColumn && React.createElement("th", null),
                    fields.map((field) => (React.createElement("th", { key: field.name }, field.searchParams && (React.createElement(FilterDescription, { resourceType: resourceType, searchParams: field.searchParams, filters: props.search.filters })))))))),
            React.createElement("tbody", null, resources?.map((resource) => resource && (React.createElement("tr", { key: resource.id, className: classes.tr, "data-testid": "search-control-row", onClick: (e) => handleRowClick(e, resource), onAuxClick: (e) => handleRowClick(e, resource) },
                checkboxColumn && (React.createElement("td", null,
                    React.createElement("input", { type: "checkbox", value: "checked", "data-testid": "row-checkbox", "aria-label": `Checkbox for ${resource.id}`, checked: !!state.selected[resource.id], onChange: (e) => handleSingleCheckboxClick(e, resource.id) }))),
                fields.map((field) => (React.createElement("td", { key: field.name }, renderValue(resource, field))))))))),
        resources?.length === 0 && (React.createElement(Container, null,
            React.createElement(Center, null,
                React.createElement(Text, { size: "xl", color: "dimmed" }, "No results")))),
        lastResult?.total !== undefined && lastResult.total > 0 && (React.createElement(Center, { m: "md", p: "md" },
            React.createElement(Pagination, { page: getPage(search), total: getTotalPages(search, lastResult.total), onChange: (newPage) => emitSearchChange(setPage(search, newPage)), getItemAriaLabel: (page) => {
                    switch (page) {
                        case 'prev':
                            return 'Previous page';
                        case 'next':
                            return 'Next page';
                        default:
                            return undefined;
                    }
                } }))),
        outcome && (React.createElement("div", { "data-testid": "search-error" },
            React.createElement("pre", { style: { textAlign: 'left' } }, JSON.stringify(outcome, undefined, 2)))),
        React.createElement(SearchFieldEditor, { search: props.search, visible: stateRef.current.fieldEditorVisible, onOk: (result) => {
                emitSearchChange(result);
                setState({
                    ...stateRef.current,
                    fieldEditorVisible: false,
                });
            }, onCancel: () => {
                setState({
                    ...stateRef.current,
                    fieldEditorVisible: false,
                });
            } }),
        React.createElement(SearchFilterEditor, { search: props.search, visible: stateRef.current.filterEditorVisible, onOk: (result) => {
                emitSearchChange(result);
                setState({
                    ...stateRef.current,
                    filterEditorVisible: false,
                });
            }, onCancel: () => {
                setState({
                    ...stateRef.current,
                    filterEditorVisible: false,
                });
            } }),
        React.createElement(SearchFilterValueDialog, { key: state.filterDialogSearchParam?.code, visible: stateRef.current.filterDialogVisible, title: 'Input', resourceType: resourceType, searchParam: state.filterDialogSearchParam, filter: state.filterDialogFilter, defaultValue: '', onOk: (filter) => {
                emitSearchChange(addFilter(props.search, filter.code, filter.operator, filter.value));
                setState({
                    ...stateRef.current,
                    filterDialogVisible: false,
                });
            }, onCancel: () => {
                setState({
                    ...stateRef.current,
                    filterDialogVisible: false,
                });
            } })));
}
const MemoizedSearchControl = React.memo(SearchControl);
function FilterDescription(props) {
    const filters = (props.filters ?? []).filter((f) => props.searchParams.find((p) => p.code === f.code));
    if (filters.length === 0) {
        return React.createElement("span", null, "no filters");
    }
    return (React.createElement(React.Fragment, null, filters.map((filter, index) => (React.createElement("div", { key: `filter-${index}-${filters.length}` },
        getOpString(filter.operator),
        "\u00A0",
        React.createElement(SearchFilterValueDisplay, { resourceType: props.resourceType, filter: filter }))))));
}
function getPage(search) {
    return Math.floor((search.offset || 0) / (search.count || DEFAULT_SEARCH_COUNT)) + 1;
}
function getTotalPages(search, total) {
    const pageSize = search.count || DEFAULT_SEARCH_COUNT;
    return Math.ceil(total / pageSize);
}
function getStart(search, total) {
    return Math.min(total, (search.offset ?? 0) + 1);
}
function getEnd(search, total) {
    return Math.min(total, ((search.offset ?? 0) + 1) * (search.count ?? DEFAULT_SEARCH_COUNT));
}

export { MemoizedSearchControl, SearchChangeEvent, SearchClickEvent, SearchControl, SearchLoadEvent };
//# sourceMappingURL=SearchControl.mjs.map
