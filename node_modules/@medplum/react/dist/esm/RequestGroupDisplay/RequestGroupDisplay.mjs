import { Grid, Text, Button } from '@mantine/core';
import { formatDateTime, getReferenceString } from '@medplum/core';
import { IconCheckbox, IconSquare } from '@tabler/icons';
import React, { useState, useEffect } from 'react';
import { useMedplum } from '../MedplumProvider/MedplumProvider.mjs';
import { ResourceName } from '../ResourceName/ResourceName.mjs';
import { StatusBadge } from '../StatusBadge/StatusBadge.mjs';
import { useResource } from '../useResource/useResource.mjs';

function RequestGroupDisplay(props) {
    const medplum = useMedplum();
    const requestGroup = useResource(props.value);
    const [startedLoading, setStartedLoading] = useState(false);
    const [responseBundle, setResponseBundle] = useState();
    useEffect(() => {
        if (requestGroup && !startedLoading) {
            medplum.executeBatch(buildBatchRequest(requestGroup)).then(setResponseBundle).catch(console.log);
            setStartedLoading(true);
        }
    }, [medplum, requestGroup, startedLoading]);
    if (!requestGroup || !responseBundle) {
        return null;
    }
    return (React.createElement(Grid, null, requestGroup.action?.map((action, index) => {
        const task = action.resource && findBundleEntry(action.resource);
        const taskInput = task?.input?.[0]?.valueReference;
        const taskOutput = task?.output?.[0]?.valueReference;
        return (React.createElement(React.Fragment, { key: `action-${index}` },
            React.createElement(Grid.Col, { span: 1, p: "md" }, task?.status === 'completed' ? React.createElement(IconCheckbox, null) : React.createElement(IconSquare, { color: "gray" })),
            React.createElement(Grid.Col, { span: 9, p: "xs" },
                React.createElement(Text, { weight: 500 }, action.title),
                action.description && React.createElement("div", null, action.description),
                React.createElement("div", null,
                    "Last edited by\u00A0",
                    React.createElement(ResourceName, { value: task?.meta?.author }),
                    "\u00A0on\u00A0",
                    formatDateTime(task?.meta?.lastUpdated)),
                React.createElement("div", null,
                    "Status: ",
                    React.createElement(StatusBadge, { status: task?.status || 'unknown' }))),
            React.createElement(Grid.Col, { span: 2, p: "md" },
                taskInput && !taskOutput && React.createElement(Button, { onClick: () => props.onStart(task, taskInput) }, "Start"),
                taskInput && taskOutput && (React.createElement(Button, { onClick: () => props.onEdit(task, taskInput, taskOutput) }, "Edit")))));
    })));
    function buildBatchRequest(request) {
        const batchEntries = [];
        if (request.action) {
            for (const action of request.action) {
                if (action.resource?.reference) {
                    batchEntries.push({ request: { method: 'GET', url: action.resource.reference } });
                }
            }
        }
        return {
            resourceType: 'Bundle',
            type: 'batch',
            entry: batchEntries,
        };
    }
    function findBundleEntry(reference) {
        for (const entry of responseBundle?.entry) {
            if (entry.resource && reference.reference === getReferenceString(entry.resource)) {
                return entry.resource;
            }
        }
        return undefined;
    }
}

export { RequestGroupDisplay };
//# sourceMappingURL=RequestGroupDisplay.mjs.map
