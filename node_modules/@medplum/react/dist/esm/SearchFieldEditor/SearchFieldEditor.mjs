import { Modal, Button } from '@mantine/core';
import { stringify, globalSchema } from '@medplum/core';
import React, { useState, useRef, useEffect } from 'react';
import { buildFieldNameString } from '../SearchControl/SearchUtils.mjs';

function SearchFieldEditor(props) {
    const [state, setState] = useState({
        search: JSON.parse(stringify(props.search)),
    });
    const availableRef = useRef(null);
    const selectedRef = useRef(null);
    useEffect(() => {
        setState({ search: props.search });
    }, [props.search]);
    /**
     * Handles a key down event on the "available" field.
     * If the user presses enter, it is a shortcut for the "Add" button.
     *
     * @param {KeyboardEvent} e The keyboard event.
     */
    function handleAvailableKeyDown(e) {
        if (e.key === 'Enter') {
            onAddField();
        }
    }
    /**
     * Handles a double click on the "available" field.
     * If the user double clicks an entry, it is a shortcut for the "Add" button.
     */
    function handleAvailableDoubleClick() {
        onAddField();
    }
    /**
     * Handles a key down event on the "available" field.
     * If the user presses enter, it is a shortcut for the "Add" button.
     *
     * @param {KeyboardEvent} e The keyboard event.
     */
    function handleSelectedKeyDown(e) {
        if (e.key === 'Enter') {
            onRemoveField();
        }
    }
    /**
     * Handles a double click on the "available" field.
     * If the user double clicks an entry, it is a shortcut for the "Add" button.
     */
    function handleSelectedDoubleClick() {
        onRemoveField();
    }
    /**
     * Handles a click on the "Add" button.
     * Moves the "available" selection into the "selected" list.
     */
    function onAddField() {
        const currentField = state.search.fields ?? [];
        const key = availableRef.current?.value;
        if (key) {
            const newFields = [...currentField, key];
            setState({
                search: {
                    ...state.search,
                    fields: newFields,
                },
            });
        }
    }
    /**
     * Handles a click on the "Remove" button.
     * Moves the "selected" selection into the "available" list.
     */
    function onRemoveField() {
        const currentField = state.search.fields ?? [];
        const key = selectedRef.current?.value;
        if (key) {
            const newFields = [...currentField];
            newFields.splice(newFields.indexOf(key), 1);
            setState({
                search: {
                    ...state.search,
                    fields: newFields,
                },
            });
        }
    }
    /**
     * Handles a click on the "Up" button.
     * Moves the selection up one position in the list.
     */
    function onMoveUp() {
        const currentField = state.search.fields ?? [];
        const field = selectedRef.current?.value;
        if (field) {
            const newFields = [...currentField];
            const index = newFields.indexOf(field);
            swapFields(newFields, index, index - 1);
            setState({
                search: {
                    ...state.search,
                    fields: newFields,
                },
            });
        }
    }
    /**
     * Handles a click on the "Down" button.
     * Moves the selection down one position in the list.
     */
    function onMoveDown() {
        const currentField = state.search.fields ?? [];
        const field = selectedRef.current?.value;
        if (field) {
            const newFields = [...currentField];
            const index = newFields.indexOf(field);
            swapFields(newFields, index, index + 1);
            setState({
                search: {
                    ...state.search,
                    fields: newFields,
                },
            });
        }
    }
    /**
     * Swaps two fields in the search.
     *
     * @param {number} i The index of the first field.
     * @param {number} j The index of the second field.
     */
    function swapFields(fields, i, j) {
        const temp = fields[i];
        fields[i] = fields[j];
        fields[j] = temp;
    }
    if (!props.visible) {
        return null;
    }
    const resourceType = props.search.resourceType;
    const typeDef = globalSchema.types[resourceType];
    const selected = state.search.fields ?? [];
    const available = getFieldsList(typeDef)
        .filter((field) => !selected?.includes(field))
        .sort();
    return (React.createElement(Modal, { title: "Fields", closeButtonLabel: "Close", opened: props.visible, onClose: props.onCancel },
        React.createElement("div", null,
            React.createElement("table", { style: { margin: 'auto' } },
                React.createElement("thead", null,
                    React.createElement("tr", null,
                        React.createElement("th", { colSpan: 2, align: "center" }, "Available"),
                        React.createElement("th", { colSpan: 2, align: "center" }, "Selected"))),
                React.createElement("tbody", null,
                    React.createElement("tr", null,
                        React.createElement("td", { colSpan: 2, align: "center" },
                            React.createElement("select", { ref: availableRef, size: 15, tabIndex: 1, style: { width: '200px' }, onKeyDown: (e) => handleAvailableKeyDown(e), onDoubleClick: () => handleAvailableDoubleClick(), "data-testid": "available" }, available.map((key) => (React.createElement("option", { key: key, value: key }, buildFieldNameString(key)))))),
                        React.createElement("td", { colSpan: 2, align: "center" },
                            React.createElement("select", { ref: selectedRef, size: 15, tabIndex: 4, style: { width: '200px' }, onKeyDown: (e) => handleSelectedKeyDown(e), onDoubleClick: () => handleSelectedDoubleClick(), "data-testid": "selected" }, selected.map((key) => (React.createElement("option", { key: key, value: key }, buildFieldNameString(key)))))))),
                React.createElement("tfoot", null,
                    React.createElement("tr", null,
                        React.createElement("td", { align: "center" },
                            React.createElement(Button, { compact: true, variant: "outline", onClick: onAddField }, "Add")),
                        React.createElement("td", { align: "center" },
                            React.createElement(Button, { compact: true, variant: "outline", onClick: onRemoveField }, "Remove")),
                        React.createElement("td", { align: "center" },
                            React.createElement(Button, { compact: true, variant: "outline", onClick: onMoveUp }, "Up")),
                        React.createElement("td", { align: "center" },
                            React.createElement(Button, { compact: true, variant: "outline", onClick: onMoveDown }, "Down")))))),
        React.createElement(Button, { onClick: () => props.onOk(state.search) }, "OK")));
}
/**
 * Returns a list of fields/columns available for a type.
 * The result is the union of properties and search parameters.
 * @param typeSchema The type definition.
 */
function getFieldsList(typeSchema) {
    const result = [];
    const keys = new Set();
    const names = new Set();
    // Add properties first
    for (const key of Object.keys(typeSchema.properties)) {
        result.push(key);
        keys.add(key.toLowerCase());
        names.add(buildFieldNameString(key));
    }
    // Add search parameters if unique
    if (typeSchema.searchParams) {
        for (const code of Object.keys(typeSchema.searchParams)) {
            const name = buildFieldNameString(code);
            if (!keys.has(code) && !names.has(name)) {
                result.push(code);
                keys.add(code);
                names.add(buildFieldNameString(code));
            }
        }
    }
    return result;
}

export { SearchFieldEditor };
//# sourceMappingURL=SearchFieldEditor.mjs.map
