import { MultiSelect, Loader } from '@mantine/core';
import React, { useRef, useState, useCallback, useEffect } from 'react';
import { killEvent } from '../utils/dom.mjs';

function AsyncAutocomplete(props) {
    const { defaultValue, toKey, toOption, loadOptions, onChange, onCreate, ...rest } = props;
    const defaultItems = toDefaultItems(defaultValue);
    const inputRef = useRef(null);
    const [lastValue, setLastValue] = useState(undefined);
    const [timer, setTimer] = useState();
    const [abortController, setAbortController] = useState();
    const [autoSubmit, setAutoSubmit] = useState();
    const [options, setOptions] = useState(defaultItems?.map(toOption));
    const lastValueRef = useRef();
    lastValueRef.current = lastValue;
    const timerRef = useRef();
    timerRef.current = timer;
    const abortControllerRef = useRef();
    abortControllerRef.current = abortController;
    const autoSubmitRef = useRef();
    autoSubmitRef.current = autoSubmit;
    const optionsRef = useRef();
    optionsRef.current = options;
    const handleTimer = useCallback(() => {
        setTimer(undefined);
        const value = inputRef.current?.value?.trim() || '';
        if (value === lastValueRef.current) {
            // Nothing has changed, move on
            return;
        }
        setLastValue(value);
        const newAbortController = new AbortController();
        setAbortController(newAbortController);
        loadOptions(value, newAbortController.signal)
            .then((newValues) => {
            if (!newAbortController.signal.aborted) {
                setOptions(newValues.map(toOption));
                setAbortController(undefined);
                if (autoSubmitRef.current) {
                    if (newValues.length > 0) {
                        onChange(newValues.slice(0, 1));
                    }
                    setAutoSubmit(false);
                }
            }
        })
            .catch(console.log);
    }, [loadOptions, onChange, toOption]);
    const handleSearchChange = useCallback(() => {
        if (abortControllerRef.current) {
            abortControllerRef.current.abort();
            setAbortController(undefined);
        }
        if (timerRef.current !== undefined) {
            window.clearTimeout(timerRef.current);
        }
        const newTimer = window.setTimeout(() => handleTimer(), 100);
        setTimer(newTimer);
    }, [handleTimer]);
    const handleChange = useCallback((values) => {
        const result = [];
        for (const value of values) {
            let item = optionsRef.current?.find((option) => option.value === value)?.resource;
            if (!item) {
                item = onCreate(value);
            }
            result.push(item);
        }
        onChange(result);
    }, [onChange, onCreate]);
    const handleKeyDown = useCallback((e) => {
        if (e.key === 'Enter') {
            if (!timerRef.current && !abortControllerRef.current) {
                killEvent(e);
                if (optionsRef.current && optionsRef.current.length > 0) {
                    setOptions(optionsRef.current.slice(0, 1));
                    handleChange([optionsRef.current[0].value]);
                }
            }
            else {
                // The user pressed enter, but we don't have results yet.
                // We need to wait for the results to come in.
                setAutoSubmit(true);
            }
        }
    }, [handleChange]);
    const handleCreate = useCallback((input) => {
        const option = toOption(onCreate(input));
        setOptions([...optionsRef.current, option]);
        return option;
    }, [onCreate, setOptions, toOption]);
    const handleFilter = useCallback((_value, selected) => !selected, []);
    useEffect(() => {
        return () => {
            if (abortControllerRef.current) {
                abortControllerRef.current.abort();
            }
        };
    }, []);
    return (React.createElement(MultiSelect, { ...rest, ref: inputRef, defaultValue: defaultItems.map(toKey), searchable: true, onKeyDown: handleKeyDown, onSearchChange: handleSearchChange, data: options, onFocus: handleTimer, onChange: handleChange, onCreate: handleCreate, rightSectionWidth: 40, rightSection: abortController ? React.createElement(Loader, { size: 16 }) : null, filter: handleFilter }));
}
function toDefaultItems(defaultValue) {
    if (!defaultValue) {
        return [];
    }
    if (Array.isArray(defaultValue)) {
        return defaultValue;
    }
    return [defaultValue];
}

export { AsyncAutocomplete };
//# sourceMappingURL=AsyncAutocomplete.mjs.map
