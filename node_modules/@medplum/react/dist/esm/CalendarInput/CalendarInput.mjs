import { createStyles, Group, Button } from '@mantine/core';
import React, { useState, useMemo } from 'react';

const useStyles = createStyles((theme) => ({
    table: {
        width: 350,
        '& th': {
            fontWeight: 'normal',
            fontSize: 11,
            padding: 8,
            textAlign: 'center',
        },
        '& td': {
            padding: '2px 4px',
        },
        '& td button': {
            width: 44,
            height: 44,
            color: theme.colors[theme.primaryColor][5],
            fontSize: 16,
            fontWeight: 500,
            textAlign: 'center',
            padding: 0,
            backgroundColor: theme.colors[theme.primaryColor][0],
            border: 0,
            borderRadius: '50%',
            cursor: 'pointer',
        },
        '& td button:hover': {
            backgroundColor: theme.colors[theme.primaryColor][1],
        },
        '& td button:disabled': {
            backgroundColor: 'transparent',
            cursor: 'default',
            color: theme.colors.gray[4],
            fontWeight: 'normal',
        },
    },
}));
/**
 * Returns a month display string (e.g. "January 2020").
 * @param date Any date within the month.
 * @returns The month display string (e.g. "January 2020")
 */
function getMonthString(date) {
    return date.toLocaleString('default', { month: 'long' }) + ' ' + date.getFullYear();
}
function CalendarInput(props) {
    const { classes } = useStyles();
    const { onChangeMonth, onClick } = props;
    const [month, setMonth] = useState(getStartMonth);
    function moveMonth(delta) {
        setMonth((currMonth) => {
            const newMonth = new Date(currMonth.getTime());
            newMonth.setMonth(currMonth.getMonth() + delta);
            onChangeMonth(newMonth);
            return newMonth;
        });
    }
    const grid = useMemo(() => buildGrid(month, props.slots), [month, props.slots]);
    return (React.createElement("div", null,
        React.createElement(Group, { position: "apart", spacing: "xs", grow: true, noWrap: true },
            React.createElement("p", { style: { flex: 1 } }, getMonthString(month)),
            React.createElement(Group, { position: "right", spacing: "xs" },
                React.createElement(Button, { variant: "outline", "aria-label": "Previous month", onClick: () => moveMonth(-1) }, "<"),
                React.createElement(Button, { variant: "outline", "aria-label": "Next month", onClick: () => moveMonth(1) }, ">"))),
        React.createElement("table", { className: classes.table },
            React.createElement("thead", null,
                React.createElement("tr", null,
                    React.createElement("th", null, "SUN"),
                    React.createElement("th", null, "MON"),
                    React.createElement("th", null, "TUE"),
                    React.createElement("th", null, "WED"),
                    React.createElement("th", null, "THU"),
                    React.createElement("th", null, "FRI"),
                    React.createElement("th", null, "SAT"))),
            React.createElement("tbody", null, grid.map((week, weekIndex) => (React.createElement("tr", { key: 'week-' + weekIndex }, week.map((day, dayIndex) => (React.createElement("td", { key: 'day-' + dayIndex }, day && (React.createElement(Button, { disabled: !day.available, onClick: () => onClick(day.date) }, day.date.getDate()))))))))))));
}
function getStartMonth() {
    const result = new Date();
    result.setDate(1);
    result.setHours(0, 0, 0, 0);
    return result;
}
function buildGrid(startDate, slots) {
    const d = new Date(startDate.getFullYear(), startDate.getMonth());
    const grid = [];
    let row = [];
    // Fill leading empty days
    for (let i = 0; i < d.getDay(); i++) {
        row.push(undefined);
    }
    while (d.getMonth() === startDate.getMonth()) {
        row.push({
            date: new Date(d.getTime()),
            available: isDayAvailable(d, slots),
        });
        if (d.getDay() === 6) {
            grid.push(row);
            row = [];
        }
        d.setDate(d.getDate() + 1);
    }
    // Fill trailing empty days
    if (d.getDay() !== 0) {
        for (let i = d.getDay(); i < 7; i++) {
            row.push(undefined);
        }
        grid.push(row);
    }
    return grid;
}
/**
 * Returns true if the given date is available for booking.
 * @param day The day to check.
 * @param slots The list of available slots.
 * @returns True if there are any available slots for the day.
 */
function isDayAvailable(day, slots) {
    // Note that slot start and end time may or may not be in UTC.
    for (const slot of slots) {
        const slotStart = new Date(slot.start);
        if (slotStart.getFullYear() === day.getFullYear() &&
            slotStart.getMonth() === day.getMonth() &&
            slotStart.getDate() === day.getDate()) {
            return true;
        }
    }
    return false;
}

export { CalendarInput, getMonthString, getStartMonth };
//# sourceMappingURL=CalendarInput.mjs.map
