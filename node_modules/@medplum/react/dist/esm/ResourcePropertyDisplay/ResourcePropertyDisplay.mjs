import { buildTypeName, PropertyType, formatTiming, formatPeriod, formatDateTime, getTypedPropertyValue } from '@medplum/core';
import React from 'react';
import { AddressDisplay } from '../AddressDisplay/AddressDisplay.mjs';
import { AttachmentArrayDisplay } from '../AttachmentArrayDisplay/AttachmentArrayDisplay.mjs';
import { AttachmentDisplay } from '../AttachmentDisplay/AttachmentDisplay.mjs';
import { BackboneElementDisplay } from '../BackboneElementDisplay/BackboneElementDisplay.mjs';
import { CodeableConceptDisplay } from '../CodeableConceptDisplay/CodeableConceptDisplay.mjs';
import { CodingDisplay } from '../CodingDisplay/CodingDisplay.mjs';
import { ContactDetailDisplay } from '../ContactDetailDisplay/ContactDetailDisplay.mjs';
import { ContactPointDisplay } from '../ContactPointDisplay/ContactPointDisplay.mjs';
import { HumanNameDisplay } from '../HumanNameDisplay/HumanNameDisplay.mjs';
import { IdentifierDisplay } from '../IdentifierDisplay/IdentifierDisplay.mjs';
import { MoneyDisplay } from '../MoneyDisplay/MoneyDisplay.mjs';
import { QuantityDisplay } from '../QuantityDisplay/QuantityDisplay.mjs';
import { RangeDisplay } from '../RangeDisplay/RangeDisplay.mjs';
import { RatioDisplay } from '../RatioDisplay/RatioDisplay.mjs';
import { ReferenceDisplay } from '../ReferenceDisplay/ReferenceDisplay.mjs';
import { ResourceArrayDisplay } from '../ResourceArrayDisplay/ResourceArrayDisplay.mjs';

function ResourcePropertyDisplay(props) {
    const { property, propertyType, value } = props;
    if (property?.max === '*' && !props.arrayElement) {
        if (propertyType === 'Attachment') {
            return React.createElement(AttachmentArrayDisplay, { values: value, maxWidth: props.maxWidth });
        }
        return (React.createElement(ResourceArrayDisplay, { property: property, values: value, ignoreMissingValues: props.ignoreMissingValues, link: props.link }));
    }
    switch (propertyType) {
        case PropertyType.boolean:
            return React.createElement(React.Fragment, null, value === undefined ? '' : Boolean(value).toString());
        case PropertyType.SystemString:
        case PropertyType.code:
        case PropertyType.date:
        case PropertyType.integer:
        case PropertyType.positiveInt:
        case PropertyType.string:
        case PropertyType.unsignedInt:
        case PropertyType.uri:
        case PropertyType.url:
            return React.createElement(React.Fragment, null, value);
        case PropertyType.canonical:
            return React.createElement(ReferenceDisplay, { value: { reference: value }, link: props.link });
        case PropertyType.dateTime:
        case PropertyType.instant:
            return React.createElement(React.Fragment, null, formatDateTime(value));
        case PropertyType.markdown:
            return React.createElement("pre", null, value);
        case PropertyType.Address:
            return React.createElement(AddressDisplay, { value: value });
        case PropertyType.Annotation:
            return React.createElement(React.Fragment, null, value?.text);
        case PropertyType.Attachment:
            return React.createElement(AttachmentDisplay, { value: value, maxWidth: props.maxWidth });
        case PropertyType.CodeableConcept:
            return React.createElement(CodeableConceptDisplay, { value: value });
        case PropertyType.Coding:
            return React.createElement(CodingDisplay, { value: value });
        case PropertyType.ContactDetail:
            return React.createElement(ContactDetailDisplay, { value: value });
        case PropertyType.ContactPoint:
            return React.createElement(ContactPointDisplay, { value: value });
        case PropertyType.HumanName:
            return React.createElement(HumanNameDisplay, { value: value });
        case PropertyType.Identifier:
            return React.createElement(IdentifierDisplay, { value: value });
        case PropertyType.Money:
            return React.createElement(MoneyDisplay, { value: value });
        case PropertyType.Period:
            return React.createElement(React.Fragment, null, formatPeriod(value));
        case PropertyType.Quantity:
        case PropertyType.Duration:
            return React.createElement(QuantityDisplay, { value: value });
        case PropertyType.Range:
            return React.createElement(RangeDisplay, { value: value });
        case PropertyType.Ratio:
            return React.createElement(RatioDisplay, { value: value });
        case PropertyType.Reference:
            return React.createElement(ReferenceDisplay, { value: value, link: props.link });
        case PropertyType.Timing:
            return React.createElement(React.Fragment, null, formatTiming(value));
        case PropertyType.Dosage:
        case PropertyType.UsageContext:
            return (React.createElement(BackboneElementDisplay, { value: { type: propertyType, value }, compact: true, ignoreMissingValues: props.ignoreMissingValues }));
        default:
            if (!property?.path) {
                throw Error(`Displaying property of type ${props.propertyType} requires element definition path`);
            }
            return (React.createElement(BackboneElementDisplay, { value: { type: buildTypeName(property?.path?.split('.')), value }, compact: true, ignoreMissingValues: props.ignoreMissingValues }));
    }
}
/**
 * Returns the value of the property and the property type.
 * Some property definitions support multiple types.
 * For example, "Observation.value[x]" can be "valueString", "valueInteger", "valueQuantity", etc.
 * According to the spec, there can only be one property for a given element definition.
 * This function returns the value and the type.
 * @param context The base context (usually a FHIR resource).
 * @param property The property definition.
 * @returns The value of the property and the property type.
 */
function getValueAndType(context, path) {
    const typedResult = getTypedPropertyValue(context, path);
    if (!typedResult) {
        return [undefined, 'undefined'];
    }
    if (Array.isArray(typedResult)) {
        return [typedResult.map((e) => e.value), typedResult[0].type];
    }
    return [typedResult.value, typedResult.type];
}

export { ResourcePropertyDisplay, getValueAndType };
//# sourceMappingURL=ResourcePropertyDisplay.mjs.map
