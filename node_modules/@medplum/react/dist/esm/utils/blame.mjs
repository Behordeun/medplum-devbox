import { stringify } from '@medplum/core';
import { diff } from './diff.mjs';

function blame(history) {
    // Convert to array of array of lines
    const versions = history.entry
        .filter((entry) => !!entry.resource)
        .map((entry) => ({
        meta: entry.resource?.meta,
        lines: stringify(entry.resource, true).match(/[^\r\n]+/g),
    }))
        .sort((a, b) => a.meta.lastUpdated.localeCompare(b.meta.lastUpdated));
    // Start with array of lines from the first version
    const table = versions[0].lines.map((line) => ({
        id: versions[0].meta.versionId,
        meta: versions[0].meta,
        value: line,
        span: 1,
    }));
    compareVersions(table, versions);
    combineSpans(table);
    return table;
}
/**
 * For each version, update the blame table with revisions.
 * @param table The output blame table.
 * @param versions The array of versions.
 */
function compareVersions(table, versions) {
    for (let i = 1; i < versions.length; i++) {
        const revisions = diff(versions[i - 1].lines, versions[i].lines);
        for (const revision of revisions) {
            const position = revision.original.position;
            const oldLines = revision.original.lines;
            const newLines = revision.revised.lines;
            if (revision.type === 'delete' || revision.type === 'change') {
                // Remove the old rows
                table.splice(position, oldLines.length);
            }
            if (revision.type === 'insert' || revision.type === 'change') {
                // Add the new lines
                for (let k = 0; k < revision.revised.lines.length; k++) {
                    table.splice(position + k, 0, {
                        id: versions[i].meta.versionId,
                        meta: versions[i].meta,
                        value: newLines[k],
                        span: 1,
                    });
                }
            }
        }
    }
}
/**
 * Combine adjacent rows into spans.
 * @param table The output blame table.
 */
function combineSpans(table) {
    let start = 0;
    while (start < table.length) {
        let curr = start;
        while (curr < table.length && table[curr].id === table[start].id) {
            table[curr].span = -1;
            curr++;
        }
        table[start].span = curr - start;
        start = curr;
    }
}

export { blame };
//# sourceMappingURL=blame.mjs.map
