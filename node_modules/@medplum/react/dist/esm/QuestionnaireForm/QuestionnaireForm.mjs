import { Title, Group, Button, Stack, Checkbox, Textarea, TextInput, NativeSelect, Radio } from '@mantine/core';
import { getReferenceString, createReference, getTypedPropertyValue, capitalize, globalSchema, stringify, deepEquals, getQuestionnaireAnswers } from '@medplum/core';
import React, { useState, useEffect } from 'react';
import { AttachmentInput } from '../AttachmentInput/AttachmentInput.mjs';
import { CheckboxFormSection } from '../CheckboxFormSection/CheckboxFormSection.mjs';
import { DateTimeInput } from '../DateTimeInput/DateTimeInput.mjs';
import { Form } from '../Form/Form.mjs';
import { FormSection } from '../FormSection/FormSection.mjs';
import { useMedplum } from '../MedplumProvider/MedplumProvider.mjs';
import { QuantityInput } from '../QuantityInput/QuantityInput.mjs';
import { ReferenceInput } from '../ReferenceInput/ReferenceInput.mjs';
import { ResourcePropertyDisplay } from '../ResourcePropertyDisplay/ResourcePropertyDisplay.mjs';
import { useResource } from '../useResource/useResource.mjs';
import { QuestionnaireItemType } from '../utils/questionnaire.mjs';

function QuestionnaireForm(props) {
    const medplum = useMedplum();
    const source = medplum.getProfile();
    const [schema, setSchema] = useState();
    const questionnaire = useResource(props.questionnaire);
    const [response, setResponse] = useState();
    const [answers, setAnswers] = useState({});
    useEffect(() => {
        medplum
            .requestSchema('Questionnaire')
            .then(() => medplum.requestSchema('QuestionnaireResponse'))
            .then(setSchema)
            .catch(console.log);
    }, [medplum]);
    useEffect(() => {
        setResponse(questionnaire ? buildInitialResponse(questionnaire) : undefined);
    }, [questionnaire]);
    function setItems(newResponseItems) {
        const newResponse = {
            resourceType: 'QuestionnaireResponse',
            status: 'completed',
            item: newResponseItems,
        };
        setResponse(newResponse);
        setAnswers(getQuestionnaireAnswers(newResponse));
    }
    if (!schema || !questionnaire) {
        return null;
    }
    return (React.createElement(Form, { testid: "questionnaire-form", onSubmit: () => {
            if (props.onSubmit && response) {
                props.onSubmit({
                    ...response,
                    questionnaire: getReferenceString(questionnaire),
                    subject: props.subject,
                    source: createReference(source),
                    authored: new Date().toISOString(),
                });
            }
        } },
        questionnaire.title && React.createElement(Title, null, questionnaire.title),
        questionnaire.item && (React.createElement(QuestionnaireFormItemArray, { items: questionnaire.item, answers: answers, onChange: setItems })),
        React.createElement(Group, { position: "right", mt: "xl" },
            React.createElement(Button, { type: "submit" }, props.submitButtonText || 'OK'))));
}
function QuestionnaireFormItemArray(props) {
    const [responseItems, setResponseItems] = useState(buildInitialResponseItems(props.items));
    function setResponseItem(index, newResponseItem) {
        const newResponseItems = responseItems.slice();
        newResponseItems[index] = newResponseItem;
        setResponseItems(newResponseItems);
        props.onChange(newResponseItems);
    }
    return (React.createElement(Stack, null, props.items.map((item, index) => {
        if (!isQuestionEnabled(item, props.answers)) {
            return null;
        }
        if (item.type === QuestionnaireItemType.display) {
            return React.createElement("p", { key: item.linkId }, item.text);
        }
        if (item.type === QuestionnaireItemType.group) {
            return (React.createElement(QuestionnaireFormItem, { key: item.linkId, item: item, answers: props.answers, onChange: (newResponseItem) => setResponseItem(index, newResponseItem) }));
        }
        if (item.type === QuestionnaireItemType.boolean) {
            const initial = item.initial && item.initial.length > 0 ? item.initial[0] : undefined;
            return (React.createElement(CheckboxFormSection, { key: item.linkId, title: item.text, htmlFor: item.linkId },
                React.createElement(Checkbox, { id: item.linkId, name: item.linkId, defaultChecked: initial?.valueBoolean, onChange: (e) => setResponseItem(index, {
                        linkId: item.linkId,
                        text: item.text,
                        answer: [{ valueBoolean: e.currentTarget.checked }],
                    }) })));
        }
        return (React.createElement(FormSection, { key: item.linkId, htmlFor: item.linkId, title: item.text || '' },
            React.createElement(QuestionnaireFormItem, { item: item, answers: props.answers, onChange: (newResponseItem) => setResponseItem(index, newResponseItem) })));
    })));
}
function QuestionnaireFormItem(props) {
    const item = props.item;
    const type = item.type;
    if (!type) {
        return null;
    }
    const name = item.linkId;
    if (!name) {
        return null;
    }
    const initial = item.initial && item.initial.length > 0 ? item.initial[0] : undefined;
    function onChangeItem(newResponseItems) {
        props.onChange({
            linkId: item.linkId,
            text: item.text,
            item: newResponseItems,
        });
    }
    function onChangeAnswer(newResponseAnswer) {
        props.onChange({
            linkId: item.linkId,
            text: item.text,
            answer: [newResponseAnswer],
        });
    }
    switch (type) {
        case QuestionnaireItemType.group:
            return (React.createElement("div", null,
                React.createElement("h3", null, item.text),
                item.item && (React.createElement(QuestionnaireFormItemArray, { items: item.item, answers: props.answers, onChange: onChangeItem }))));
        case QuestionnaireItemType.boolean:
            return (React.createElement(Checkbox, { id: name, name: name, defaultChecked: initial?.valueBoolean, onChange: (e) => onChangeAnswer({ valueBoolean: e.currentTarget.checked }) }));
        case QuestionnaireItemType.decimal:
            return (React.createElement(TextInput, { type: "number", step: "any", id: name, name: name, defaultValue: initial?.valueDecimal, onChange: (e) => onChangeAnswer({ valueDecimal: e.currentTarget.valueAsNumber }) }));
        case QuestionnaireItemType.integer:
            return (React.createElement(TextInput, { type: "number", step: 1, id: name, name: name, defaultValue: initial?.valueInteger, onChange: (e) => onChangeAnswer({ valueInteger: e.currentTarget.valueAsNumber }) }));
        case QuestionnaireItemType.date:
            return (React.createElement(TextInput, { type: "date", id: name, name: name, defaultValue: initial?.valueDate, onChange: (e) => onChangeAnswer({ valueDate: e.currentTarget.value }) }));
        case QuestionnaireItemType.dateTime:
            return (React.createElement(DateTimeInput, { name: name, defaultValue: initial?.valueDateTime, onChange: (newValue) => onChangeAnswer({ valueDateTime: newValue }) }));
        case QuestionnaireItemType.time:
            return (React.createElement(TextInput, { type: "time", id: name, name: name, defaultValue: initial?.valueTime, onChange: (e) => onChangeAnswer({ valueTime: e.currentTarget.value }) }));
        case QuestionnaireItemType.string:
        case QuestionnaireItemType.url:
            return (React.createElement(TextInput, { id: name, name: name, defaultValue: initial?.valueString, onChange: (e) => onChangeAnswer({ valueString: e.currentTarget.value }) }));
        case QuestionnaireItemType.text:
            return (React.createElement(Textarea, { id: name, name: name, defaultValue: initial?.valueString, onChange: (e) => onChangeAnswer({ valueString: e.currentTarget.value }) }));
        case QuestionnaireItemType.attachment:
            return (React.createElement(AttachmentInput, { name: name, defaultValue: initial?.valueAttachment, onChange: (newValue) => onChangeAnswer({ valueAttachment: newValue }) }));
        case QuestionnaireItemType.reference:
            return (React.createElement(ReferenceInput, { name: name, defaultValue: initial?.valueReference, onChange: (newValue) => onChangeAnswer({ valueReference: newValue }) }));
        case QuestionnaireItemType.quantity:
            return (React.createElement(QuantityInput, { name: name, defaultValue: initial?.valueQuantity, onChange: (newValue) => onChangeAnswer({ valueQuantity: newValue }) }));
        case QuestionnaireItemType.choice:
        case QuestionnaireItemType.openChoice:
            if (isDropDownChoice(item)) {
                return (React.createElement(QuestionnaireChoiceDropDownInput, { name: name, item: item, initial: initial, onChangeAnswer: onChangeAnswer }));
            }
            else {
                return (React.createElement(QuestionnaireChoiceRadioInput, { name: name, item: item, initial: initial, onChangeAnswer: onChangeAnswer }));
            }
    }
    return null;
}
function QuestionnaireChoiceDropDownInput(props) {
    const { name, item, initial } = props;
    const initialValue = getTypedPropertyValue({ type: 'QuestionnaireItemInitial', value: initial }, 'value');
    const data = [''];
    if (item.answerOption) {
        for (const option of item.answerOption) {
            const optionValue = getTypedPropertyValue({ type: 'QuestionnaireItemAnswerOption', value: option }, 'value');
            data.push(typedValueToString(optionValue));
        }
    }
    return (React.createElement(NativeSelect, { id: name, name: name, onChange: (e) => {
            const index = e.currentTarget.selectedIndex;
            if (index === 0) {
                props.onChangeAnswer({});
                return;
            }
            const option = item.answerOption[index - 1];
            const optionValue = getTypedPropertyValue({ type: 'QuestionnaireItemAnswerOption', value: option }, 'value');
            const propertyName = 'value' + capitalize(optionValue.type);
            props.onChangeAnswer({ [propertyName]: optionValue.value });
        }, defaultValue: typedValueToString(initialValue), data: data }));
}
function typedValueToString(typedValue) {
    if (!typedValue) {
        return undefined;
    }
    if (typedValue.type === 'CodeableConcept') {
        return typedValue.value.coding[0].display;
    }
    if (typedValue.type === 'Coding') {
        return typedValue.value.display;
    }
    return typedValue.value.toString();
}
function QuestionnaireChoiceRadioInput(props) {
    const { name, item, initial, onChangeAnswer } = props;
    const valueElementDefinition = globalSchema.types['QuestionnaireItemAnswerOption'].properties['value[x]'];
    const initialValue = getTypedPropertyValue({ type: 'QuestionnaireItemInitial', value: initial }, 'value');
    const options = [];
    let defaultValue = undefined;
    if (item.answerOption) {
        for (let i = 0; i < item.answerOption.length; i++) {
            const option = item.answerOption[i];
            const optionName = `${name}-option-${i}`;
            const optionValue = getTypedPropertyValue({ type: 'QuestionnaireItemAnswerOption', value: option }, 'value');
            if (initialValue && stringify(optionValue) === stringify(initialValue)) {
                defaultValue = optionName;
            }
            options.push([optionName, optionValue]);
        }
    }
    return (React.createElement(Radio.Group, { name: name, orientation: "vertical", defaultValue: defaultValue, onChange: (newValue) => {
            const option = options.find((option) => option[0] === newValue);
            if (option) {
                const optionValue = option[1];
                const propertyName = 'value' + capitalize(optionValue.type);
                onChangeAnswer({ [propertyName]: optionValue.value });
            }
        } }, options.map(([optionName, optionValue]) => (React.createElement(Radio, { key: optionName, id: optionName, value: optionName, label: React.createElement(ResourcePropertyDisplay, { property: valueElementDefinition, propertyType: optionValue.type, value: optionValue.value }) })))));
}
function buildInitialResponse(questionnaire) {
    const response = {
        resourceType: 'QuestionnaireResponse',
        questionnaire: getReferenceString(questionnaire),
        item: buildInitialResponseItems(questionnaire.item),
    };
    return response;
}
function buildInitialResponseItems(items) {
    return items?.map(buildInitialResponseItem) ?? [];
}
function buildInitialResponseItem(item) {
    return {
        linkId: item.linkId,
        text: item.text,
        item: buildInitialResponseItems(item.item),
        answer: item.initial?.map(buildInitialResponseAnswer) ?? [],
    };
}
function buildInitialResponseAnswer(answer) {
    // This works because QuestionnaireItemInitial and QuestionnaireResponseItemAnswer
    // have the same properties.
    return { ...answer };
}
function isDropDownChoice(item) {
    return !!item.extension?.some((e) => e.url === 'http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl' &&
        e.valueCodeableConcept?.coding?.[0]?.code === 'drop-down');
}
function isQuestionEnabled(item, answers) {
    if (!item.enableWhen) {
        return true;
    }
    const enableBehavior = item.enableBehavior || 'any';
    for (const enableWhen of item.enableWhen) {
        const expectedAnswer = getTypedPropertyValue({
            type: 'QuestionnaireItemEnableWhen',
            value: enableWhen,
        }, 'answer[x]');
        const actualAnswer = getTypedPropertyValue({
            type: 'QuestionnaireResponseItemAnswer',
            value: answers[enableWhen.question],
        }, 'value[x]');
        const match = deepEquals(expectedAnswer, actualAnswer);
        if (enableBehavior === 'any' && match) {
            return true;
        }
        if (enableBehavior === 'all' && !match) {
            return false;
        }
    }
    if (enableBehavior === 'any') {
        return false;
    }
    else {
        return true;
    }
}

export { QuestionnaireForm, QuestionnaireFormItem, isQuestionEnabled };
//# sourceMappingURL=QuestionnaireForm.mjs.map
