import { createStyles, Stack, ActionIcon, Group, Button, Divider, TextInput, NativeSelect, Text } from '@mantine/core';
import { formatRange, getCodeBySystem } from '@medplum/core';
import { IconCirclePlus, IconCircleMinus } from '@tabler/icons';
import React, { useState, useEffect } from 'react';
import { Container } from '../Container/Container.mjs';
import { Form } from '../Form/Form.mjs';
import { RangeInput } from '../RangeInput/RangeInput.mjs';
import { killEvent } from '../utils/dom.mjs';

const useStyles = createStyles((theme) => ({
    section: {
        position: 'relative',
        margin: '4px 4px 8px 0',
        padding: '6px 12px 16px 6px',
        border: `1.5px solid ${theme.colors.gray[3]}`,
        borderRadius: theme.radius.sm,
        transition: 'all 0.1s',
    },
}));
// Properties of qualified intervals used for grouping
const intervalFilters = ['gender', 'age', 'gestationalAge', 'context', 'appliesTo'];
const defaultProps = {
    definition: { resourceType: 'ObservationDefinition' },
    onSubmit: () => {
        return;
    },
};
function ReferenceRangeEditor(props) {
    props = Object.assign(defaultProps, props);
    const defaultDefinition = props.definition;
    const [intervalGroups, setIntervalGroups] = useState([]);
    const [groupId, setGroupId] = useState(1);
    const [intervalId, setIntervalId] = useState(1);
    useEffect(() => {
        const definition = ensureQualifiedIntervalKeys(defaultDefinition, setIntervalId);
        setIntervalGroups(groupQualifiedIntervals(definition.qualifiedInterval || [], setGroupId));
    }, [defaultDefinition]);
    return (React.createElement(Form, { testid: "reference-range-editor", onSubmit: submitDefinition },
        React.createElement(Stack, null, intervalGroups.map((intervalGroup) => (React.createElement(ReferenceRangeGroupEditor, { unit: getUnitString(defaultDefinition.quantitativeDetails?.unit), onChange: changeInterval, onAdd: addInterval, onRemove: removeInterval, onRemoveGroup: removeGroup, key: `group-${intervalGroup.id}`, intervalGroup: intervalGroup })))),
        React.createElement(ActionIcon, { title: "Add Group", size: "sm", onClick: (e) => {
                killEvent(e);
                addGroup({ id: `group-id-${groupId}`, filters: {}, intervals: [] });
                setGroupId((id) => id + 1);
            } },
            React.createElement(IconCirclePlus, null)),
        React.createElement(Group, { position: "right" },
            React.createElement(Button, { type: "submit" }, "Save"))));
    /**
     * Submit qualified intervals
     */
    function submitDefinition() {
        const qualifiedInterval = intervalGroups
            .flatMap((group) => group.intervals)
            .filter((interval) => !isEmptyInterval(interval));
        props.onSubmit({ ...defaultDefinition, qualifiedInterval });
    }
    /**
     * Add Remove Interval Groups
     */
    function addGroup(addedGroup) {
        setIntervalGroups((currentGroups) => [...currentGroups, addedGroup]);
    }
    function removeGroup(removedGroup) {
        setIntervalGroups((currentGroups) => currentGroups.filter((group) => group.id !== removedGroup.id));
    }
    /**
     * Add/Remove/Update specific Qualified Intervals
     */
    function changeInterval(groupId, changedInterval) {
        setIntervalGroups((groups) => {
            groups = [...groups];
            const currentGroup = groups.find((g) => g.id === groupId);
            const index = currentGroup?.intervals?.findIndex((interval) => interval.id === changedInterval.id);
            if (index !== undefined && currentGroup?.intervals?.[index]) {
                currentGroup.intervals[index] = changedInterval;
            }
            return groups;
        });
    }
    function addInterval(groupId, addedInterval) {
        if (addedInterval.id === undefined) {
            addedInterval.id = `id-${intervalId}`;
            setIntervalId((id) => id + 1);
        }
        setIntervalGroups((groups) => {
            groups = [...groups];
            const currentGroupIndex = groups.findIndex((g) => g.id === groupId);
            if (currentGroupIndex != -1) {
                const currentGroup = { ...groups[currentGroupIndex] };
                addedInterval = { ...addedInterval, ...currentGroup.filters };
                currentGroup.intervals = [...currentGroup.intervals, addedInterval];
                groups[currentGroupIndex] = currentGroup;
            }
            return groups;
        });
    }
    function removeInterval(groupId, removedInterval) {
        setIntervalGroups((groups) => {
            groups = [...groups];
            const currentGroup = groups.find((g) => g.id === groupId);
            if (currentGroup) {
                currentGroup.intervals = currentGroup.intervals.filter((interval) => interval.id !== removedInterval.id);
            }
            return groups;
        });
    }
}
function ReferenceRangeGroupEditor(props) {
    const { intervalGroup, unit } = props;
    const { classes } = useStyles();
    return (React.createElement(Container, { "data-testid": intervalGroup.id, className: classes.section },
        React.createElement(Stack, { spacing: 'lg' },
            React.createElement(Group, { position: "right" },
                React.createElement(ActionIcon, { title: "Remove Group", "data-testid": `remove-group-button-${intervalGroup.id}`, key: `remove-group-button-${intervalGroup.id}`, size: "sm", onClick: (e) => {
                        killEvent(e);
                        props.onRemoveGroup(intervalGroup);
                    } },
                    React.createElement(IconCircleMinus, null))),
            React.createElement(ReferenceRangeGroupFilters, { intervalGroup: intervalGroup, onChange: props.onChange }),
            React.createElement(Divider, null),
            intervalGroup.intervals.map((interval) => (React.createElement(Stack, { key: `interval-${interval.id}`, spacing: 'xs' },
                React.createElement(Group, null,
                    React.createElement(TextInput, { key: `condition-${interval.id}`, "data-testid": `condition-${interval.id}`, defaultValue: interval.condition, label: 'Condition: ', size: 'sm', onChange: (e) => {
                            killEvent(e);
                            props.onChange(intervalGroup.id, { ...interval, condition: e.currentTarget.value.trim() });
                        } }),
                    React.createElement(ActionIcon, { title: "Remove Interval", size: "sm", key: `remove-interval-${interval.id}`, "data-testid": `remove-interval-${interval.id}`, onClick: (e) => {
                            killEvent(e);
                            props.onRemove(intervalGroup.id, interval);
                        } },
                        React.createElement(IconCircleMinus, null))),
                React.createElement(RangeInput, { onChange: (range) => {
                        props.onChange(intervalGroup.id, { ...interval, range });
                    }, key: `range-${interval.id}`, name: `range-${interval.id}`, defaultValue: interval.range })))),
            React.createElement(ActionIcon, { title: "Add Interval", size: "sm", onClick: (e) => {
                    killEvent(e);
                    props.onAdd(intervalGroup.id, {
                        range: {
                            low: { unit },
                            high: { unit },
                        },
                    });
                } },
                React.createElement(IconCirclePlus, null)))));
}
/**
 * Render the "filters" section of the IntervalGroup. Also populates some initial
 */
function ReferenceRangeGroupFilters(props) {
    const { intervalGroup, onChange } = props;
    // Pre-populate the units of the age filter
    if (!intervalGroup.filters.age) {
        intervalGroup.filters.age = {};
    }
    for (const key of ['low', 'high']) {
        if (!intervalGroup.filters.age[key]?.unit) {
            intervalGroup.filters.age[key] = {
                ...intervalGroup.filters.age[key],
                unit: 'years',
                system: 'http://unitsofmeasure.org',
            };
        }
    }
    return (React.createElement(Stack, { style: { maxWidth: '50%' } },
        React.createElement(Group, null,
            React.createElement(NativeSelect, { data: ['', 'male', 'female'], label: "Gender:", defaultValue: intervalGroup.filters.gender || '', onChange: (e) => {
                    for (const interval of intervalGroup.intervals) {
                        let newGender = e.currentTarget?.value;
                        if (newGender === '') {
                            newGender = undefined;
                        }
                        onChange(intervalGroup.id, {
                            ...interval,
                            gender: newGender,
                        });
                    }
                } })),
        React.createElement(Group, { spacing: 'xs' },
            React.createElement(Text, { component: "label", htmlFor: `div-age-${intervalGroup.id}` }, "Age:"),
            React.createElement("div", { id: `div-age-${intervalGroup.id}` },
                React.createElement(RangeInput, { key: `age-${intervalGroup.id}`, name: `age-${intervalGroup.id}`, defaultValue: intervalGroup.filters['age'], onChange: (ageRange) => {
                        for (const interval of intervalGroup.intervals) {
                            onChange(intervalGroup.id, { ...interval, age: ageRange });
                        }
                    } }))),
        React.createElement(NativeSelect, { data: ['', 'pre-puberty', 'follicular', 'midcycle', 'luteal', 'postmenopausal'], label: "Endocrine:", defaultValue: intervalGroup.filters.context?.text || '', onChange: (e) => {
                for (const interval of intervalGroup.intervals) {
                    let newEndocrine = e.currentTarget?.value;
                    if (newEndocrine === '') {
                        newEndocrine = undefined;
                        onChange(intervalGroup.id, { ...interval, context: undefined });
                    }
                    else {
                        onChange(intervalGroup.id, {
                            ...interval,
                            context: {
                                text: newEndocrine,
                                coding: [
                                    { code: newEndocrine, system: 'http://terminology.hl7.org/CodeSystem/referencerange-meaning' },
                                ],
                            },
                        });
                    }
                }
            } })));
}
/**
 * Helper function that assigns ids to each qualifiedInterval of an ObservationDefinition
 * @param definition An ObservationDefinition
 * @param setIntervalId React setState function for the intervalId
 * @returns
 */
function ensureQualifiedIntervalKeys(definition, setIntervalId) {
    const intervals = definition.qualifiedInterval || [];
    // Set the nextId to the max of any existing numeric id
    let nextId = Math.max(...intervals.map((interval) => {
        const existingNum = parseInt(interval.id?.substring(3) || '');
        return !isNaN(existingNum) ? existingNum : Number.NEGATIVE_INFINITY;
    })) + 1;
    if (!Number.isFinite(nextId)) {
        nextId = 1;
    }
    // If an interval doesn't have an id, set it to the nextId
    definition = {
        ...definition,
        qualifiedInterval: intervals.map((interval) => ({
            ...interval,
            id: interval.id || `id-${nextId++}`,
        })),
    };
    setIntervalId(nextId);
    return definition;
}
/**
 * Group all ObservationDefinitionQualifiedIntervals based on the values of their "filter" properties,
 * so that similar ranges can be grouped together
 */
function groupQualifiedIntervals(intervals, setGroupId) {
    let groupId = 1;
    const groups = {};
    for (const interval of intervals) {
        const groupKey = generateGroupKey(interval);
        if (!(groupKey in groups)) {
            groups[groupKey] = {
                id: `group-id-${groupId++}`,
                filters: Object.fromEntries(intervalFilters.map((f) => [f, interval[f]])),
                intervals: [],
            };
        }
        groups[groupKey].intervals.push(interval);
    }
    setGroupId(groupId);
    return Object.values(groups);
}
/**
 * Generates a unique string for each set of filter values, so that similarly filtered intervals can be grouped together
 * @return A "group key" that corresponds to the value of the interval filter properties.
 */
function generateGroupKey(interval) {
    const results = [
        `gender=${interval.gender}`,
        `age=${formatRange(interval.age)}`,
        `gestationalAge=${formatRange(interval.gestationalAge)}`,
        `context=${interval.context?.text}`,
        `appliesTo=${interval.appliesTo?.map((c) => c.text).join('+')}`,
    ];
    return results.join(':');
}
function getUnitString(unit) {
    return unit && (getCodeBySystem(unit, 'http://unitsofmeasure.org') || unit.text);
}
function isEmptyInterval(interval) {
    return interval.range?.low?.value === undefined && interval.range?.high?.value === undefined;
}

export { ReferenceRangeEditor, ReferenceRangeGroupEditor };
//# sourceMappingURL=ReferenceRangeEditor.mjs.map
