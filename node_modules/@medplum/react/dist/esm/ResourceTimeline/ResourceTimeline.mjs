import { createStyles, Center, Loader, Group, TextInput, ActionIcon, ScrollArea, Menu } from '@mantine/core';
import { updateNotification, showNotification } from '@mantine/notifications';
import { normalizeErrorString, getReferenceString } from '@medplum/core';
import { IconMessage, IconCloudUpload, IconCheck, IconFileAlert, IconPin, IconPinnedOff, IconListDetails, IconEdit, IconTrash } from '@tabler/icons';
import React, { useRef, useState, useCallback, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { AttachmentButton } from '../AttachmentButton/AttachmentButton.mjs';
import { AttachmentDisplay } from '../AttachmentDisplay/AttachmentDisplay.mjs';
import { DiagnosticReportDisplay } from '../DiagnosticReportDisplay/DiagnosticReportDisplay.mjs';
import { Form } from '../Form/Form.mjs';
import { useMedplum } from '../MedplumProvider/MedplumProvider.mjs';
import { Panel } from '../Panel/Panel.mjs';
import { ResourceAvatar } from '../ResourceAvatar/ResourceAvatar.mjs';
import { ResourceDiffTable } from '../ResourceDiffTable/ResourceDiffTable.mjs';
import { ResourceTable } from '../ResourceTable/ResourceTable.mjs';
import { Timeline, TimelineItem } from '../Timeline/Timeline.mjs';
import { useResource } from '../useResource/useResource.mjs';
import { sortByDateAndPriority } from '../utils/date.mjs';

const useStyles = createStyles((theme) => ({
    pinnedComment: {
        backgroundColor: theme.colors.blue[0],
    },
}));
function ResourceTimeline(props) {
    const navigate = useNavigate();
    const medplum = useMedplum();
    const sender = medplum.getProfile();
    const inputRef = useRef(null);
    const resource = useResource(props.value);
    const [history, setHistory] = useState();
    const [items, setItems] = useState([]);
    const buildSearchRequests = props.buildSearchRequests;
    const itemsRef = useRef(items);
    itemsRef.current = items;
    const loadTimeline = useCallback(() => {
        if (!resource) {
            setItems([]);
            setHistory({});
            return;
        }
        medplum.executeBatch(buildSearchRequests(resource)).then(handleBatchResponse).catch(console.log);
    }, [medplum, resource, buildSearchRequests]);
    useEffect(() => {
        loadTimeline();
    }, [loadTimeline]);
    /**
     * Handles a batch request response.
     * @param batchResponse The batch response.
     */
    function handleBatchResponse(batchResponse) {
        const newItems = [];
        if (batchResponse.entry) {
            for (const batchEntry of batchResponse.entry) {
                const bundle = batchEntry.resource;
                if (!bundle) {
                    // User may not have access to all resource types
                    continue;
                }
                if (bundle.type === 'history') {
                    setHistory(bundle);
                }
                if (bundle.entry) {
                    for (const entry of bundle.entry) {
                        if (entry.resource) {
                            newItems.push(entry.resource);
                        }
                    }
                }
            }
            sortByDateAndPriority(newItems);
            newItems.reverse();
        }
        setItems(newItems);
    }
    /**
     * Adds an array of resources to the timeline.
     * @param resources Array of resources.
     */
    function addResources(resources) {
        const newItems = [...itemsRef.current, ...resources];
        sortByDateAndPriority(newItems);
        newItems.reverse();
        setItems(newItems);
    }
    /**
     * Adds a Communication resource to the timeline.
     * @param contentString The comment content.
     */
    function createComment(contentString) {
        if (!resource || !props.createCommunication) {
            // Encounter not loaded yet
            return;
        }
        medplum
            .createResource(props.createCommunication(resource, sender, contentString))
            .then((result) => {
            addResources([result]);
        })
            .catch(console.log);
    }
    /**
     * Adds a Media resource to the timeline.
     * @param attachment The media attachment.
     */
    function createMedia(attachment) {
        if (!resource || !props.createMedia) {
            // Encounter not loaded yet
            return;
        }
        medplum
            .createResource(props.createMedia(resource, sender, attachment))
            .then((result) => addResources([result]))
            .then(() => updateNotification({
            id: 'upload-notification',
            color: 'teal',
            title: 'Upload complete',
            message: '',
            icon: React.createElement(IconCheck, { size: 16 }),
            autoClose: 2000,
        }))
            .catch((reason) => updateNotification({
            id: 'upload-notification',
            color: 'red',
            title: 'Upload error',
            message: normalizeErrorString(reason),
            icon: React.createElement(IconFileAlert, { size: 16 }),
            autoClose: 2000,
        }));
    }
    function setPriority(communication, priority) {
        return medplum.updateResource({ ...communication, priority });
    }
    function onPin(communication) {
        setPriority(communication, 'stat').then(loadTimeline).catch(console.log);
    }
    function onUnpin(communication) {
        setPriority(communication, 'routine').then(loadTimeline).catch(console.log);
    }
    function onDetails(timelineItem) {
        navigate(`/${timelineItem.resourceType}/${timelineItem.id}`);
    }
    function onEdit(timelineItem) {
        navigate(`/${timelineItem.resourceType}/${timelineItem.id}/edit`);
    }
    function onDelete(timelineItem) {
        navigate(`/${timelineItem.resourceType}/${timelineItem.id}/delete`);
    }
    function onVersionDetails(version) {
        navigate(`/${version.resourceType}/${version.id}/_history/${version.meta?.versionId}`);
    }
    function onUploadStart() {
        showNotification({
            id: 'upload-notification',
            loading: true,
            title: 'Initializing upload...',
            message: 'Please wait...',
            autoClose: false,
            disallowClose: true,
        });
    }
    function onUploadProgress(e) {
        updateNotification({
            id: 'upload-notification',
            loading: true,
            title: 'Uploading...',
            message: getProgressMessage(e),
            autoClose: false,
            disallowClose: true,
        });
    }
    if (!resource) {
        return (React.createElement(Center, { style: { width: '100%', height: '100%' } },
            React.createElement(Loader, null)));
    }
    return (React.createElement(Timeline, null,
        props.createCommunication && (React.createElement(Panel, null,
            React.createElement(Form, { testid: "timeline-form", onSubmit: (formData) => {
                    createComment(formData.text);
                    const input = inputRef.current;
                    if (input) {
                        input.value = '';
                        input.focus();
                    }
                } },
                React.createElement(Group, { spacing: "xs", noWrap: true, style: { width: '100%' } },
                    React.createElement(ResourceAvatar, { value: sender }),
                    React.createElement(TextInput, { name: "text", ref: inputRef, placeholder: "Add comment", style: { width: '100%', maxWidth: 300 } }),
                    React.createElement(ActionIcon, { type: "submit", radius: "xl", color: "blue", variant: "filled" },
                        React.createElement(IconMessage, { size: 16 })),
                    React.createElement(AttachmentButton, { onUpload: createMedia, onUploadStart: onUploadStart, onUploadProgress: onUploadProgress }, (props) => (React.createElement(ActionIcon, { ...props, radius: "xl", color: "blue", variant: "filled" },
                        React.createElement(IconCloudUpload, { size: 16 })))))))),
        items.map((item) => {
            if (item.resourceType === resource.resourceType && item.id === resource.id) {
                return (React.createElement(HistoryTimelineItem, { key: item.meta?.versionId, history: history, resource: item, onDetails: onVersionDetails }));
            }
            const key = `${item.resourceType}/${item.id}`;
            switch (item.resourceType) {
                case 'AuditEvent':
                    return React.createElement(AuditEventTimelineItem, { key: key, resource: item, onDetails: onDetails });
                case 'Communication':
                    return (React.createElement(CommunicationTimelineItem, { key: key, resource: item, onPin: item.priority !== 'stat' ? onPin : undefined, onUnpin: item.priority === 'stat' ? onUnpin : undefined, onDetails: onDetails, onEdit: onEdit, onDelete: onDelete }));
                case 'DiagnosticReport':
                    return (React.createElement(DiagnosticReportTimelineItem, { key: key, resource: item, onDetails: onDetails, onEdit: onEdit, onDelete: onDelete }));
                case 'Media':
                    return (React.createElement(MediaTimelineItem, { key: key, resource: item, onDetails: onDetails, onEdit: onEdit, onDelete: onDelete }));
                default:
                    return (React.createElement(TimelineItem, { key: key, resource: item, padding: true },
                        React.createElement(ResourceTable, { value: item, ignoreMissingValues: true })));
            }
        })));
}
function TimelineItemPopupMenu(props) {
    return (React.createElement(Menu.Dropdown, null,
        React.createElement(Menu.Label, null, "Resource"),
        props.onPin && (React.createElement(Menu.Item, { icon: React.createElement(IconPin, { size: 14 }), onClick: () => props.onPin(props.resource), "aria-label": `Pin ${getReferenceString(props.resource)}` }, "Pin")),
        props.onUnpin && (React.createElement(Menu.Item, { icon: React.createElement(IconPinnedOff, { size: 14 }), onClick: () => props.onUnpin(props.resource), "aria-label": `Unpin ${getReferenceString(props.resource)}` }, "Unpin")),
        props.onDetails && (React.createElement(Menu.Item, { icon: React.createElement(IconListDetails, { size: 14 }), onClick: () => props.onDetails(props.resource), "aria-label": `Details ${getReferenceString(props.resource)}` }, "Details")),
        props.onEdit && (React.createElement(Menu.Item, { icon: React.createElement(IconEdit, { size: 14 }), onClick: () => props.onEdit(props.resource), "aria-label": `Edit ${getReferenceString(props.resource)}` }, "Edit")),
        props.onDelete && (React.createElement(React.Fragment, null,
            React.createElement(Menu.Divider, null),
            React.createElement(Menu.Label, null, "Danger zone"),
            React.createElement(Menu.Item, { color: "red", icon: React.createElement(IconTrash, { size: 14 }), onClick: () => props.onDelete(props.resource), "aria-label": `Delete ${getReferenceString(props.resource)}` }, "Delete")))));
}
function HistoryTimelineItem(props) {
    const previous = getPrevious(props.history, props.resource);
    if (previous) {
        return (React.createElement(TimelineItem, { resource: props.resource, padding: true, popupMenuItems: React.createElement(TimelineItemPopupMenu, { ...props }) },
            React.createElement(ResourceDiffTable, { original: previous, revised: props.resource })));
    }
    else {
        return (React.createElement(TimelineItem, { resource: props.resource, padding: true, popupMenuItems: React.createElement(TimelineItemPopupMenu, { ...props }) },
            React.createElement("h3", null, "Created"),
            React.createElement(ResourceTable, { value: props.resource, ignoreMissingValues: true })));
    }
}
function getPrevious(history, version) {
    const entries = history.entry;
    const index = entries.findIndex((entry) => entry.resource?.meta?.versionId === version.meta?.versionId);
    if (index >= entries.length - 1) {
        return undefined;
    }
    return entries[index + 1].resource;
}
function CommunicationTimelineItem(props) {
    const { classes } = useStyles();
    const routine = !props.resource.priority || props.resource.priority === 'routine';
    const className = routine ? undefined : classes.pinnedComment;
    return (React.createElement(TimelineItem, { resource: props.resource, profile: props.resource.sender, padding: true, className: className, popupMenuItems: React.createElement(TimelineItemPopupMenu, { ...props }) },
        React.createElement("p", null, props.resource.payload?.[0]?.contentString)));
}
function MediaTimelineItem(props) {
    const contentType = props.resource.content?.contentType;
    const padding = contentType &&
        !contentType.startsWith('image/') &&
        !contentType.startsWith('video/') &&
        contentType !== 'application/pdf';
    return (React.createElement(TimelineItem, { resource: props.resource, padding: !!padding, popupMenuItems: React.createElement(TimelineItemPopupMenu, { ...props }) },
        React.createElement(AttachmentDisplay, { value: props.resource.content })));
}
function AuditEventTimelineItem(props) {
    return (React.createElement(TimelineItem, { resource: props.resource, padding: true, popupMenuItems: React.createElement(TimelineItemPopupMenu, { ...props }) },
        React.createElement(ScrollArea, null,
            React.createElement("pre", null, props.resource.outcomeDesc))));
}
function DiagnosticReportTimelineItem(props) {
    return (React.createElement(TimelineItem, { resource: props.resource, padding: true, popupMenuItems: React.createElement(TimelineItemPopupMenu, { ...props }) },
        React.createElement(DiagnosticReportDisplay, { value: props.resource })));
}
function getProgressMessage(e) {
    if (e.lengthComputable) {
        const percent = (100 * e.loaded) / e.total;
        return `Uploaded: ${formatFileSize(e.loaded)} / ${formatFileSize(e.total)} ${percent.toFixed(2)}%`;
    }
    return `Uploaded: ${formatFileSize(e.loaded)}`;
}
function formatFileSize(bytes) {
    if (bytes == 0) {
        return '0.00 B';
    }
    const e = Math.floor(Math.log(bytes) / Math.log(1024));
    return (bytes / Math.pow(1024, e)).toFixed(2) + ' ' + ' KMGTP'.charAt(e) + 'B';
}

export { ResourceTimeline };
//# sourceMappingURL=ResourceTimeline.mjs.map
