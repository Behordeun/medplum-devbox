(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@medplum/core'), require('react'), require('@mantine/core'), require('@tabler/icons'), require('react-router-dom'), require('@mantine/notifications')) :
    typeof define === 'function' && define.amd ? define(['exports', '@medplum/core', 'react', '@mantine/core', '@tabler/icons', 'react-router-dom', '@mantine/notifications'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.medplum = global.medplum || {}, global.medplum.react = {}), global.medplum.core, global.React, global.mantine.core, global.tabler.icons, global.ReactRouterDOM, global.mantine.notifications));
})(this, (function (exports, core, React, core$1, icons, reactRouterDom, notifications) { 'use strict';

    function AddressDisplay(props) {
        const address = props.value;
        if (!address) {
            return null;
        }
        return React.createElement(React.Fragment, null, core.formatAddress(address));
    }

    function getLine(address, index) {
        return address && address.line && address.line.length > index ? address.line[index] : '';
    }
    function setLine(address, index, str) {
        const line = address.line || [];
        while (line.length <= index) {
            line.push('');
        }
        line[index] = str;
        return { ...address, line };
    }
    function AddressInput(props) {
        const [value, setValue] = React.useState(props.defaultValue || {});
        const valueRef = React.useRef();
        valueRef.current = value;
        function setValueWrapper(newValue) {
            setValue(newValue);
            if (props.onChange) {
                props.onChange(newValue);
            }
        }
        function setUse(use) {
            setValueWrapper({ ...valueRef.current, use });
        }
        function setType(type) {
            setValueWrapper({ ...valueRef.current, type });
        }
        function setLine1(line1) {
            setValueWrapper(setLine(valueRef.current || {}, 0, line1));
        }
        function setLine2(line2) {
            setValueWrapper(setLine(valueRef.current || {}, 1, line2));
        }
        function setCity(city) {
            setValueWrapper({ ...valueRef.current, city });
        }
        function setState(state) {
            setValueWrapper({ ...valueRef.current, state });
        }
        function setPostalCode(postalCode) {
            setValueWrapper({ ...valueRef.current, postalCode });
        }
        return (React.createElement(core$1.Group, { spacing: "xs", grow: true, noWrap: true },
            React.createElement(core$1.NativeSelect, { "data-testid": "address-use", defaultValue: value?.use, onChange: (e) => setUse(e.currentTarget.value), data: ['', 'home', 'work', 'temp', 'old', 'billing'] }),
            React.createElement(core$1.NativeSelect, { "data-testid": "address-type", defaultValue: value?.type, onChange: (e) => setType(e.currentTarget.value), data: ['', 'postal', 'physical', 'both'] }),
            React.createElement(core$1.TextInput, { placeholder: "Line 1", defaultValue: getLine(value, 0), onChange: (e) => setLine1(e.currentTarget.value) }),
            React.createElement(core$1.TextInput, { placeholder: "Line 2", defaultValue: getLine(value, 1), onChange: (e) => setLine2(e.currentTarget.value) }),
            React.createElement(core$1.TextInput, { placeholder: "City", defaultValue: value.city, onChange: (e) => setCity(e.currentTarget.value) }),
            React.createElement(core$1.TextInput, { placeholder: "State", defaultValue: value.state, onChange: (e) => setState(e.currentTarget.value) }),
            React.createElement(core$1.TextInput, { placeholder: "Postal Code", defaultValue: value.postalCode, onChange: (e) => setPostalCode(e.currentTarget.value) })));
    }

    const reactContext = React.createContext(undefined);
    /**
     * The MedplumProvider component provides Medplum context state.
     *
     * Medplum context includes:
     *   1) medplum - Medplum client library
     *   2) profile - The current user profile (if signed in)
     */
    function MedplumProvider(props) {
        const medplum = props.medplum;
        const [state, setState] = React.useState({
            profile: medplum.getProfile(),
            loading: false,
        });
        React.useEffect(() => {
            function eventListener() {
                setState({
                    ...state,
                    profile: medplum.getProfile(),
                });
            }
            medplum.addEventListener('change', eventListener);
            return () => medplum.removeEventListeneer('change', eventListener);
        }, [medplum, state]);
        const medplumContext = {
            ...state,
            medplum,
        };
        return React.createElement(reactContext.Provider, { value: medplumContext }, props.children);
    }
    /**
     * Returns the MedplumContext instance.
     */
    function useMedplumContext() {
        return React.useContext(reactContext);
    }
    /**
     * Returns the MedplumClient instance.
     * This is a shortcut for useMedplumContext().medplum.
     */
    function useMedplum() {
        return useMedplumContext().medplum;
    }
    /**
     * Returns the current Medplum user profile (if signed in).
     * This is a shortcut for useMedplumContext().profile.
     * @returns The current user profile.
     */
    function useMedplumProfile() {
        return useMedplumContext().profile;
    }

    function AnnotationInput(props) {
        const author = useMedplumProfile();
        const [value, setValue] = React.useState(props.defaultValue || {});
        const valueRef = React.useRef();
        valueRef.current = value;
        function setText(text) {
            const newValue = text
                ? {
                    text,
                    authorReference: author && core.createReference(author),
                    time: new Date().toISOString(),
                }
                : {};
            setValue(newValue);
            if (props.onChange) {
                props.onChange(newValue);
            }
        }
        return (React.createElement(core$1.TextInput, { name: props.name, placeholder: "Annotation text", defaultValue: value.text, onChange: (e) => setText(e.currentTarget.value) }));
    }

    /**
     * Kills a browser event.
     * Prevents default behavior.
     * Stops event propagation.
     * @param e The event.
     */
    function killEvent(e) {
        e.preventDefault();
        e.stopPropagation();
    }
    /**
     * Returns true if the element is a checkbox or a table cell containing a checkbox.
     * Table cells containing checkboxes are commonly accidentally clicked.
     * @param el The HTML DOM element.
     * @returns True if the element is a checkbox or a table cell containing a checkbox.
     */
    function isCheckboxCell(el) {
        if (isCheckboxElement(el)) {
            return true;
        }
        if (el instanceof HTMLTableCellElement) {
            const children = el.children;
            if (children.length === 1 && isCheckboxElement(children[0])) {
                return true;
            }
        }
        return false;
    }
    function isCheckboxElement(el) {
        return el instanceof HTMLInputElement && el.type === 'checkbox';
    }

    function AsyncAutocomplete(props) {
        const { defaultValue, toKey, toOption, loadOptions, onChange, onCreate, ...rest } = props;
        const defaultItems = toDefaultItems(defaultValue);
        const inputRef = React.useRef(null);
        const [lastValue, setLastValue] = React.useState(undefined);
        const [timer, setTimer] = React.useState();
        const [abortController, setAbortController] = React.useState();
        const [autoSubmit, setAutoSubmit] = React.useState();
        const [options, setOptions] = React.useState(defaultItems?.map(toOption));
        const lastValueRef = React.useRef();
        lastValueRef.current = lastValue;
        const timerRef = React.useRef();
        timerRef.current = timer;
        const abortControllerRef = React.useRef();
        abortControllerRef.current = abortController;
        const autoSubmitRef = React.useRef();
        autoSubmitRef.current = autoSubmit;
        const optionsRef = React.useRef();
        optionsRef.current = options;
        const handleTimer = React.useCallback(() => {
            setTimer(undefined);
            const value = inputRef.current?.value?.trim() || '';
            if (value === lastValueRef.current) {
                // Nothing has changed, move on
                return;
            }
            setLastValue(value);
            const newAbortController = new AbortController();
            setAbortController(newAbortController);
            loadOptions(value, newAbortController.signal)
                .then((newValues) => {
                if (!newAbortController.signal.aborted) {
                    setOptions(newValues.map(toOption));
                    setAbortController(undefined);
                    if (autoSubmitRef.current) {
                        if (newValues.length > 0) {
                            onChange(newValues.slice(0, 1));
                        }
                        setAutoSubmit(false);
                    }
                }
            })
                .catch(console.log);
        }, [loadOptions, onChange, toOption]);
        const handleSearchChange = React.useCallback(() => {
            if (abortControllerRef.current) {
                abortControllerRef.current.abort();
                setAbortController(undefined);
            }
            if (timerRef.current !== undefined) {
                window.clearTimeout(timerRef.current);
            }
            const newTimer = window.setTimeout(() => handleTimer(), 100);
            setTimer(newTimer);
        }, [handleTimer]);
        const handleChange = React.useCallback((values) => {
            const result = [];
            for (const value of values) {
                let item = optionsRef.current?.find((option) => option.value === value)?.resource;
                if (!item) {
                    item = onCreate(value);
                }
                result.push(item);
            }
            onChange(result);
        }, [onChange, onCreate]);
        const handleKeyDown = React.useCallback((e) => {
            if (e.key === 'Enter') {
                if (!timerRef.current && !abortControllerRef.current) {
                    killEvent(e);
                    if (optionsRef.current && optionsRef.current.length > 0) {
                        setOptions(optionsRef.current.slice(0, 1));
                        handleChange([optionsRef.current[0].value]);
                    }
                }
                else {
                    // The user pressed enter, but we don't have results yet.
                    // We need to wait for the results to come in.
                    setAutoSubmit(true);
                }
            }
        }, [handleChange]);
        const handleCreate = React.useCallback((input) => {
            const option = toOption(onCreate(input));
            setOptions([...optionsRef.current, option]);
            return option;
        }, [onCreate, setOptions, toOption]);
        const handleFilter = React.useCallback((_value, selected) => !selected, []);
        React.useEffect(() => {
            return () => {
                if (abortControllerRef.current) {
                    abortControllerRef.current.abort();
                }
            };
        }, []);
        return (React.createElement(core$1.MultiSelect, { ...rest, ref: inputRef, defaultValue: defaultItems.map(toKey), searchable: true, onKeyDown: handleKeyDown, onSearchChange: handleSearchChange, data: options, onFocus: handleTimer, onChange: handleChange, onCreate: handleCreate, rightSectionWidth: 40, rightSection: abortController ? React.createElement(core$1.Loader, { size: 16 }) : null, filter: handleFilter }));
    }
    function toDefaultItems(defaultValue) {
        if (!defaultValue) {
            return [];
        }
        if (Array.isArray(defaultValue)) {
            return defaultValue;
        }
        return [defaultValue];
    }

    function AttachmentDisplay(props) {
        const value = props.value;
        const { contentType, url, title } = value ?? {};
        if (!url) {
            return null;
        }
        return (React.createElement("div", { "data-testid": "attachment-display" },
            contentType?.startsWith('image/') && (React.createElement("img", { "data-testid": "attachment-image", style: { maxWidth: props.maxWidth }, src: url, alt: value?.title })),
            contentType?.startsWith('video/') && (React.createElement("video", { "data-testid": "attachment-video", style: { maxWidth: props.maxWidth }, controls: true },
                React.createElement("source", { type: contentType, src: url }))),
            contentType === 'application/pdf' && !title?.endsWith('.pdf') && (React.createElement("div", { "data-testid": "attachment-pdf", style: { maxWidth: props.maxWidth, minHeight: 400 } },
                React.createElement("iframe", { width: "100%", height: "400", src: url + '#navpanes=0', allowFullScreen: true, frameBorder: 0, seamless: true }))),
            React.createElement("div", { "data-testid": "download-link", style: { padding: '2px 16px 16px 16px' } },
                React.createElement(core$1.Anchor, { href: value?.url, "data-testid": "attachment-details", target: "_blank", rel: "noopener noreferrer" }, value?.title || 'Download'))));
    }

    function AttachmentArrayDisplay(props) {
        return (React.createElement("div", null, props.values &&
            props.values.map((v, index) => (React.createElement("div", { key: 'attatchment-' + index },
                React.createElement(AttachmentDisplay, { value: v, maxWidth: props.maxWidth }))))));
    }

    function AttachmentButton(props) {
        const medplum = useMedplum();
        const fileInputRef = React.useRef(null);
        function onClick(e) {
            killEvent(e);
            fileInputRef.current?.click();
        }
        function onFileChange(e) {
            killEvent(e);
            const files = e.target.files;
            if (files) {
                Array.from(files).forEach(processFile);
            }
        }
        /**
         * Processes a single file.
         *
         * @param {File} file The file descriptor.
         */
        function processFile(file) {
            if (!file) {
                return;
            }
            const fileName = file.name;
            if (!fileName) {
                return;
            }
            if (props.onUploadStart) {
                props.onUploadStart();
            }
            const filename = file.name;
            const contentType = file.type || 'application/octet-stream';
            medplum
                .createBinary(file, filename, contentType, props.onUploadProgress)
                .then((binary) => {
                props.onUpload({
                    contentType: binary.contentType,
                    url: binary.url,
                    title: filename,
                });
            })
                .catch((outcome) => {
                alert(outcome?.issue?.[0]?.details?.text);
            });
        }
        return (React.createElement(React.Fragment, null,
            React.createElement("input", { type: "file", "data-testid": "upload-file-input", style: { display: 'none' }, ref: fileInputRef, onChange: (e) => onFileChange(e) }),
            props.children({ onClick })));
    }

    function AttachmentArrayInput(props) {
        const [values, setValues] = React.useState(props.defaultValue ?? []);
        const valuesRef = React.useRef();
        valuesRef.current = values;
        function setValuesWrapper(newValues) {
            setValues(newValues);
            if (props.onChange) {
                props.onChange(newValues);
            }
        }
        return (React.createElement("table", { style: { width: '100%' } },
            React.createElement("colgroup", null,
                React.createElement("col", { width: "97%" }),
                React.createElement("col", { width: "3%" })),
            React.createElement("tbody", null,
                values.map((v, index) => (React.createElement("tr", { key: `${index}-${values.length}` },
                    React.createElement("td", null,
                        React.createElement(AttachmentDisplay, { value: v, maxWidth: 200 })),
                    React.createElement("td", null,
                        React.createElement(core$1.ActionIcon, { title: "Remove", size: "sm", onClick: (e) => {
                                killEvent(e);
                                const copy = values.slice();
                                copy.splice(index, 1);
                                setValuesWrapper(copy);
                            } },
                            React.createElement(icons.IconCircleMinus, null)))))),
                React.createElement("tr", null,
                    React.createElement("td", null),
                    React.createElement("td", null,
                        React.createElement(AttachmentButton, { onUpload: (attachment) => {
                                setValuesWrapper([...valuesRef.current, attachment]);
                            } }, (props) => (React.createElement(core$1.ActionIcon, { ...props, title: "Add", size: "sm", color: "green" },
                            React.createElement(icons.IconCloudUpload, { size: 16 })))))))));
    }

    function AttachmentInput(props) {
        const [value, setValue] = React.useState(props.defaultValue);
        function setValueWrapper(newValue) {
            setValue(newValue);
            if (props.onChange) {
                props.onChange(newValue);
            }
        }
        if (value) {
            return (React.createElement(React.Fragment, null,
                React.createElement(AttachmentDisplay, { value: value, maxWidth: 200 }),
                React.createElement(core$1.Button, { onClick: (e) => {
                        killEvent(e);
                        setValueWrapper(undefined);
                    } }, "Remove")));
        }
        return (React.createElement(AttachmentButton, { onUpload: setValueWrapper }, (props) => React.createElement(core$1.Button, { ...props }, "Upload...")));
    }

    const useStyles$d = core$1.createStyles(() => ({
        root: {
            '@media (max-width: 800px)': {
                paddingLeft: 4,
                paddingRight: 4,
            },
        },
    }));
    function Container(props) {
        const { children, ...others } = props;
        const { classes } = useStyles$d();
        return (React.createElement(core$1.Container, { className: classes.root, ...others }, children));
    }

    const useStyles$c = core$1.createStyles((theme, { width, fill }) => ({
        paper: {
            maxWidth: width,
            margin: `${theme.spacing.xl}px auto`,
            padding: fill ? 0 : theme.spacing.md,
            '@media (max-width: 800px)': {
                padding: fill ? 0 : 8,
            },
            '& img': {
                width: '100%',
                maxWidth: '100%',
            },
            '& video': {
                width: '100%',
                maxWidth: '100%',
            },
        },
    }));
    const defaultProps$1 = {
        shadow: 'xs',
        radius: 'md',
        withBorder: true,
    };
    function Panel(props) {
        const { className, children, width, fill, unstyled, ...others } = core$1.useComponentDefaultProps('Panel', defaultProps$1, props);
        const { classes, cx } = useStyles$c({ width, fill }, { name: 'Panel', unstyled });
        return (React.createElement(core$1.Paper, { className: cx(classes.paper, className), ...others }, children));
    }

    function Document(props) {
        const { children, ...others } = props;
        return (React.createElement(Container, null,
            React.createElement(Panel, { ...others }, children)));
    }

    /**
     * Parses an HTML form and returns the result as a JavaScript object.
     * @param form The HTML form element.
     */
    function parseForm(form) {
        const result = {};
        for (const element of Array.from(form.elements)) {
            if (element instanceof HTMLInputElement) {
                parseInputElement(result, element);
            }
            else if (element instanceof HTMLTextAreaElement) {
                result[element.name] = element.value;
            }
            else if (element instanceof HTMLSelectElement) {
                parseSelectElement(result, element);
            }
        }
        return result;
    }
    /**
     * Parses an HTML input element.
     * Sets the name/value pair in the result,
     * but only if the element is enabled and checked.
     * @param el The input element.
     * @param result The result builder.
     */
    function parseInputElement(result, el) {
        if (el.disabled) {
            // Ignore disabled elements
            return;
        }
        if ((el.type === 'checkbox' || el.type === 'radio') && !el.checked) {
            // Ignore unchecked radio or checkbox elements
            return;
        }
        result[el.name] = el.value;
    }
    /**
     * Parses an HTML select element.
     * Sets the name/value pair if one is selected.
     * @param result The result builder.
     * @param el The select element.
     */
    function parseSelectElement(result, el) {
        result[el.name] = el.value;
    }

    function Form(props) {
        return (React.createElement("form", { style: props.style, "data-testid": props.testid, onSubmit: (e) => {
                e.preventDefault();
                const formData = parseForm(e.target);
                if (props.onSubmit) {
                    props.onSubmit(formData);
                }
            } }, props.children));
    }

    function Logo(props) {
        return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 491 491", style: { width: props.size, height: props.size } },
            React.createElement("title", null, "Medplum Logo"),
            React.createElement("path", { fill: props.fill || '#ad7136', d: "M282 67c6-16 16-29 29-40L289 0c-22 17-37 41-43 68l17 23 19-24z" }),
            React.createElement("path", { fill: props.fill || '#946af9', d: "M311 63c-17 0-33 4-48 11-16-7-32-11-49-11-87 0-158 96-158 214s71 214 158 214c17 0 33-4 49-11 15 7 31 11 48 11 87 0 158-96 158-214S398 63 311 63z" }),
            React.createElement("path", { fill: props.fill || '#7857c5', d: "M231 489l-17 2c-87 0-158-96-158-214S127 63 214 63l17 1c-39 12-70 102-70 213s31 201 70 212z" }),
            React.createElement("path", { fill: props.fill || '#40bc26', d: "M207 220a176 176 0 01-177 43A176 176 0 01251 43l1 5c17 59 2 125-45 172z" }),
            React.createElement("path", { fill: props.fill || '#33961e', d: "M252 48A421 421 0 0057 270l-27-7A176 176 0 01251 43l1 5z" })));
    }

    function getErrorsForInput(outcome, expression) {
        return outcome?.issue
            ?.filter((issue) => isExpressionMatch(issue.expression?.[0], expression))
            ?.map((issue) => issue.details?.text)
            ?.join('\n');
    }
    function getIssuesForExpression(outcome, expression) {
        return outcome?.issue?.filter((issue) => isExpressionMatch(issue.expression?.[0], expression));
    }
    function isExpressionMatch(expr1, expr2) {
        // Expression can be either "fieldName" or "resourceType.fieldName"
        if (expr1 === expr2) {
            return true;
        }
        if (!expr1 || !expr2) {
            return false;
        }
        const dot1 = expr1.indexOf('.');
        if (dot1 >= 0 && expr1.substring(dot1 + 1) === expr2) {
            return true;
        }
        const dot2 = expr2.indexOf('.');
        if (dot2 >= 0 && expr2.substring(dot2 + 1) === expr1) {
            return true;
        }
        return false;
    }

    function NewProjectForm(props) {
        const medplum = useMedplum();
        const [outcome, setOutcome] = React.useState();
        return (React.createElement(Form, { style: { maxWidth: 400 }, onSubmit: async (formData) => {
                try {
                    props.handleAuthResponse(await medplum.startNewProject({
                        login: props.login,
                        projectName: formData.projectName,
                    }));
                }
                catch (err) {
                    setOutcome(err);
                }
            } },
            React.createElement(core$1.Center, { sx: { flexDirection: 'column' } },
                React.createElement(Logo, { size: 32 }),
                React.createElement(core$1.Title, null, "Create project")),
            React.createElement(core$1.Stack, { spacing: "xl" },
                React.createElement(core$1.TextInput, { name: "projectName", label: "Project Name", placeholder: "My Project", required: true, autoFocus: true, error: getErrorsForInput(outcome, 'firstName') }),
                React.createElement(core$1.Text, { color: "dimmed", size: "xs" },
                    "By clicking submit you agree to the Medplum",
                    ' ',
                    React.createElement(core$1.Anchor, { href: "https://www.medplum.com/privacy" }, "Privacy\u00A0Policy"),
                    ' and ',
                    React.createElement(core$1.Anchor, { href: "https://www.medplum.com/terms" }, "Terms\u00A0of\u00A0Service"),
                    ".")),
            React.createElement(core$1.Group, { position: "right", mt: "xl", noWrap: true },
                React.createElement(core$1.Button, { type: "submit" }, "Create project"))));
    }

    /**
     * Dynamically creates a script tag for the specified JavaScript file.
     * @param src The JavaScript file URL.
     */
    function createScriptTag(src, onload) {
        const head = document.getElementsByTagName('head')[0];
        const script = document.createElement('script');
        script.async = true;
        script.src = src;
        script.onload = onload || null;
        head.appendChild(script);
    }

    function GoogleButton(props) {
        const medplum = useMedplum();
        const { googleClientId, handleGoogleCredential } = props;
        const parentRef = React.useRef(null);
        const [scriptLoaded, setScriptLoaded] = React.useState(typeof google !== 'undefined');
        const [initialized, setInitialized] = React.useState(false);
        const [buttonRendered, setButtonRendered] = React.useState(false);
        React.useEffect(() => {
            if (typeof google === 'undefined') {
                createScriptTag('https://accounts.google.com/gsi/client', () => setScriptLoaded(true));
                return;
            }
            if (!initialized) {
                google.accounts.id.initialize({
                    client_id: googleClientId,
                    callback: handleGoogleCredential,
                });
                setInitialized(true);
            }
            if (parentRef.current && !buttonRendered) {
                google.accounts.id.renderButton(parentRef.current, {});
                setButtonRendered(true);
            }
        }, [medplum, googleClientId, initialized, scriptLoaded, parentRef, buttonRendered, handleGoogleCredential]);
        if (!googleClientId) {
            return null;
        }
        return React.createElement("div", { ref: parentRef });
    }
    function getGoogleClientId(clientId) {
        if (clientId) {
            return clientId;
        }
        const origin = window.location.protocol + '//' + window.location.host;
        const authorizedOrigins = "http://localhost:3000,http://127.0.0.1:3000,http://localhost:6006,http://127.0.0.1:6006,https://app.medplum.com,https://docs.medplum.com,https://storybook.medplum.com,https://graphiql.medplum.com,https://www.medplum.com"?.split(',') ?? [];
        if (authorizedOrigins.includes(origin)) {
            return "921088377005-3j1sa10vr6hj86jgmdfh2l53v3mp7lfi.apps.googleusercontent.com";
        }
        return undefined;
    }

    /**
     * Dynamically loads the recaptcha script.
     * We do not want to load the script on page load unless the user needs it.
     * @param siteKey The reCAPTCHA site key, available from the reCAPTCHA admin page.
     */
    function initRecaptcha(siteKey) {
        if (typeof grecaptcha === 'undefined') {
            createScriptTag('https://www.google.com/recaptcha/api.js?render=' + siteKey);
        }
    }
    /**
     * Starts a request to generate a recapcha token.
     * @param siteKey The reCAPTCHA site key, available from the reCAPTCHA admin page.
     * @returns Promise to a recaptcha token for the current user.
     */
    function getRecaptcha(siteKey) {
        return new Promise((resolve, reject) => {
            grecaptcha.ready(async () => {
                try {
                    resolve(await grecaptcha.execute(siteKey, { action: 'submit' }));
                }
                catch (err) {
                    reject(err);
                }
            });
        });
    }

    function NewUserForm(props) {
        const googleClientId = getGoogleClientId(props.googleClientId);
        const recaptchaSiteKey = props.recaptchaSiteKey;
        const medplum = useMedplum();
        const [outcome, setOutcome] = React.useState();
        const issues = getIssuesForExpression(outcome, undefined);
        React.useEffect(() => initRecaptcha(recaptchaSiteKey), [recaptchaSiteKey]);
        return (React.createElement(Form, { style: { maxWidth: 400 }, onSubmit: async (formData) => {
                try {
                    const recaptchaToken = await getRecaptcha(recaptchaSiteKey);
                    props.handleAuthResponse(await medplum.startNewUser({
                        projectId: props.projectId,
                        firstName: formData.firstName,
                        lastName: formData.lastName,
                        email: formData.email,
                        password: formData.password,
                        remember: formData.remember === 'true',
                        recaptchaSiteKey,
                        recaptchaToken,
                    }));
                }
                catch (err) {
                    setOutcome(err);
                }
            } },
            React.createElement(core$1.Center, { sx: { flexDirection: 'column' } }, props.children),
            issues && (React.createElement(core$1.Alert, { icon: React.createElement(icons.IconAlertCircle, { size: 16 }), color: "red" }, issues.map((issue) => (React.createElement("div", { "data-testid": "text-field-error", key: issue.details?.text }, issue.details?.text))))),
            googleClientId && (React.createElement(React.Fragment, null,
                React.createElement(core$1.Group, { position: "center", p: "xl", style: { height: 70 } },
                    React.createElement(GoogleButton, { googleClientId: googleClientId, handleGoogleCredential: async (response) => {
                            try {
                                await medplum.startPkce();
                                props.handleAuthResponse(await medplum.startGoogleLogin({
                                    googleClientId: response.clientId,
                                    googleCredential: response.credential,
                                    createUser: true,
                                }));
                            }
                            catch (err) {
                                setOutcome(err);
                            }
                        } })),
                React.createElement(core$1.Divider, { label: "or", labelPosition: "center", my: "lg" }))),
            React.createElement(core$1.Stack, { spacing: "xl" },
                React.createElement(core$1.TextInput, { name: "firstName", type: "text", label: "First name", placeholder: "First name", required: true, autoFocus: true, error: getErrorsForInput(outcome, 'firstName') }),
                React.createElement(core$1.TextInput, { name: "lastName", type: "text", label: "Last name", placeholder: "Last name", required: true, error: getErrorsForInput(outcome, 'lastName') }),
                React.createElement(core$1.TextInput, { name: "email", type: "email", label: "Email", placeholder: "name@domain.com", required: true, error: getErrorsForInput(outcome, 'email') }),
                React.createElement(core$1.PasswordInput, { name: "password", label: "Password", autoComplete: "off", required: true, error: getErrorsForInput(outcome, 'password') }),
                React.createElement(core$1.Text, { color: "dimmed", size: "xs" },
                    "By clicking submit you agree to the Medplum",
                    ' ',
                    React.createElement(core$1.Anchor, { href: "https://www.medplum.com/privacy" }, "Privacy\u00A0Policy"),
                    ' and ',
                    React.createElement(core$1.Anchor, { href: "https://www.medplum.com/terms" }, "Terms\u00A0of\u00A0Service"),
                    "."),
                React.createElement(core$1.Text, { color: "dimmed", size: "xs" },
                    "This site is protected by reCAPTCHA and the Google",
                    ' ',
                    React.createElement(core$1.Anchor, { href: "https://policies.google.com/privacy" }, "Privacy\u00A0Policy"),
                    ' and ',
                    React.createElement(core$1.Anchor, { href: "https://policies.google.com/terms" }, "Terms\u00A0of\u00A0Service"),
                    " apply.")),
            React.createElement(core$1.Group, { position: "apart", mt: "xl", noWrap: true },
                React.createElement(core$1.Checkbox, { name: "remember", label: "Remember me", size: "xs" }),
                React.createElement(core$1.Button, { type: "submit" }, "Create account"))));
    }

    function RegisterForm(props) {
        const { type, projectId, googleClientId, recaptchaSiteKey, onSuccess } = props;
        const medplum = useMedplum();
        const [login, setLogin] = React.useState(undefined);
        const [outcome, setOutcome] = React.useState();
        React.useEffect(() => {
            if (type === 'patient' && login) {
                medplum
                    .startNewPatient({ login, projectId: projectId })
                    .then((response) => medplum.processCode(response.code))
                    .then(() => onSuccess())
                    .catch((err) => setOutcome(err));
            }
        }, [medplum, type, projectId, login, onSuccess]);
        function handleAuthResponse(response) {
            if (response.code) {
                medplum
                    .processCode(response.code)
                    .then(() => onSuccess())
                    .catch(console.log);
            }
            else if (response.login) {
                setLogin(response.login);
            }
        }
        return (React.createElement(Document, { width: 450 },
            outcome && React.createElement("pre", null, JSON.stringify(outcome, null, 2)),
            !login && (React.createElement(NewUserForm, { projectId: projectId, googleClientId: googleClientId, recaptchaSiteKey: recaptchaSiteKey, handleAuthResponse: handleAuthResponse }, props.children)),
            login && type === 'project' && React.createElement(NewProjectForm, { login: login, handleAuthResponse: handleAuthResponse })));
    }

    function AuthenticationForm(props) {
        const { generatePkce, onForgotPassword, onRegister, handleAuthResponse, children, ...baseLoginRequest } = props;
        const medplum = useMedplum();
        const googleClientId = getGoogleClientId(props.googleClientId);
        const [outcome, setOutcome] = React.useState();
        const issues = getIssuesForExpression(outcome, undefined);
        async function startPkce() {
            if (generatePkce) {
                await medplum.startPkce();
            }
        }
        return (React.createElement(Form, { style: { maxWidth: 400 }, onSubmit: (formData) => {
                startPkce()
                    .then(() => medplum.startLogin({
                    ...baseLoginRequest,
                    email: formData.email,
                    password: formData.password,
                    remember: formData.remember === 'on',
                }))
                    .then(handleAuthResponse)
                    .catch(setOutcome);
            } },
            React.createElement(core$1.Center, { sx: { flexDirection: 'column' } }, children),
            issues && (React.createElement(core$1.Alert, { icon: React.createElement(icons.IconAlertCircle, { size: 16 }), color: "red" }, issues.map((issue) => (React.createElement("div", { "data-testid": "text-field-error", key: issue.details?.text }, issue.details?.text))))),
            googleClientId && (React.createElement(React.Fragment, null,
                React.createElement(core$1.Group, { position: "center", p: "xl", style: { height: 70 } },
                    React.createElement(GoogleButton, { googleClientId: googleClientId, handleGoogleCredential: (response) => {
                            startPkce()
                                .then(() => medplum.startGoogleLogin({
                                ...baseLoginRequest,
                                googleCredential: response.credential,
                            }))
                                .then(props.handleAuthResponse)
                                .catch(setOutcome);
                        } })),
                React.createElement(core$1.Divider, { label: "or", labelPosition: "center", my: "lg" }))),
            React.createElement(core$1.Stack, { spacing: "xl" },
                React.createElement(core$1.TextInput, { name: "email", type: "email", label: "Email", placeholder: "name@domain.com", required: true, autoFocus: true, error: getErrorsForInput(outcome, 'email') }),
                React.createElement(core$1.PasswordInput, { name: "password", type: "password", label: "Password", autoComplete: "off", required: true, error: getErrorsForInput(outcome, 'password') })),
            React.createElement(core$1.Group, { position: "apart", mt: "xl", spacing: 0, noWrap: true },
                onForgotPassword && (React.createElement(core$1.Anchor, { component: "button", type: "button", color: "dimmed", onClick: onForgotPassword, size: "xs" }, "Forgot password")),
                onRegister && (React.createElement(core$1.Anchor, { component: "button", type: "button", color: "dimmed", onClick: onRegister, size: "xs" }, "Register")),
                React.createElement(core$1.Checkbox, { id: "remember", name: "remember", label: "Remember me", size: "xs", sx: { lineHeight: 1 } }),
                React.createElement(core$1.Button, { type: "submit" }, "Sign in"))));
    }

    function ChooseProfileForm(props) {
        const medplum = useMedplum();
        return (React.createElement(core$1.Stack, null,
            React.createElement(core$1.Center, { sx: { flexDirection: 'column' } },
                React.createElement(Logo, { size: 32 }),
                React.createElement(core$1.Title, null, "Choose profile")),
            props.memberships.map((membership) => (React.createElement(core$1.UnstyledButton, { key: membership.id, onClick: () => {
                    medplum
                        .post('auth/profile', {
                        login: props.login,
                        profile: membership.id,
                    })
                        .then(props.handleAuthResponse)
                        .catch(console.log);
                } },
                React.createElement(core$1.Group, null,
                    React.createElement(core$1.Avatar, { radius: "xl" }),
                    React.createElement("div", { style: { flex: 1 } },
                        React.createElement(core$1.Text, { size: "sm", weight: 500 }, membership.profile?.display),
                        React.createElement(core$1.Text, { color: "dimmed", size: "xs" }, membership.project?.display))))))));
    }

    function ChooseScopeForm(props) {
        const medplum = useMedplum();
        return (React.createElement(Form, { style: { maxWidth: 400 }, onSubmit: (formData) => {
                medplum
                    .post('auth/scope', {
                    login: props.login,
                    scope: Object.keys(formData).join(' '),
                })
                    .then(props.handleAuthResponse)
                    .catch(console.log);
            } },
            React.createElement(core$1.Stack, null,
                React.createElement(core$1.Center, { sx: { flexDirection: 'column' } },
                    React.createElement(Logo, { size: 32 }),
                    React.createElement(core$1.Title, null, "Choose scope")),
                React.createElement(core$1.Stack, null, (props.scope || 'openid').split(' ').map((scopeName) => (React.createElement(core$1.Checkbox, { key: scopeName, id: scopeName, name: scopeName, label: scopeName, defaultChecked: true })))),
                React.createElement(core$1.Group, { position: "right", mt: "xl" },
                    React.createElement(core$1.Button, { type: "submit" }, "Set scope")))));
    }

    function MfaForm(props) {
        const medplum = useMedplum();
        const [errorMessage, setErrorMessage] = React.useState(undefined);
        return (React.createElement(Form, { style: { maxWidth: 400 }, onSubmit: (formData) => {
                setErrorMessage(undefined);
                medplum
                    .post('auth/mfa/verify', {
                    login: props.login,
                    token: formData.token,
                })
                    .then(props.handleAuthResponse)
                    .catch((err) => setErrorMessage(core.normalizeErrorString(err)));
            } },
            React.createElement(core$1.Stack, null,
                React.createElement(core$1.Center, { sx: { flexDirection: 'column' } },
                    React.createElement(Logo, { size: 32 }),
                    React.createElement(core$1.Title, null, "Enter MFA code")),
                errorMessage && (React.createElement(core$1.Alert, { icon: React.createElement(icons.IconAlertCircle, { size: 16 }), title: "Error", color: "red" }, errorMessage)),
                React.createElement(core$1.Stack, null,
                    React.createElement(core$1.TextInput, { name: "token", label: "MFA code", required: true })),
                React.createElement(core$1.Group, { position: "right", mt: "xl" },
                    React.createElement(core$1.Button, { type: "submit" }, "Submit code")))));
    }

    /**
     * The SignInForm component allows users to sign in to Medplum.
     *
     * "Signing in" is a multi-step process:
     * 1) Authentication - identify the user
     * 2) MFA - If MFA is enabled, prompt for MFA code
     * 3) Choose profile - If the user has multiple profiles, prompt to choose one
     * 4) Choose scope - If the user has multiple scopes, prompt to choose one
     * 5) Success - Return to the caller with either a code or a redirect
     */
    function SignInForm(props) {
        const { chooseScopes, onSuccess, onForgotPassword, onRegister, onCode, ...baseLoginRequest } = props;
        const medplum = useMedplum();
        const [login, setLogin] = React.useState(undefined);
        const [mfaRequired, setAuthenticatorRequired] = React.useState(false);
        const [memberships, setMemberships] = React.useState(undefined);
        function handleAuthResponse(response) {
            setAuthenticatorRequired(!!response.mfaRequired);
            if (response.login) {
                setLogin(response.login);
            }
            if (response.memberships) {
                setMemberships(response.memberships);
            }
            if (response.code) {
                if (chooseScopes) {
                    setMemberships(undefined);
                }
                else {
                    handleCode(response.code);
                }
            }
        }
        function handleScopeResponse(response) {
            handleCode(response.code);
        }
        function handleCode(code) {
            if (onCode) {
                onCode(code);
            }
            else {
                medplum
                    .processCode(code)
                    .then(() => {
                    if (onSuccess) {
                        onSuccess();
                    }
                })
                    .catch(console.log);
            }
        }
        return (React.createElement(Document, { width: 450 }, (() => {
            if (!login) {
                return (React.createElement(AuthenticationForm, { generatePkce: !onCode, onForgotPassword: onForgotPassword, onRegister: onRegister, handleAuthResponse: handleAuthResponse, ...baseLoginRequest }, props.children));
            }
            else if (mfaRequired) {
                return React.createElement(MfaForm, { login: login, handleAuthResponse: handleAuthResponse });
            }
            else if (memberships) {
                return React.createElement(ChooseProfileForm, { login: login, memberships: memberships, handleAuthResponse: handleAuthResponse });
            }
            else if (props.projectId === 'new') {
                return React.createElement(NewProjectForm, { login: login, handleAuthResponse: handleAuthResponse });
            }
            else if (props.chooseScopes) {
                return React.createElement(ChooseScopeForm, { login: login, scope: props.scope, handleAuthResponse: handleScopeResponse });
            }
            else {
                return React.createElement("div", null, "Success");
            }
        })()));
    }

    const DEFAULT_IGNORED_PROPERTIES = [
        'meta',
        'implicitRules',
        'language',
        'text',
        'contained',
        'extension',
        'modifierExtension',
    ];

    const useStyles$b = core$1.createStyles((theme) => ({
        root: {
            display: 'grid',
            gridTemplateColumns: '30% 70%',
            margin: 0,
            '& > dt, & > dd': {
                padding: `${theme.spacing.sm}px ${theme.spacing.sm}px`,
                borderTop: `0.1px solid ${theme.colors.gray[3]}`,
                margin: 0,
            },
        },
        compact: {
            gridTemplateColumns: '20% 80%',
            '& > dt, & > dd': {
                padding: `0 ${theme.spacing.xs}px ${theme.spacing.xs}px 0`,
                border: 0,
            },
        },
    }));
    function DescriptionList(props) {
        const { children, compact } = props;
        const { classes, cx } = useStyles$b();
        return React.createElement("dl", { className: cx(classes.root, { [classes.compact]: compact }) }, children);
    }
    function DescriptionListEntry(props) {
        return (React.createElement(React.Fragment, null,
            React.createElement("dt", null, props.term),
            React.createElement("dd", null, props.children)));
    }

    function CodeableConceptDisplay(props) {
        return React.createElement(React.Fragment, null, core.formatCodeableConcept(props.value));
    }

    function CodingDisplay(props) {
        return React.createElement(React.Fragment, null, core.formatCoding(props.value));
    }

    function ContactPointDisplay(props) {
        const contactPoint = props.value;
        if (!contactPoint) {
            return null;
        }
        const builder = [];
        if (contactPoint.value) {
            builder.push(contactPoint.value);
        }
        if (contactPoint.use || contactPoint.system) {
            builder.push(' [');
            if (contactPoint.use) {
                builder.push(contactPoint.use);
            }
            if (contactPoint.use && contactPoint.system) {
                builder.push(' ');
            }
            if (contactPoint.system) {
                builder.push(contactPoint.system);
            }
            builder.push(']');
        }
        return React.createElement(React.Fragment, null, builder.join('').trim());
    }

    function ContactDetailDisplay(props) {
        const contactDetail = props.value;
        if (!contactDetail) {
            return null;
        }
        return (React.createElement(React.Fragment, null,
            contactDetail.name,
            contactDetail.name && ': ',
            contactDetail.telecom?.map((telecom, index) => (React.createElement(ContactPointDisplay, { key: 'telecom-' + index, value: telecom })))));
    }

    function HumanNameDisplay(props) {
        const name = props.value;
        if (!name) {
            return null;
        }
        return React.createElement(React.Fragment, null, core.formatHumanName(name, props.options));
    }

    function IdentifierDisplay(props) {
        return (React.createElement("div", null,
            props.value?.system,
            ": ",
            props.value?.value));
    }

    function MoneyDisplay(props) {
        return React.createElement(React.Fragment, null, core.formatMoney(props.value));
    }

    function QuantityDisplay(props) {
        return React.createElement(React.Fragment, null, core.formatQuantity(props.value));
    }

    function RangeDisplay(props) {
        return React.createElement(React.Fragment, null, core.formatRange(props.value));
    }

    function RatioDisplay(props) {
        const value = props.value;
        if (!value) {
            return null;
        }
        return (React.createElement(React.Fragment, null,
            React.createElement(QuantityDisplay, { value: value.numerator }),
            "\u00A0/\u00A0",
            React.createElement(QuantityDisplay, { value: value.denominator })));
    }

    function MedplumLink(props) {
        const navigate = reactRouterDom.useNavigate();
        const { to, suffix, label, onClick, children, ...rest } = props;
        let href = getHref(to);
        if (suffix) {
            href += '/' + suffix;
        }
        return (React.createElement(core$1.Anchor, { href: href, "aria-label": label, onClick: (e) => {
                killEvent(e);
                if (onClick) {
                    onClick();
                }
                else if (to) {
                    navigate(href);
                }
            }, ...rest }, children));
    }
    function getHref(to) {
        if (to) {
            if (typeof to === 'string') {
                return getStringHref(to);
            }
            else if ('resourceType' in to) {
                return getResourceHref(to);
            }
            else if ('reference' in to) {
                return getReferenceHref(to);
            }
        }
        return '#';
    }
    function getStringHref(to) {
        if (to.startsWith('http://') || to.startsWith('https://') || to.startsWith('/')) {
            return to;
        }
        return '/' + to;
    }
    function getResourceHref(to) {
        return `/${to.resourceType}/${to.id}`;
    }
    function getReferenceHref(to) {
        return `/${to.reference}`;
    }

    function ReferenceDisplay(props) {
        if (!props.value) {
            return null;
        }
        const displayString = props.value.display || props.value.reference || core.stringify(props.value);
        // The "link" prop defaults to "true"; undefined is treated as "true"
        // To disable the link, it must be explicitly "false"
        if (props.link !== false && props.value.reference) {
            return React.createElement(MedplumLink, { to: props.value }, displayString);
        }
        else {
            return React.createElement(React.Fragment, null, displayString);
        }
    }

    function ResourceArrayDisplay(props) {
        const property = props.property;
        const values = props.values ?? [];
        const propertyType = property.type?.[0]?.code;
        return (React.createElement(React.Fragment, null, values.map((v, index) => (React.createElement("div", { key: `${index}-${values.length}` },
            React.createElement(ResourcePropertyDisplay, { arrayElement: true, property: property, propertyType: propertyType, value: v, ignoreMissingValues: props.ignoreMissingValues, link: props.link }))))));
    }

    function ResourcePropertyDisplay(props) {
        const { property, propertyType, value } = props;
        if (property?.max === '*' && !props.arrayElement) {
            if (propertyType === 'Attachment') {
                return React.createElement(AttachmentArrayDisplay, { values: value, maxWidth: props.maxWidth });
            }
            return (React.createElement(ResourceArrayDisplay, { property: property, values: value, ignoreMissingValues: props.ignoreMissingValues, link: props.link }));
        }
        switch (propertyType) {
            case core.PropertyType.boolean:
                return React.createElement(React.Fragment, null, value === undefined ? '' : Boolean(value).toString());
            case core.PropertyType.SystemString:
            case core.PropertyType.code:
            case core.PropertyType.date:
            case core.PropertyType.integer:
            case core.PropertyType.positiveInt:
            case core.PropertyType.string:
            case core.PropertyType.unsignedInt:
            case core.PropertyType.uri:
            case core.PropertyType.url:
                return React.createElement(React.Fragment, null, value);
            case core.PropertyType.canonical:
                return React.createElement(ReferenceDisplay, { value: { reference: value }, link: props.link });
            case core.PropertyType.dateTime:
            case core.PropertyType.instant:
                return React.createElement(React.Fragment, null, core.formatDateTime(value));
            case core.PropertyType.markdown:
                return React.createElement("pre", null, value);
            case core.PropertyType.Address:
                return React.createElement(AddressDisplay, { value: value });
            case core.PropertyType.Annotation:
                return React.createElement(React.Fragment, null, value?.text);
            case core.PropertyType.Attachment:
                return React.createElement(AttachmentDisplay, { value: value, maxWidth: props.maxWidth });
            case core.PropertyType.CodeableConcept:
                return React.createElement(CodeableConceptDisplay, { value: value });
            case core.PropertyType.Coding:
                return React.createElement(CodingDisplay, { value: value });
            case core.PropertyType.ContactDetail:
                return React.createElement(ContactDetailDisplay, { value: value });
            case core.PropertyType.ContactPoint:
                return React.createElement(ContactPointDisplay, { value: value });
            case core.PropertyType.HumanName:
                return React.createElement(HumanNameDisplay, { value: value });
            case core.PropertyType.Identifier:
                return React.createElement(IdentifierDisplay, { value: value });
            case core.PropertyType.Money:
                return React.createElement(MoneyDisplay, { value: value });
            case core.PropertyType.Period:
                return React.createElement(React.Fragment, null, core.formatPeriod(value));
            case core.PropertyType.Quantity:
            case core.PropertyType.Duration:
                return React.createElement(QuantityDisplay, { value: value });
            case core.PropertyType.Range:
                return React.createElement(RangeDisplay, { value: value });
            case core.PropertyType.Ratio:
                return React.createElement(RatioDisplay, { value: value });
            case core.PropertyType.Reference:
                return React.createElement(ReferenceDisplay, { value: value, link: props.link });
            case core.PropertyType.Timing:
                return React.createElement(React.Fragment, null, core.formatTiming(value));
            case core.PropertyType.Dosage:
            case core.PropertyType.UsageContext:
                return (React.createElement(BackboneElementDisplay, { value: { type: propertyType, value }, compact: true, ignoreMissingValues: props.ignoreMissingValues }));
            default:
                if (!property?.path) {
                    throw Error(`Displaying property of type ${props.propertyType} requires element definition path`);
                }
                return (React.createElement(BackboneElementDisplay, { value: { type: core.buildTypeName(property?.path?.split('.')), value }, compact: true, ignoreMissingValues: props.ignoreMissingValues }));
        }
    }
    /**
     * Returns the value of the property and the property type.
     * Some property definitions support multiple types.
     * For example, "Observation.value[x]" can be "valueString", "valueInteger", "valueQuantity", etc.
     * According to the spec, there can only be one property for a given element definition.
     * This function returns the value and the type.
     * @param context The base context (usually a FHIR resource).
     * @param property The property definition.
     * @returns The value of the property and the property type.
     */
    function getValueAndType(context, path) {
        const typedResult = core.getTypedPropertyValue(context, path);
        if (!typedResult) {
            return [undefined, 'undefined'];
        }
        if (Array.isArray(typedResult)) {
            return [typedResult.map((e) => e.value), typedResult[0].type];
        }
        return [typedResult.value, typedResult.type];
    }

    function BackboneElementDisplay(props) {
        const typedValue = props.value;
        const value = typedValue.value;
        if (!value) {
            return null;
        }
        const typeName = typedValue.type;
        const typeSchema = core.globalSchema.types[typeName];
        if (!typeSchema) {
            return React.createElement("div", null,
                typeName,
                "\u00A0not implemented");
        }
        if (typeof value === 'object' &&
            'name' in value &&
            Object.keys(value).length === 1 &&
            typeof value.name === 'string') {
            // Special case for common BackboneElement pattern
            // Where there is an object with a single property 'name'
            // Just display the name value.
            return React.createElement("div", null, value.name);
        }
        return (React.createElement(DescriptionList, { compact: props.compact }, Object.entries(typeSchema.properties).map((entry) => {
            const key = entry[0];
            if (DEFAULT_IGNORED_PROPERTIES.indexOf(key) >= 0) {
                return null;
            }
            const property = entry[1];
            if (!property.path) {
                property.path = typeName + '.' + key;
            }
            const [propertyValue, propertyType] = getValueAndType(typedValue, key);
            if (props.ignoreMissingValues &&
                (!propertyValue || (Array.isArray(propertyValue) && propertyValue.length === 0))) {
                return null;
            }
            return (React.createElement(DescriptionListEntry, { key: key, term: core.getPropertyDisplayName(key) },
                React.createElement(ResourcePropertyDisplay, { property: property, propertyType: propertyType, value: propertyValue, ignoreMissingValues: props.ignoreMissingValues, link: props.link })));
        })));
    }

    function CheckboxFormSection(props) {
        return (React.createElement(core$1.Group, { noWrap: true },
            React.createElement("div", null, props.children),
            React.createElement("div", null,
                React.createElement(core$1.Input.Wrapper, { id: props.htmlFor, label: props.title, description: props.description }, (() => null)()))));
    }

    function FormSection(props) {
        return (React.createElement(core$1.Input.Wrapper, { id: props.htmlFor, label: props.title, description: props.description, error: getErrorsForInput(props.outcome, props.htmlFor) }, props.children));
    }

    const system = {
        resourceType: 'Device',
        id: 'system',
        deviceName: [
            {
                name: 'System',
            },
        ],
    };
    /**
     * React Hook to use a FHIR reference.
     * Handles the complexity of resolving references and caching resources.
     * @param value The resource or reference to resource.
     * @returns The resolved resource.
     */
    function useResource(value) {
        const medplum = useMedplum();
        const [resource, setResource] = React.useState(getInitialResource(medplum, value));
        React.useEffect(() => {
            let subscribed = true;
            if (!resource && value && 'reference' in value && value.reference) {
                medplum
                    .readReference(value)
                    .then((r) => {
                    if (subscribed) {
                        setResource(r);
                    }
                })
                    .catch(() => setResource(undefined));
            }
            return (() => (subscribed = false));
        }, [medplum, resource, value]);
        return resource;
    }
    /**
     * Returns the initial resource value based on the input value.
     * If the input value is a resource, returns the resource.
     * If the input value is a reference to system, returns the system resource.
     * If the input value is a reference to a resource available in the cache, returns the resource.
     * Otherwise, returns undefined.
     * @param medplum The medplum client.
     * @param value The resource or reference to resource.
     * @returns An initial resource if available; undefined otherwise.
     */
    function getInitialResource(medplum, value) {
        if (!value) {
            return undefined;
        }
        if ('resourceType' in value) {
            return value;
        }
        if ('reference' in value) {
            if (value.reference === 'system') {
                return system;
            }
            return medplum.getCachedReference(value);
        }
        return undefined;
    }

    function ResourceForm(props) {
        const medplum = useMedplum();
        const defaultValue = useResource(props.defaultValue);
        const [schema, setSchema] = React.useState();
        const [value, setValue] = React.useState();
        React.useEffect(() => {
            if (defaultValue) {
                setValue(JSON.parse(JSON.stringify(defaultValue)));
                medplum.requestSchema(defaultValue.resourceType).then(setSchema).catch(console.log);
            }
        }, [medplum, defaultValue]);
        if (!schema || !value) {
            return React.createElement("div", null, "Loading...");
        }
        return (React.createElement("form", { noValidate: true, autoComplete: "off", onSubmit: (e) => {
                e.preventDefault();
                if (props.onSubmit) {
                    props.onSubmit(value);
                }
            } },
            React.createElement(core$1.Stack, { mb: "xl" },
                React.createElement(FormSection, { title: "Resource Type", htmlFor: "resourceType", outcome: props.outcome },
                    React.createElement(core$1.TextInput, { name: "resourceType", defaultValue: value.resourceType, disabled: true })),
                React.createElement(FormSection, { title: "ID", htmlFor: "id", outcome: props.outcome },
                    React.createElement(core$1.TextInput, { name: "id", defaultValue: value.id, disabled: true }))),
            React.createElement(BackboneElementInput, { typeName: value.resourceType, defaultValue: value, outcome: props.outcome, onChange: setValue }),
            React.createElement(core$1.Group, { position: "right", mt: "xl" },
                React.createElement(core$1.Button, { type: "submit" }, "OK"),
                props.onDelete && (React.createElement(core$1.Button, { variant: "outline", color: "red", type: "button", onClick: () => {
                        props.onDelete(value);
                    } }, "Delete")))));
    }
    function setPropertyValue(obj, key, propName, elementDefinition, value) {
        const types = elementDefinition.type;
        if (types.length > 1) {
            for (const type of types) {
                const compoundKey = key.replace('[x]', core.capitalize(type.code));
                if (compoundKey in obj) {
                    delete obj[compoundKey];
                }
            }
        }
        obj[propName] = value;
        return obj;
    }

    function toKey(element) {
        return element.code;
    }
    function toOption(element) {
        return {
            value: element.code,
            label: getDisplay(element),
            resource: element,
        };
    }
    function createValue(input) {
        return {
            code: input,
            display: input,
        };
    }
    function ValueSetAutocomplete(props) {
        const medplum = useMedplum();
        const { elementDefinition, ...rest } = props;
        const loadValues = React.useCallback(async (input, signal) => {
            const system = elementDefinition.binding?.valueSet;
            const valueSet = await medplum.searchValueSet(system, input, { signal });
            const valueSetElements = valueSet.expansion?.contains;
            const newData = [];
            for (const valueSetElement of valueSetElements) {
                if (valueSetElement.code && !newData.some((item) => item.code === valueSetElement.code)) {
                    newData.push(valueSetElement);
                }
            }
            return newData;
        }, [medplum, elementDefinition]);
        return (React.createElement(AsyncAutocomplete, { ...rest, creatable: true, clearable: true, toKey: toKey, toOption: toOption, loadOptions: loadValues, getCreateLabel: (query) => `+ Create ${query}`, onCreate: createValue }));
    }
    function getDisplay(item) {
        return item.display || item.code || '';
    }

    function CodeableConceptInput(props) {
        const [value, setValue] = React.useState(props.defaultValue);
        function handleChange(newValues) {
            const newConcept = valueSetElementToCodeableConcept(newValues);
            setValue(newConcept);
            if (props.onChange) {
                props.onChange(newConcept);
            }
        }
        return (React.createElement(ValueSetAutocomplete, { elementDefinition: props.property, name: props.name, placeholder: props.placeholder, defaultValue: value && codeableConceptToValueSetElement(value), onChange: handleChange }));
    }
    function codeableConceptToValueSetElement(concept) {
        return concept.coding?.map((c) => ({
            system: c.system,
            code: c.code,
            display: c.display,
        }));
    }
    function valueSetElementToCodeableConcept(elements) {
        if (elements.length === 0) {
            return undefined;
        }
        return {
            coding: elements.map((e) => ({
                system: e.system,
                code: e.code,
                display: e.display,
            })),
        };
    }

    function CodeInput(props) {
        const [value, setValue] = React.useState(props.defaultValue);
        function handleChange(newValues) {
            const newValue = newValues[0];
            const newCode = valueSetElementToCode(newValue);
            setValue(newCode);
            if (props.onChange) {
                props.onChange(newCode);
            }
        }
        return (React.createElement(ValueSetAutocomplete, { elementDefinition: props.property, name: props.name, placeholder: props.placeholder, defaultValue: codeToValueSetElement(value), onChange: handleChange }));
    }
    function codeToValueSetElement(code) {
        return code ? { code } : undefined;
    }
    function valueSetElementToCode(element) {
        return element?.code;
    }

    function CodingInput(props) {
        const [value, setValue] = React.useState(props.defaultValue);
        function handleChange(newValues) {
            const newValue = newValues[0];
            const newConcept = newValue && valueSetElementToCoding(newValue);
            setValue(newConcept);
            if (props.onChange) {
                props.onChange(newConcept);
            }
        }
        return (React.createElement(ValueSetAutocomplete, { elementDefinition: props.property, name: props.name, placeholder: props.placeholder, defaultValue: value && codingToValueSetElement(value), onChange: handleChange }));
    }
    function codingToValueSetElement(coding) {
        return {
            system: coding.system,
            code: coding.code,
            display: coding.display,
        };
    }
    function valueSetElementToCoding(element) {
        return {
            system: element.system,
            code: element.code,
            display: element.display,
        };
    }

    function ContactPointInput(props) {
        const [contactPoint, setContactPoint] = React.useState(props.defaultValue);
        const ref = React.useRef();
        ref.current = contactPoint;
        function setContactPointWrapper(newValue) {
            if (newValue && Object.keys(newValue).length === 0) {
                newValue = undefined;
            }
            setContactPoint(newValue);
            if (props.onChange) {
                props.onChange(newValue);
            }
        }
        function setSystem(system) {
            const newValue = { ...ref.current, system };
            if (!system) {
                delete newValue.system;
            }
            setContactPointWrapper(newValue);
        }
        function setUse(use) {
            const newValue = { ...ref.current, use };
            if (!use) {
                delete newValue.use;
            }
            setContactPointWrapper(newValue);
        }
        function setValue(value) {
            const newValue = { ...ref.current, value };
            if (!value) {
                delete newValue.value;
            }
            setContactPointWrapper(newValue);
        }
        return (React.createElement(core$1.Group, { spacing: "xs", grow: true, noWrap: true },
            React.createElement(core$1.NativeSelect, { "data-testid": "system", defaultValue: contactPoint?.system, onChange: (e) => setSystem(e.currentTarget.value), data: ['', 'email', 'phone', 'fax', 'pager', 'sms', 'other'] }),
            React.createElement(core$1.NativeSelect, { "data-testid": "use", defaultValue: contactPoint?.use, onChange: (e) => setUse(e.currentTarget.value), data: ['', 'home', 'work', 'temp', 'old', 'mobile'] }),
            React.createElement(core$1.TextInput, { placeholder: "Value", defaultValue: contactPoint?.value, onChange: (e) => setValue(e.currentTarget.value) })));
    }

    function ContactDetailInput(props) {
        const [contactPoint, setContactDetail] = React.useState(props.defaultValue);
        const ref = React.useRef();
        ref.current = contactPoint;
        function setContactDetailWrapper(newValue) {
            setContactDetail(newValue);
            if (props.onChange) {
                props.onChange(newValue);
            }
        }
        function setName(name) {
            const newValue = { ...ref.current, name };
            if (!name) {
                delete newValue.name;
            }
            setContactDetailWrapper(newValue);
        }
        function setTelecom(telecom) {
            const newValue = { ...ref.current, telecom: telecom && [telecom] };
            if (!telecom) {
                delete newValue.telecom;
            }
            setContactDetailWrapper(newValue);
        }
        return (React.createElement(core$1.Group, { spacing: "xs", grow: true, noWrap: true },
            React.createElement(core$1.TextInput, { "data-testid": props.name + '-name', name: props.name + '-name', placeholder: "Name", style: { width: 180 }, defaultValue: contactPoint?.name, onChange: (e) => setName(e.currentTarget.value) }),
            React.createElement(ContactPointInput, { name: props.name + '-telecom', defaultValue: contactPoint?.telecom?.[0], onChange: setTelecom })));
    }

    /**
     * The DateTimeInput component is a wrapper around the HTML5 input type="datetime-local".
     * The main purpose is to reconcile time zones.
     * Most of our date/time values are in ISO-8601, which includes a time zone offset.
     * The datetime-local input does not support the time zone offset.
     * @param props The Input props.
     * @returns The JSX element to render.
     */
    function DateTimeInput(props) {
        return (React.createElement(core$1.TextInput, { id: props.name, name: props.name, "data-testid": props.name, placeholder: props.placeholder, type: getInputType(), defaultValue: convertIsoToLocal(props.defaultValue), error: getErrorsForInput(props.outcome, props.name), onChange: (e) => {
                if (props.onChange) {
                    const newValue = e.currentTarget.value;
                    props.onChange(convertLocalToIso(newValue));
                }
            } }));
    }
    /**
     * Converts an ISO-8601 date/time string to a local date/time string.
     * @param isoString The ISO-8601 date/time string to convert.
     * @returns The local date/time string.
     */
    function convertIsoToLocal(isoString) {
        if (!isoString) {
            return '';
        }
        // Convert the ISO-8601 date to a local datetime-local value.
        // See: https://developer.mozilla.org/en-US/docs/Web/HTML/Date_and_time_formats#local_date_and_time_strings
        // See: https://stackoverflow.com/a/60368477
        const date = new Date(isoString);
        if (!core.isValidDate(date)) {
            // If the input string was malformed, return an empty string.
            return '';
        }
        return date.toLocaleDateString('sv') + 'T' + date.toLocaleTimeString('sv');
    }
    /**
     * Converts a local date/time string to an ISO-8601 date/time string.
     * @param localString The local date/time string to convert.
     * @returns The ISO-8601 date/time string.
     */
    function convertLocalToIso(localString) {
        if (!localString) {
            return '';
        }
        // Try to parse the local string as a Date
        // JavaScript's Date() constructor defaults to the local time zone.
        // The Date() constructor will throw if the value is malformed.
        const date = new Date(localString);
        if (!core.isValidDate(date)) {
            // If the input string was malformed, return an empty string.
            return '';
        }
        return date.toISOString();
    }
    /**
     * Returns the input type for the requested type.
     * JSDOM does not support many of the valid <input> type attributes.
     * For example, it won't fire change events for <input type="datetime-local">.
     */
    function getInputType() {
        return 'datetime-local';
    }

    function ExtensionInput(props) {
        return (React.createElement(core$1.JsonInput, { id: props.name, name: props.name, "data-testid": "extension-input", defaultValue: core.stringify(props.defaultValue), onChange: (newValue) => {
                if (props.onChange) {
                    props.onChange(JSON.parse(newValue));
                }
            } }));
    }

    function HumanNameInput(props) {
        const [value, setValue] = React.useState(props.defaultValue);
        const valueRef = React.useRef();
        valueRef.current = value;
        function setValueWrapper(newValue) {
            setValue(newValue);
            if (props.onChange) {
                props.onChange(newValue);
            }
        }
        function setUse(use) {
            setValueWrapper({ ...valueRef.current, use: use ? use : undefined });
        }
        function setPrefix(prefix) {
            setValueWrapper({
                ...valueRef.current,
                prefix: prefix ? prefix.split(' ') : undefined,
            });
        }
        function setGiven(given) {
            setValueWrapper({
                ...valueRef.current,
                given: given ? given.split(' ') : undefined,
            });
        }
        function setFamily(family) {
            setValueWrapper({
                ...valueRef.current,
                family: family ? family : undefined,
            });
        }
        function setSuffix(suffix) {
            setValueWrapper({
                ...valueRef.current,
                suffix: suffix ? suffix.split(' ') : undefined,
            });
        }
        return (React.createElement(core$1.Group, { spacing: "xs", grow: true, noWrap: true },
            React.createElement(core$1.NativeSelect, { defaultValue: value?.use, "data-testid": "use", onChange: (e) => setUse(e.currentTarget.value), data: ['', 'temp', 'old', 'usual', 'official', 'nickname', 'anonymous', 'maiden'] }),
            React.createElement(core$1.TextInput, { placeholder: "Prefix", defaultValue: value?.prefix?.join(' '), onChange: (e) => setPrefix(e.currentTarget.value) }),
            React.createElement(core$1.TextInput, { placeholder: "Given", defaultValue: value?.given?.join(' '), onChange: (e) => setGiven(e.currentTarget.value) }),
            React.createElement(core$1.TextInput, { placeholder: "Family", defaultValue: value?.family, onChange: (e) => setFamily(e.currentTarget.value) }),
            React.createElement(core$1.TextInput, { placeholder: "Suffix", defaultValue: value?.suffix?.join(' '), onChange: (e) => setSuffix(e.currentTarget.value) })));
    }

    function IdentifierInput(props) {
        const [value, setValue] = React.useState(props.defaultValue);
        function setValueWrapper(newValue) {
            setValue(newValue);
            if (props.onChange) {
                props.onChange(newValue);
            }
        }
        return (React.createElement(core$1.Group, { spacing: "xs", grow: true, noWrap: true },
            React.createElement(core$1.TextInput, { placeholder: "System", defaultValue: value?.system, onChange: (e) => setValueWrapper({ ...value, system: e.currentTarget.value }) }),
            React.createElement(core$1.TextInput, { placeholder: "Value", defaultValue: value?.value, onChange: (e) => setValueWrapper({ ...value, value: e.currentTarget.value }) })));
    }

    /*
     * Based on: https://github.com/mantinedev/ui.mantine.dev/blob/master/components/CurrencyInput/CurrencyInput.tsx
     */
    /**
     * List of currencies.
     *
     * Full list of currencies:
     * https://www.hl7.org/fhir/valueset-currencies.html
     *
     * Latest browsers can report list of supported currencies, but it's not widely supported:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/supportedValuesOf
     *
     * Using a short list for simplicity for now.
     */
    const data = ['USD', 'EUR', 'CAD', 'GBP', 'AUD'];
    function MoneyInput(props) {
        const { onChange } = props;
        const [value, setValue] = React.useState(props.defaultValue);
        const setValueWrapper = React.useCallback((newValue) => {
            setValue(newValue);
            if (onChange) {
                onChange(newValue);
            }
        }, [onChange]);
        const handleCurrencyChange = React.useCallback((e) => {
            setValueWrapper({
                ...value,
                currency: e.currentTarget.value,
            });
        }, [value, setValueWrapper]);
        const handleValueChange = React.useCallback((e) => {
            setValueWrapper({
                ...value,
                value: e.currentTarget.valueAsNumber,
            });
        }, [value, setValueWrapper]);
        const select = (React.createElement(core$1.NativeSelect, { defaultValue: value?.currency, data: data, styles: {
                input: {
                    fontWeight: 500,
                    borderTopLeftRadius: 0,
                    borderBottomLeftRadius: 0,
                    width: 92,
                },
            }, onChange: handleCurrencyChange }));
        return (React.createElement(core$1.TextInput, { type: "number", label: props.label, placeholder: props.placeholder || 'Value', defaultValue: value?.value?.toString() || 'USD', icon: React.createElement(icons.IconCurrencyDollar, { size: 14 }), rightSection: select, rightSectionWidth: 92, onChange: handleValueChange }));
    }

    function PeriodInput(props) {
        const [value, setValue] = React.useState(props.defaultValue);
        function setValueWrapper(newValue) {
            setValue(newValue);
            if (props.onChange) {
                props.onChange(newValue);
            }
        }
        return (React.createElement(core$1.Group, { spacing: "xs", grow: true, noWrap: true },
            React.createElement(DateTimeInput, { name: props.name + '.start', placeholder: "Start", defaultValue: value?.start, onChange: (newValue) => setValueWrapper({ ...value, start: newValue }) }),
            React.createElement(DateTimeInput, { name: props.name + '.end', placeholder: "End", defaultValue: value?.end, onChange: (newValue) => setValueWrapper({ ...value, end: newValue }) })));
    }

    function QuantityInput(props) {
        const [value, setValue] = React.useState(props.defaultValue);
        function setValueWrapper(newValue) {
            setValue(newValue);
            if (props.onChange) {
                props.onChange(newValue);
            }
        }
        return (React.createElement(core$1.Group, { spacing: "xs", grow: true, noWrap: true },
            React.createElement(core$1.NativeSelect, { style: { width: 80 }, "data-testid": props.name + '-comparator', defaultValue: value?.comparator, data: ['', '<', '<=', '>=', '>'], onChange: (e) => setValueWrapper({
                    ...value,
                    comparator: e.currentTarget.value,
                }) }),
            React.createElement(core$1.TextInput, { id: props.name, name: props.name, "data-testid": props.name + '-value', type: "number", step: "any", placeholder: "Value", defaultValue: value?.value?.toString(), onChange: (e) => setValueWrapper({
                    ...value,
                    value: tryParseNumber(e.currentTarget.value),
                }) }),
            React.createElement(core$1.TextInput, { placeholder: "Unit", "data-testid": props.name + '-unit', defaultValue: value?.unit, onChange: (e) => setValueWrapper({
                    ...value,
                    unit: e.currentTarget.value,
                }) })));
    }
    function tryParseNumber(str) {
        if (!str) {
            return undefined;
        }
        return parseFloat(str);
    }

    /**
     * Renders a Range input.
     * See: https://www.hl7.org/fhir/datatypes.html#Range
     * @param props Range input properties.
     * @returns Range input element.
     */
    function RangeInput(props) {
        const [value, setValue] = React.useState(props.defaultValue);
        function setValueWrapper(newValue) {
            setValue(newValue);
            if (props.onChange) {
                props.onChange(newValue);
            }
        }
        return (React.createElement(core$1.Group, { spacing: "xs", grow: true, noWrap: true },
            React.createElement(QuantityInput, { name: props.name + '-low', defaultValue: value?.low, onChange: (v) => setValueWrapper({
                    ...value,
                    low: v,
                }) }),
            React.createElement(QuantityInput, { name: props.name + '-high', defaultValue: value?.high, onChange: (v) => setValueWrapper({
                    ...value,
                    high: v,
                }) })));
    }

    /**
     * Renders a Ratio input.
     * See: https://www.hl7.org/fhir/datatypes.html#Ratio
     * @param props Ratio input properties.
     * @returns Ratio input element.
     */
    function RatioInput(props) {
        const [value, setValue] = React.useState(props.defaultValue);
        function setValueWrapper(newValue) {
            setValue(newValue);
            if (props.onChange) {
                props.onChange(newValue);
            }
        }
        return (React.createElement(core$1.Group, { spacing: "xs", grow: true, noWrap: true },
            React.createElement(QuantityInput, { name: props.name + '-numerator', defaultValue: value?.numerator, onChange: (v) => setValueWrapper({
                    ...value,
                    numerator: v,
                }) }),
            React.createElement(QuantityInput, { name: props.name + '-denominator', defaultValue: value?.denominator, onChange: (v) => setValueWrapper({
                    ...value,
                    denominator: v,
                }) })));
    }

    function ResourceAvatar(props) {
        const resource = useResource(props.value);
        const text = resource ? core.getDisplayString(resource) : props.alt ?? '';
        const imageUrl = (resource && core.getImageSrc(resource)) ?? props.src;
        const radius = props.radius ?? 'xl';
        const avatarProps = { ...props };
        delete avatarProps.value;
        delete avatarProps.link;
        if (props.link) {
            return (React.createElement(MedplumLink, { to: resource },
                React.createElement(core$1.Avatar, { src: imageUrl, alt: text, radius: radius, ...avatarProps })));
        }
        return React.createElement(core$1.Avatar, { src: imageUrl, alt: text, radius: radius, ...avatarProps });
    }

    /**
     * Defines which search parameters will be used by the type ahead to search for each resourceType
     */
    const SEARCH_CODES = {
        Schedule: '_id',
        Task: '_id',
        Patient: 'name',
        Practitioner: 'name',
        Questionnaire: 'name',
        ServiceRequest: '_id',
        DiagnosticReport: '_id',
        Specimen: '_id',
        Observation: 'code',
        RequestGroup: '_id',
        ActivityDefinition: 'name',
        User: 'email:contains',
    };
    function ResourceInput(props) {
        const medplum = useMedplum();
        const defaultValue = useResource(props.defaultValue);
        const [value, setValue] = React.useState(defaultValue ? core.getDisplayString(defaultValue) : '');
        const [loading, setLoading] = React.useState(false);
        const [data, setData] = React.useState([]);
        React.useEffect(() => {
            if (defaultValue) {
                setValue(core.getDisplayString(defaultValue));
            }
        }, [defaultValue, setValue]);
        async function loadValues(input) {
            setLoading(true);
            const searchCode = SEARCH_CODES[props.resourceType] || 'name';
            const searchParams = new URLSearchParams({
                [searchCode]: input,
                _count: '10',
            });
            const resources = await medplum.searchResources(props.resourceType, searchParams);
            setData(resources.map((resource) => ({ value: core.getDisplayString(resource), resource })));
            setLoading(false);
        }
        async function handleChange(val) {
            setValue(val);
            return loadValues(val);
        }
        function handleSelect(item) {
            setValue(item.value);
            setData([]);
            if (props.onChange) {
                props.onChange(item.resource);
            }
        }
        return (React.createElement(core$1.Autocomplete, { itemComponent: ItemComponent, value: value, data: data, placeholder: props.placeholder, onFocus: () => loadValues(value), onChange: handleChange, onItemSubmit: handleSelect, rightSection: loading ? React.createElement(core$1.Loader, { size: 16 }) : null }));
    }
    const ItemComponent = React.forwardRef(({ value, resource, ...others }, ref) => {
        return (React.createElement("div", { ref: ref, ...others },
            React.createElement(core$1.Group, { noWrap: true },
                React.createElement(ResourceAvatar, { value: resource }),
                React.createElement("div", null,
                    React.createElement(core$1.Text, null, value),
                    React.createElement(core$1.Text, { size: "xs", color: "dimmed" }, resource.birthDate)))));
    });

    function ReferenceInput(props) {
        const targetTypes = getTargetTypes$1(props.targetTypes);
        const initialResourceType = getInitialResourceType(props.defaultValue, targetTypes);
        const [value, setValue] = React.useState(props.defaultValue);
        const [resourceType, setResourceType] = React.useState(initialResourceType);
        const valueRef = React.useRef();
        valueRef.current = value;
        const resourceTypeRef = React.useRef();
        resourceTypeRef.current = resourceType;
        function setValueHelper(newValue) {
            setValue(newValue);
            if (props.onChange) {
                props.onChange(newValue);
            }
        }
        return (React.createElement(core$1.Group, { spacing: "xs", grow: true, noWrap: true },
            targetTypes ? (React.createElement(core$1.NativeSelect, { "data-testid": "reference-input-resource-type-select", defaultValue: resourceType, onChange: (e) => setResourceType(e.currentTarget.value), data: targetTypes })) : (React.createElement(core$1.TextInput, { "data-testid": "reference-input-resource-type-input", defaultValue: resourceType, onChange: (e) => setResourceType(e.currentTarget.value) })),
            React.createElement(ResourceInput, { resourceType: resourceType, name: props.name + '-id', placeholder: props.placeholder, defaultValue: value, onChange: (item) => {
                    setValueHelper(item ? core.createReference(item) : undefined);
                } })));
    }
    function getTargetTypes$1(targetTypes) {
        if (!targetTypes || targetTypes.length === 0 || (targetTypes.length === 1 && targetTypes[0] === 'Resource')) {
            return undefined;
        }
        return targetTypes;
    }
    function getInitialResourceType(defaultValue, targetTypes) {
        const defaultValueResourceType = defaultValue?.reference?.split('/')[0];
        if (defaultValueResourceType) {
            return defaultValueResourceType;
        }
        if (targetTypes && targetTypes.length > 0) {
            return targetTypes[0];
        }
        return undefined;
    }

    function ResourceArrayInput(props) {
        const [values, setValues] = React.useState(props.defaultValue && Array.isArray(props.defaultValue) ? props.defaultValue : []);
        const valuesRef = React.useRef();
        valuesRef.current = values;
        function setValuesWrapper(newValues) {
            setValues(newValues);
            if (props.onChange) {
                props.onChange(newValues);
            }
        }
        return (React.createElement("table", { style: { width: '100%', borderCollapse: 'collapse' } },
            React.createElement("colgroup", null,
                React.createElement("col", { width: "97%" }),
                React.createElement("col", { width: "3%" })),
            React.createElement("tbody", null,
                values.map((v, index) => (React.createElement("tr", { key: `${index}-${values.length}` },
                    React.createElement("td", null,
                        React.createElement(ResourcePropertyInput, { arrayElement: true, property: props.property, name: props.name + '.' + index, defaultValue: v, onChange: (newValue) => {
                                const copy = [...valuesRef.current];
                                copy[index] = newValue;
                                setValuesWrapper(copy);
                            } })),
                    React.createElement("td", { style: { textAlign: 'right' } },
                        React.createElement(core$1.ActionIcon, { title: "Remove", size: "sm", onClick: (e) => {
                                killEvent(e);
                                const copy = [...valuesRef.current];
                                copy.splice(index, 1);
                                setValuesWrapper(copy);
                            } },
                            React.createElement(icons.IconCircleMinus, null)))))),
                React.createElement("tr", null,
                    React.createElement("td", null),
                    React.createElement("td", { style: { textAlign: 'right' } },
                        React.createElement(core$1.ActionIcon, { title: "Add", size: "sm", color: "green", onClick: (e) => {
                                killEvent(e);
                                const copy = [...valuesRef.current];
                                copy.push(undefined);
                                setValuesWrapper(copy);
                            } },
                            React.createElement(icons.IconCirclePlus, null)))))));
    }

    const daysOfWeek = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
    function TimingInput(props) {
        const [value, setValue] = React.useState(props.defaultValue || {});
        const [open, setOpen] = React.useState(false);
        const valueRef = React.useRef();
        valueRef.current = value;
        return (React.createElement(React.Fragment, null,
            React.createElement(core$1.Group, { spacing: "xs", grow: true, noWrap: true },
                React.createElement("span", null, core.formatTiming(valueRef.current) || 'No repeat'),
                React.createElement(core$1.Button, { onClick: () => setOpen(true) }, "Edit")),
            React.createElement(TimingEditorDialog, { visible: open, defaultValue: valueRef.current, onOk: (newValue) => {
                    if (props.onChange) {
                        props.onChange(newValue);
                    }
                    setValue(newValue);
                    setOpen(false);
                }, onCancel: () => setOpen(false) })));
    }
    function TimingEditorDialog(props) {
        const [value, setValue] = React.useState(props.defaultValue || {});
        const valueRef = React.useRef();
        valueRef.current = value;
        function setStart(newStart) {
            setValue({ ...valueRef.current, event: [newStart] });
        }
        function setRepeat(repeat) {
            setValue({ ...valueRef.current, repeat });
        }
        function setPeriod(newPeriod) {
            setRepeat({ ...valueRef.current?.repeat, period: newPeriod });
        }
        function setPeriodUnit(newPeriodUnit) {
            setRepeat({ ...valueRef.current?.repeat, periodUnit: newPeriodUnit });
        }
        function setDayOfWeek(day, enabled) {
            if (enabled) {
                addDayOfWeek(day);
            }
            else {
                removeDayOfWeek(day);
            }
        }
        function addDayOfWeek(day) {
            const existing = valueRef.current?.repeat?.dayOfWeek || [];
            if (!existing.includes(day)) {
                setRepeat({ ...valueRef.current?.repeat, dayOfWeek: [...existing, day] });
            }
        }
        function removeDayOfWeek(day) {
            const existing = valueRef.current?.repeat?.dayOfWeek || [];
            if (existing.includes(day)) {
                setRepeat({ ...valueRef.current?.repeat, dayOfWeek: existing.filter((d) => d !== day) });
            }
        }
        return (React.createElement(core$1.Modal, { title: "Timing", closeButtonLabel: "Close", opened: props.visible, onClose: () => props.onCancel() },
            React.createElement("div", { style: { padding: '5px 20px', textAlign: 'left' } },
                React.createElement(FormSection, { title: "Starts on", htmlFor: 'timing-dialog-start' },
                    React.createElement(DateTimeInput, { name: 'timing-dialog-start', onChange: (newValue) => setStart(newValue) })),
                React.createElement(FormSection, { title: "Repeat every", htmlFor: 'timing-dialog-period' },
                    React.createElement(core$1.Group, { spacing: "xs", grow: true, noWrap: true },
                        React.createElement(core$1.TextInput, { type: "number", step: 1, id: "timing-dialog-period", name: "timing-dialog-period", defaultValue: value?.repeat?.period, onChange: (e) => setPeriod(parseInt(e.currentTarget.value)) }),
                        React.createElement(core$1.NativeSelect, { id: "timing-dialog-periodUnit", name: "timing-dialog-periodUnit", defaultValue: value?.repeat?.periodUnit, onChange: (e) => setPeriodUnit(e.currentTarget.value), data: [
                                { label: 'day', value: 'd' },
                                { label: 'week', value: 'wk' },
                                { label: 'month', value: 'mo' },
                                { label: 'year', value: 'a' },
                            ] }))),
                React.createElement(FormSection, { title: "Repeat on" },
                    React.createElement(core$1.Group, { spacing: "xs", grow: true, noWrap: true }, daysOfWeek.map((day) => (React.createElement(React.Fragment, { key: day },
                        React.createElement("label", { htmlFor: 'timing-dialog-repeat-' + day }, day.charAt(0).toUpperCase()),
                        React.createElement(core$1.Checkbox, { id: 'timing-dialog-repeat-' + day, name: 'timing-dialog-repeat-' + day, onChange: (e) => setDayOfWeek(day, e.currentTarget.checked) }))))))),
            React.createElement(core$1.Button, { onClick: () => props.onOk(value) }, "OK")));
    }

    function ResourcePropertyInput(props) {
        const property = props.property;
        const propertyType = props.defaultPropertyType ?? property.type?.[0]?.code;
        const name = props.name;
        const value = props.defaultValue;
        if (property.max === '*' && !props.arrayElement) {
            if (propertyType === 'Attachment') {
                return React.createElement(AttachmentArrayInput, { name: name, defaultValue: value, onChange: props.onChange });
            }
            return React.createElement(ResourceArrayInput, { property: property, name: name, defaultValue: value, onChange: props.onChange });
        }
        const propertyTypes = property.type;
        if (propertyTypes.length > 1) {
            return React.createElement(ElementDefinitionInputSelector, { elementDefinitionTypes: propertyTypes, ...props });
        }
        else {
            return React.createElement(ElementDefinitionTypeInput, { elementDefinitionType: propertyTypes[0], ...props });
        }
    }
    function ElementDefinitionInputSelector(props) {
        const propertyTypes = props.elementDefinitionTypes;
        let initialPropertyType = undefined;
        if (props.defaultPropertyType) {
            initialPropertyType = propertyTypes.find((t) => t.code === props.defaultPropertyType);
        }
        if (!initialPropertyType) {
            initialPropertyType = propertyTypes[0];
        }
        const [selectedType, setSelectedType] = React.useState(initialPropertyType);
        return (React.createElement(core$1.Group, { spacing: "xs", grow: true, noWrap: true },
            React.createElement(core$1.NativeSelect, { style: { width: '200px' }, defaultValue: selectedType?.code, onChange: (e) => {
                    setSelectedType(propertyTypes.find((type) => type.code === e.currentTarget.value));
                }, data: propertyTypes.map((type) => ({
                    value: type.code,
                    label: type.code,
                })) }),
            React.createElement(ElementDefinitionTypeInput, { ...props, elementDefinitionType: selectedType, onChange: (newValue) => {
                    if (props.onChange) {
                        props.onChange(newValue, props.name.replace('[x]', core.capitalize(selectedType.code)));
                    }
                } })));
    }
    function ElementDefinitionTypeInput(props) {
        const property = props.property;
        const propertyType = props.elementDefinitionType.code;
        const name = props.name;
        const value = props.defaultValue;
        switch (propertyType) {
            // 2.24.0.1 Primitive Types
            // https://www.hl7.org/fhir/datatypes.html#primitive
            case core.PropertyType.SystemString:
            case core.PropertyType.canonical:
            case core.PropertyType.string:
            case core.PropertyType.time:
            case core.PropertyType.uri:
            case core.PropertyType.url:
                return (React.createElement(core$1.TextInput, { id: name, name: name, "data-testid": name, defaultValue: value, onChange: (e) => {
                        if (props.onChange) {
                            props.onChange(e.currentTarget.value);
                        }
                    }, error: getErrorsForInput(props.outcome, name) }));
            case core.PropertyType.date:
                return (React.createElement(core$1.TextInput, { type: "date", id: name, name: name, "data-testid": name, defaultValue: value, onChange: (e) => {
                        if (props.onChange) {
                            props.onChange(e.currentTarget.value);
                        }
                    }, error: getErrorsForInput(props.outcome, name) }));
            case core.PropertyType.dateTime:
            case core.PropertyType.instant:
                return React.createElement(DateTimeInput, { name: name, defaultValue: value, onChange: props.onChange, outcome: props.outcome });
            case core.PropertyType.decimal:
            case core.PropertyType.integer:
            case core.PropertyType.positiveInt:
            case core.PropertyType.unsignedInt:
                return (React.createElement(core$1.TextInput, { type: "number", step: propertyType === core.PropertyType.decimal ? 'any' : '1', id: name, name: name, "data-testid": name, defaultValue: value, onChange: (e) => {
                        if (props.onChange) {
                            props.onChange(e.currentTarget.valueAsNumber);
                        }
                    } }));
            case core.PropertyType.code:
                return React.createElement(CodeInput, { property: property, name: name, defaultValue: value, onChange: props.onChange });
            case core.PropertyType.boolean:
                return (React.createElement(core$1.Checkbox, { id: name, name: name, "data-testid": name, defaultChecked: !!value, onChange: (e) => {
                        if (props.onChange) {
                            props.onChange(e.currentTarget.checked);
                        }
                    } }));
            case core.PropertyType.markdown:
                return (React.createElement(core$1.Textarea, { id: name, name: name, "data-testid": name, defaultValue: value, onChange: (e) => {
                        if (props.onChange) {
                            props.onChange(e.currentTarget.value);
                        }
                    } }));
            // 2.24.0.2 Complex Types
            // https://www.hl7.org/fhir/datatypes.html#complex
            case core.PropertyType.Address:
                return React.createElement(AddressInput, { name: name, defaultValue: value, onChange: props.onChange });
            case core.PropertyType.Annotation:
                return React.createElement(AnnotationInput, { name: name, defaultValue: value, onChange: props.onChange });
            case core.PropertyType.Attachment:
                return React.createElement(AttachmentInput, { name: name, defaultValue: value, onChange: props.onChange });
            case core.PropertyType.CodeableConcept:
                return React.createElement(CodeableConceptInput, { property: property, name: name, defaultValue: value, onChange: props.onChange });
            case core.PropertyType.Coding:
                return React.createElement(CodingInput, { property: property, name: name, defaultValue: value, onChange: props.onChange });
            case core.PropertyType.ContactDetail:
                return React.createElement(ContactDetailInput, { name: name, defaultValue: value, onChange: props.onChange });
            case core.PropertyType.ContactPoint:
                return React.createElement(ContactPointInput, { name: name, defaultValue: value, onChange: props.onChange });
            case core.PropertyType.Extension:
                return React.createElement(ExtensionInput, { name: name, defaultValue: value, onChange: props.onChange });
            case core.PropertyType.HumanName:
                return React.createElement(HumanNameInput, { name: name, defaultValue: value, onChange: props.onChange });
            case core.PropertyType.Identifier:
                return React.createElement(IdentifierInput, { name: name, defaultValue: value, onChange: props.onChange });
            case core.PropertyType.Money:
                return React.createElement(MoneyInput, { name: name, defaultValue: value, onChange: props.onChange });
            case core.PropertyType.Period:
                return React.createElement(PeriodInput, { name: name, defaultValue: value, onChange: props.onChange });
            case core.PropertyType.Duration:
            case core.PropertyType.Quantity:
                return React.createElement(QuantityInput, { name: name, defaultValue: value, onChange: props.onChange });
            case core.PropertyType.Range:
                return React.createElement(RangeInput, { name: name, defaultValue: value, onChange: props.onChange });
            case core.PropertyType.Ratio:
                return React.createElement(RatioInput, { name: name, defaultValue: value, onChange: props.onChange });
            case core.PropertyType.Reference:
                return (React.createElement(ReferenceInput, { name: name, defaultValue: value, targetTypes: getTargetTypes(property), onChange: props.onChange }));
            case core.PropertyType.Timing:
                return React.createElement(TimingInput, { name: name, defaultValue: value, onChange: props.onChange });
            case core.PropertyType.Dosage:
            case core.PropertyType.UsageContext:
                return (React.createElement(BackboneElementInput, { typeName: propertyType, defaultValue: value, onChange: props.onChange, outcome: props.outcome }));
            default:
                return (React.createElement(BackboneElementInput, { typeName: core.buildTypeName(property.path?.split('.')), defaultValue: value, onChange: props.onChange, outcome: props.outcome }));
        }
    }
    function getTargetTypes(property) {
        return property?.type?.[0]?.targetProfile?.map((p) => p.split('/').pop());
    }

    function BackboneElementInput(props) {
        const [value, setValue] = React.useState(props.defaultValue ?? {});
        function setValueWrapper(newValue) {
            setValue(newValue);
            if (props.onChange) {
                props.onChange(newValue);
            }
        }
        const typeName = props.typeName;
        const typeSchema = core.globalSchema.types[typeName];
        if (!typeSchema) {
            return React.createElement("div", null,
                typeName,
                "\u00A0not implemented");
        }
        const typedValue = { type: typeName, value };
        return (React.createElement(core$1.Stack, null, Object.entries(typeSchema.properties).map((entry) => {
            const key = entry[0];
            if (key === 'id' || DEFAULT_IGNORED_PROPERTIES.indexOf(key) >= 0) {
                return null;
            }
            const property = entry[1];
            if (!property.type) {
                return null;
            }
            const [propertyValue, propertyType] = getValueAndType(typedValue, key);
            if (property.type.length === 1 && property.type[0].code === 'boolean') {
                return (React.createElement(CheckboxFormSection, { key: key, title: core.getPropertyDisplayName(key), description: property.definition, htmlFor: key },
                    React.createElement(ResourcePropertyInput, { property: property, name: key, defaultValue: propertyValue, defaultPropertyType: propertyType, outcome: props.outcome, onChange: (newValue, propName) => {
                            setValueWrapper(setPropertyValue(value, key, propName ?? key, entry[1], newValue));
                        } })));
            }
            return (React.createElement(FormSection, { key: key, title: core.getPropertyDisplayName(key), description: property.definition, htmlFor: key, outcome: props.outcome },
                React.createElement(ResourcePropertyInput, { property: property, name: key, defaultValue: propertyValue, defaultPropertyType: propertyType, outcome: props.outcome, onChange: (newValue, propName) => {
                        setValueWrapper(setPropertyValue(value, key, propName ?? key, entry[1], newValue));
                    } })));
        })));
    }

    const useStyles$a = core$1.createStyles((theme) => ({
        table: {
            width: 350,
            '& th': {
                fontWeight: 'normal',
                fontSize: 11,
                padding: 8,
                textAlign: 'center',
            },
            '& td': {
                padding: '2px 4px',
            },
            '& td button': {
                width: 44,
                height: 44,
                color: theme.colors[theme.primaryColor][5],
                fontSize: 16,
                fontWeight: 500,
                textAlign: 'center',
                padding: 0,
                backgroundColor: theme.colors[theme.primaryColor][0],
                border: 0,
                borderRadius: '50%',
                cursor: 'pointer',
            },
            '& td button:hover': {
                backgroundColor: theme.colors[theme.primaryColor][1],
            },
            '& td button:disabled': {
                backgroundColor: 'transparent',
                cursor: 'default',
                color: theme.colors.gray[4],
                fontWeight: 'normal',
            },
        },
    }));
    /**
     * Returns a month display string (e.g. "January 2020").
     * @param date Any date within the month.
     * @returns The month display string (e.g. "January 2020")
     */
    function getMonthString(date) {
        return date.toLocaleString('default', { month: 'long' }) + ' ' + date.getFullYear();
    }
    function CalendarInput(props) {
        const { classes } = useStyles$a();
        const { onChangeMonth, onClick } = props;
        const [month, setMonth] = React.useState(getStartMonth);
        function moveMonth(delta) {
            setMonth((currMonth) => {
                const newMonth = new Date(currMonth.getTime());
                newMonth.setMonth(currMonth.getMonth() + delta);
                onChangeMonth(newMonth);
                return newMonth;
            });
        }
        const grid = React.useMemo(() => buildGrid(month, props.slots), [month, props.slots]);
        return (React.createElement("div", null,
            React.createElement(core$1.Group, { position: "apart", spacing: "xs", grow: true, noWrap: true },
                React.createElement("p", { style: { flex: 1 } }, getMonthString(month)),
                React.createElement(core$1.Group, { position: "right", spacing: "xs" },
                    React.createElement(core$1.Button, { variant: "outline", "aria-label": "Previous month", onClick: () => moveMonth(-1) }, "<"),
                    React.createElement(core$1.Button, { variant: "outline", "aria-label": "Next month", onClick: () => moveMonth(1) }, ">"))),
            React.createElement("table", { className: classes.table },
                React.createElement("thead", null,
                    React.createElement("tr", null,
                        React.createElement("th", null, "SUN"),
                        React.createElement("th", null, "MON"),
                        React.createElement("th", null, "TUE"),
                        React.createElement("th", null, "WED"),
                        React.createElement("th", null, "THU"),
                        React.createElement("th", null, "FRI"),
                        React.createElement("th", null, "SAT"))),
                React.createElement("tbody", null, grid.map((week, weekIndex) => (React.createElement("tr", { key: 'week-' + weekIndex }, week.map((day, dayIndex) => (React.createElement("td", { key: 'day-' + dayIndex }, day && (React.createElement(core$1.Button, { disabled: !day.available, onClick: () => onClick(day.date) }, day.date.getDate()))))))))))));
    }
    function getStartMonth() {
        const result = new Date();
        result.setDate(1);
        result.setHours(0, 0, 0, 0);
        return result;
    }
    function buildGrid(startDate, slots) {
        const d = new Date(startDate.getFullYear(), startDate.getMonth());
        const grid = [];
        let row = [];
        // Fill leading empty days
        for (let i = 0; i < d.getDay(); i++) {
            row.push(undefined);
        }
        while (d.getMonth() === startDate.getMonth()) {
            row.push({
                date: new Date(d.getTime()),
                available: isDayAvailable(d, slots),
            });
            if (d.getDay() === 6) {
                grid.push(row);
                row = [];
            }
            d.setDate(d.getDate() + 1);
        }
        // Fill trailing empty days
        if (d.getDay() !== 0) {
            for (let i = d.getDay(); i < 7; i++) {
                row.push(undefined);
            }
            grid.push(row);
        }
        return grid;
    }
    /**
     * Returns true if the given date is available for booking.
     * @param day The day to check.
     * @param slots The list of available slots.
     * @returns True if there are any available slots for the day.
     */
    function isDayAvailable(day, slots) {
        // Note that slot start and end time may or may not be in UTC.
        for (const slot of slots) {
            const slotStart = new Date(slot.start);
            if (slotStart.getFullYear() === day.getFullYear() &&
                slotStart.getMonth() === day.getMonth() &&
                slotStart.getDate() === day.getDate()) {
                return true;
            }
        }
        return false;
    }

    function ResourceName(props) {
        const { value, link, ...rest } = props;
        const resource = useResource(value);
        if (!resource) {
            return null;
        }
        const text = core.getDisplayString(resource);
        return link ? (React.createElement(MedplumLink, { to: resource, ...rest }, text)) : (React.createElement(core$1.Text, { component: "span", ...rest }, text));
    }

    function ResourceBadge(props) {
        return (React.createElement(core$1.Group, { spacing: "xs" },
            React.createElement(ResourceAvatar, { size: 24, radius: 12, value: props.value, link: props.link }),
            React.createElement(ResourceName, { value: props.value, link: props.link })));
    }

    /*
     * Request status: https://hl7.org/fhir/valueset-request-status.html
     * draft, active, on-hold, revoked, completed, entered-in-error, unknown
     *
     * Publication status: https://hl7.org/fhir/valueset-publication-status.html
     * draft, active, retired, unknown
     *
     * Observation status: https://www.hl7.org/fhir/valueset-observation-status.html
     * registered, preliminary, final, amended,  corrected, cancelled, entered-in-error, unknown
     *
     * DiagnosticReport status: https://hl7.org/fhir/valueset-diagnostic-report-status.html
     * registered, preliminary, final, amended, corrected, appended, cancelled, entered-in-error, unknown
     *
     * Task status: https://hl7.org/fhir/valueset-task-status.html
     * draft, requested, received, accepted, rejected, ready, cancelled, in-progress, on-hold, failed, completed, entered-in-error
     *
     * Appointment status: https://www.hl7.org/fhir/valueset-appointmentstatus.html
     * proposed, pending, booked, arrived, fulfilled, cancelled, noshow, entered-in-error, chcked-in, waitlist
     */
    const statusToColor = {
        draft: 'blue',
        active: 'blue',
        'on-hold': 'yellow',
        revoked: 'red',
        completed: 'green',
        'entered-in-error': 'red',
        unknown: 'gray',
        retired: 'gray',
        registered: 'blue',
        preliminary: 'blue',
        final: 'green',
        amended: 'yellow',
        corrected: 'yellow',
        cancelled: 'red',
        requested: 'blue',
        received: 'blue',
        accepted: 'blue',
        rejected: 'red',
        ready: 'blue',
        'in-progress': 'blue',
        failed: 'red',
        proposed: 'blue',
        pending: 'blue',
        booked: 'blue',
        arrived: 'blue',
        fulfilled: 'green',
        noshow: 'red',
        'checked-in': 'blue',
        waitlist: 'gray',
        routine: 'gray',
        urgent: 'red',
        asap: 'red',
        stat: 'red',
    };
    function StatusBadge(props) {
        return React.createElement(core$1.Badge, { color: statusToColor[props.status] }, props.status);
    }

    const useStyles$9 = core$1.createStyles((theme) => ({
        table: {
            border: `0.1px solid ${theme.colors.gray[5]}`,
            borderCollapse: 'collapse',
            '& td, & th': {
                border: `0.1px solid ${theme.colors.gray[5]}`,
                padding: 4,
            },
        },
        criticalRow: {
            background: theme.colorScheme === 'dark' ? theme.colors.red[7] : theme.colors.red[1],
            border: `0.1px solid ${theme.colors.red[5]}`,
            color: theme.colors.red[5],
            fontWeight: 500,
            '& td': {
                border: `0.1px solid ${theme.colors.red[5]}`,
            },
        },
    }));
    function DiagnosticReportDisplay(props) {
        const diagnosticReport = useResource(props.value);
        const specimen = useResource(diagnosticReport?.specimen?.[0]);
        if (!diagnosticReport) {
            return null;
        }
        let textContent = '';
        if (diagnosticReport.presentedForm && diagnosticReport.presentedForm.length > 0) {
            const pf = diagnosticReport.presentedForm[0];
            if (pf.contentType?.startsWith('text/plain') && pf.data) {
                textContent = window.atob(pf.data);
            }
        }
        if (specimen?.note) {
            for (const note of specimen.note) {
                textContent += note.text + '\n\n';
            }
        }
        return (React.createElement(core$1.Stack, null,
            React.createElement(core$1.Title, null, "Diagnostic Report"),
            React.createElement(core$1.Group, { mt: "md", spacing: 30 },
                diagnosticReport.subject && (React.createElement("div", null,
                    React.createElement(core$1.Text, { size: "xs", transform: "uppercase", color: "dimmed" }, "Subject"),
                    React.createElement(core$1.Text, null,
                        React.createElement(ResourceBadge, { value: diagnosticReport.subject, link: true })))),
                diagnosticReport.resultsInterpreter &&
                    diagnosticReport.resultsInterpreter.map((interpreter) => (React.createElement("div", { key: interpreter.reference },
                        React.createElement(core$1.Text, { size: "xs", transform: "uppercase", color: "dimmed" }, "Interpreter"),
                        React.createElement(core$1.Text, null,
                            React.createElement(ResourceBadge, { value: interpreter, link: true }))))),
                diagnosticReport.issued && (React.createElement("div", null,
                    React.createElement(core$1.Text, { size: "xs", transform: "uppercase", color: "dimmed" }, "Issued"),
                    React.createElement(core$1.Text, null, core.formatDateTime(diagnosticReport.issued)))),
                diagnosticReport.status && (React.createElement("div", null,
                    React.createElement(core$1.Text, { size: "xs", transform: "uppercase", color: "dimmed" }, "Status"),
                    React.createElement(core$1.Text, null, core.capitalize(diagnosticReport.status))))),
            diagnosticReport.result && React.createElement(ObservationTable, { value: diagnosticReport.result }),
            textContent && React.createElement("pre", null, textContent.trim())));
    }
    function ObservationTable(props) {
        const { classes } = useStyles$9();
        return (React.createElement("table", { className: classes.table },
            React.createElement("thead", null,
                React.createElement("tr", null,
                    React.createElement("th", null, "Test"),
                    React.createElement("th", null, "Value"),
                    React.createElement("th", null, "Reference Range"),
                    React.createElement("th", null, "Interpretation"),
                    React.createElement("th", null, "Category"),
                    React.createElement("th", null, "Status"))),
            React.createElement("tbody", null, props.value?.map((observation, index) => (React.createElement(ObservationRow, { key: 'obs-' + index, value: observation }))))));
    }
    function ObservationRow(props) {
        const { classes, cx } = useStyles$9();
        const observation = useResource(props.value);
        if (!observation) {
            return null;
        }
        const critical = isCritical(observation);
        return (React.createElement("tr", { className: cx({ [classes.criticalRow]: critical }) },
            React.createElement("td", null,
                React.createElement(MedplumLink, { to: observation },
                    React.createElement(CodeableConceptDisplay, { value: observation.code }))),
            React.createElement("td", null,
                React.createElement(ObservationValueDisplay, { value: observation })),
            React.createElement("td", null,
                React.createElement(ReferenceRangeDisplay, { value: observation.referenceRange })),
            React.createElement("td", null, observation.interpretation && observation.interpretation.length > 0 && (React.createElement(CodeableConceptDisplay, { value: observation.interpretation[0] }))),
            React.createElement("td", null, observation.category && observation.category.length > 0 && (React.createElement("ul", null, observation.category.map((concept, index) => (React.createElement("li", { key: `category-${index}` },
                React.createElement(CodeableConceptDisplay, { value: concept }))))))),
            React.createElement("td", null, observation.status && React.createElement(StatusBadge, { status: observation.status }))));
    }
    function ObservationValueDisplay(props) {
        const obs = props.value;
        return React.createElement(React.Fragment, null, core.formatObservationValue(obs));
    }
    function ReferenceRangeDisplay(props) {
        const range = props.value && props.value.length > 0 && props.value[0];
        if (!range) {
            return null;
        }
        if (range.text) {
            return React.createElement(React.Fragment, null, range.text);
        }
        return React.createElement(RangeDisplay, { value: range });
    }
    /**
     * Returns true if the observation is critical.
     * See: https://www.hl7.org/fhir/valueset-observation-interpretation.html
     * @param observation The FHIR observation.
     * @returns True if the FHIR observation is a critical value.
     */
    function isCritical(observation) {
        const code = observation.interpretation?.[0]?.coding?.[0]?.code;
        return code === 'AA' || code === 'LL' || code === 'HH' || code === 'A';
    }

    const useStyles$8 = core$1.createStyles((theme) => ({
        root: {
            borderCollapse: 'collapse',
            width: '100%',
            '& tr': {
                borderTop: `0.1px solid ${theme.colors.gray[3]}`,
            },
            '& th, & td': {
                padding: `${theme.spacing.sm}px ${theme.spacing.sm}px`,
                verticalAlign: 'top',
            },
        },
        removed: {
            color: theme.colors.red[7],
            textDecoration: 'line-through',
        },
        added: {
            color: theme.colors.green[7],
        },
    }));
    function ResourceDiffTable(props) {
        const { classes } = useStyles$8();
        const medplum = useMedplum();
        const [schema, setSchema] = React.useState();
        React.useEffect(() => {
            medplum.requestSchema(props.original.resourceType).then(setSchema).catch(console.log);
        }, [medplum, props.original.resourceType]);
        if (!schema) {
            return null;
        }
        const typeSchema = schema.types[props.original.resourceType];
        if (!typeSchema) {
            return null;
        }
        return (React.createElement("table", { className: classes.root },
            React.createElement("colgroup", null,
                React.createElement("col", { style: { width: '30%' } }),
                React.createElement("col", { style: { width: '35%' } }),
                React.createElement("col", { style: { width: '35%' } })),
            React.createElement("thead", null,
                React.createElement("tr", null,
                    React.createElement("th", null, "Property"),
                    React.createElement("th", null, "Before"),
                    React.createElement("th", null, "After"))),
            React.createElement("tbody", null, Object.entries(typeSchema.properties).map((entry) => {
                const key = entry[0];
                if (key === 'id' || key === 'meta') {
                    return null;
                }
                const property = entry[1];
                const [originalPropertyValue, originalPropertyType] = getValueAndType(core.toTypedValue(props.original), key);
                const [revisedPropertyValue, revisedPropertyType] = getValueAndType(core.toTypedValue(props.revised), key);
                if (isEmpty(originalPropertyValue) && isEmpty(revisedPropertyValue)) {
                    return null;
                }
                if (core.stringify(originalPropertyValue) === core.stringify(revisedPropertyValue)) {
                    return null;
                }
                return (React.createElement("tr", { key: key },
                    React.createElement("td", null, core.getPropertyDisplayName(key)),
                    React.createElement("td", { className: classes.removed },
                        React.createElement(ResourcePropertyDisplay, { property: property, propertyType: originalPropertyType, value: originalPropertyValue, ignoreMissingValues: true })),
                    React.createElement("td", { className: classes.added },
                        React.createElement(ResourcePropertyDisplay, { property: property, propertyType: revisedPropertyType, value: revisedPropertyValue, ignoreMissingValues: true }))));
            }))));
    }
    function isEmpty(value) {
        return (!value ||
            (Array.isArray(value) && value.length === 0) ||
            (typeof value === 'object' && Object.keys(value).length === 0));
    }

    function ResourceTable(props) {
        const medplum = useMedplum();
        const value = useResource(props.value);
        const [schema, setSchema] = React.useState();
        React.useEffect(() => {
            if (value) {
                medplum.requestSchema(value.resourceType).then(setSchema).catch(console.log);
            }
        }, [medplum, value]);
        if (!schema || !value) {
            return null;
        }
        return (React.createElement(BackboneElementDisplay, { value: { type: value.resourceType, value }, ignoreMissingValues: props.ignoreMissingValues }));
    }

    /**
     * ErrorBoundary is a React component that handles errors in its child components.
     * See: https://reactjs.org/docs/error-boundaries.html
     */
    class ErrorBoundary extends React.Component {
        constructor(props) {
            super(props);
            this.state = {};
        }
        static getDerivedStateFromError(error) {
            return { error };
        }
        componentDidCatch(error, errorInfo) {
            console.error('Uncaught error:', error, errorInfo);
        }
        render() {
            if (this.state.error) {
                return (React.createElement(core$1.Alert, { icon: React.createElement(icons.IconAlertCircle, { size: 16 }), title: "Something went wrong", color: "red" }, core.normalizeErrorString(this.state.error)));
            }
            return this.props.children;
        }
    }

    function Timeline(props) {
        return React.createElement(Container, null, props.children);
    }
    function TimelineItem(props) {
        const { resource, profile, padding, popupMenuItems, ...others } = props;
        const author = profile ?? resource.meta?.author;
        return (React.createElement(Panel, { "data-testid": "timeline-item", fill: true, ...others },
            React.createElement(core$1.Group, { position: "apart", spacing: 8, mx: "xs", my: "sm" },
                React.createElement(ResourceAvatar, { value: author, link: true, size: "md" }),
                React.createElement("div", { style: { flex: 1 } },
                    React.createElement(core$1.Text, { size: "sm" },
                        React.createElement(ResourceName, { color: "dark", weight: 500, value: author, link: true })),
                    React.createElement(core$1.Text, { size: "xs" },
                        React.createElement(MedplumLink, { color: "dimmed", to: props.resource }, core.formatDateTime(props.resource.meta?.lastUpdated)),
                        React.createElement(core$1.Text, { component: "span", color: "dimmed", mx: 8 }, "\u00B7"),
                        React.createElement(MedplumLink, { color: "dimmed", to: props.resource }, props.resource.resourceType))),
                popupMenuItems && (React.createElement(core$1.Menu, { position: "bottom-end", shadow: "md", width: 200 },
                    React.createElement(core$1.Menu.Target, null,
                        React.createElement(core$1.ActionIcon, { radius: "xl", "aria-label": `Actions for ${core.getReferenceString(props.resource)}` },
                            React.createElement(icons.IconDots, null))),
                    popupMenuItems))),
            React.createElement(ErrorBoundary, null,
                padding && React.createElement("div", { style: { padding: '0 16px 16px 16px' } }, props.children),
                !padding && React.createElement(React.Fragment, null, props.children))));
    }

    /**
     * Sorts an array of resources in place by meta.lastUpdated ascending.
     * @param resources Array of resources.
     */
    function sortByDateAndPriority(resources) {
        resources.sort(resourceDateComparator);
    }
    function resourceDateComparator(a, b) {
        const priority1 = getPriorityScore(a);
        const priority2 = getPriorityScore(b);
        if (priority1 > priority2) {
            return 1;
        }
        if (priority1 < priority2) {
            return -1;
        }
        return getTime(a) - getTime(b);
    }
    function getPriorityScore(resource) {
        const priority = resource.priority;
        if (typeof priority === 'string') {
            return { stat: 4, asap: 3, urgent: 2 }[priority] || 0;
        }
        return 0;
    }
    function getTime(resource) {
        if (resource.resourceType === 'Communication' && resource.sent) {
            return new Date(resource.sent).getTime();
        }
        if ((resource.resourceType === 'DiagnosticReport' ||
            resource.resourceType === 'Media' ||
            resource.resourceType === 'Observation') &&
            resource.issued) {
            return new Date(resource.issued).getTime();
        }
        if (resource.resourceType === 'DocumentReference' && resource.date) {
            return new Date(resource.date).getTime();
        }
        const dateTime = resource.meta?.lastUpdated;
        if (!dateTime) {
            return 0;
        }
        return new Date(dateTime).getTime();
    }

    const useStyles$7 = core$1.createStyles((theme) => ({
        pinnedComment: {
            backgroundColor: theme.colors.blue[0],
        },
    }));
    function ResourceTimeline(props) {
        const navigate = reactRouterDom.useNavigate();
        const medplum = useMedplum();
        const sender = medplum.getProfile();
        const inputRef = React.useRef(null);
        const resource = useResource(props.value);
        const [history, setHistory] = React.useState();
        const [items, setItems] = React.useState([]);
        const buildSearchRequests = props.buildSearchRequests;
        const itemsRef = React.useRef(items);
        itemsRef.current = items;
        const loadTimeline = React.useCallback(() => {
            if (!resource) {
                setItems([]);
                setHistory({});
                return;
            }
            medplum.executeBatch(buildSearchRequests(resource)).then(handleBatchResponse).catch(console.log);
        }, [medplum, resource, buildSearchRequests]);
        React.useEffect(() => {
            loadTimeline();
        }, [loadTimeline]);
        /**
         * Handles a batch request response.
         * @param batchResponse The batch response.
         */
        function handleBatchResponse(batchResponse) {
            const newItems = [];
            if (batchResponse.entry) {
                for (const batchEntry of batchResponse.entry) {
                    const bundle = batchEntry.resource;
                    if (!bundle) {
                        // User may not have access to all resource types
                        continue;
                    }
                    if (bundle.type === 'history') {
                        setHistory(bundle);
                    }
                    if (bundle.entry) {
                        for (const entry of bundle.entry) {
                            if (entry.resource) {
                                newItems.push(entry.resource);
                            }
                        }
                    }
                }
                sortByDateAndPriority(newItems);
                newItems.reverse();
            }
            setItems(newItems);
        }
        /**
         * Adds an array of resources to the timeline.
         * @param resources Array of resources.
         */
        function addResources(resources) {
            const newItems = [...itemsRef.current, ...resources];
            sortByDateAndPriority(newItems);
            newItems.reverse();
            setItems(newItems);
        }
        /**
         * Adds a Communication resource to the timeline.
         * @param contentString The comment content.
         */
        function createComment(contentString) {
            if (!resource || !props.createCommunication) {
                // Encounter not loaded yet
                return;
            }
            medplum
                .createResource(props.createCommunication(resource, sender, contentString))
                .then((result) => {
                addResources([result]);
            })
                .catch(console.log);
        }
        /**
         * Adds a Media resource to the timeline.
         * @param attachment The media attachment.
         */
        function createMedia(attachment) {
            if (!resource || !props.createMedia) {
                // Encounter not loaded yet
                return;
            }
            medplum
                .createResource(props.createMedia(resource, sender, attachment))
                .then((result) => addResources([result]))
                .then(() => notifications.updateNotification({
                id: 'upload-notification',
                color: 'teal',
                title: 'Upload complete',
                message: '',
                icon: React.createElement(icons.IconCheck, { size: 16 }),
                autoClose: 2000,
            }))
                .catch((reason) => notifications.updateNotification({
                id: 'upload-notification',
                color: 'red',
                title: 'Upload error',
                message: core.normalizeErrorString(reason),
                icon: React.createElement(icons.IconFileAlert, { size: 16 }),
                autoClose: 2000,
            }));
        }
        function setPriority(communication, priority) {
            return medplum.updateResource({ ...communication, priority });
        }
        function onPin(communication) {
            setPriority(communication, 'stat').then(loadTimeline).catch(console.log);
        }
        function onUnpin(communication) {
            setPriority(communication, 'routine').then(loadTimeline).catch(console.log);
        }
        function onDetails(timelineItem) {
            navigate(`/${timelineItem.resourceType}/${timelineItem.id}`);
        }
        function onEdit(timelineItem) {
            navigate(`/${timelineItem.resourceType}/${timelineItem.id}/edit`);
        }
        function onDelete(timelineItem) {
            navigate(`/${timelineItem.resourceType}/${timelineItem.id}/delete`);
        }
        function onVersionDetails(version) {
            navigate(`/${version.resourceType}/${version.id}/_history/${version.meta?.versionId}`);
        }
        function onUploadStart() {
            notifications.showNotification({
                id: 'upload-notification',
                loading: true,
                title: 'Initializing upload...',
                message: 'Please wait...',
                autoClose: false,
                disallowClose: true,
            });
        }
        function onUploadProgress(e) {
            notifications.updateNotification({
                id: 'upload-notification',
                loading: true,
                title: 'Uploading...',
                message: getProgressMessage(e),
                autoClose: false,
                disallowClose: true,
            });
        }
        if (!resource) {
            return (React.createElement(core$1.Center, { style: { width: '100%', height: '100%' } },
                React.createElement(core$1.Loader, null)));
        }
        return (React.createElement(Timeline, null,
            props.createCommunication && (React.createElement(Panel, null,
                React.createElement(Form, { testid: "timeline-form", onSubmit: (formData) => {
                        createComment(formData.text);
                        const input = inputRef.current;
                        if (input) {
                            input.value = '';
                            input.focus();
                        }
                    } },
                    React.createElement(core$1.Group, { spacing: "xs", noWrap: true, style: { width: '100%' } },
                        React.createElement(ResourceAvatar, { value: sender }),
                        React.createElement(core$1.TextInput, { name: "text", ref: inputRef, placeholder: "Add comment", style: { width: '100%', maxWidth: 300 } }),
                        React.createElement(core$1.ActionIcon, { type: "submit", radius: "xl", color: "blue", variant: "filled" },
                            React.createElement(icons.IconMessage, { size: 16 })),
                        React.createElement(AttachmentButton, { onUpload: createMedia, onUploadStart: onUploadStart, onUploadProgress: onUploadProgress }, (props) => (React.createElement(core$1.ActionIcon, { ...props, radius: "xl", color: "blue", variant: "filled" },
                            React.createElement(icons.IconCloudUpload, { size: 16 })))))))),
            items.map((item) => {
                if (item.resourceType === resource.resourceType && item.id === resource.id) {
                    return (React.createElement(HistoryTimelineItem, { key: item.meta?.versionId, history: history, resource: item, onDetails: onVersionDetails }));
                }
                const key = `${item.resourceType}/${item.id}`;
                switch (item.resourceType) {
                    case 'AuditEvent':
                        return React.createElement(AuditEventTimelineItem, { key: key, resource: item, onDetails: onDetails });
                    case 'Communication':
                        return (React.createElement(CommunicationTimelineItem, { key: key, resource: item, onPin: item.priority !== 'stat' ? onPin : undefined, onUnpin: item.priority === 'stat' ? onUnpin : undefined, onDetails: onDetails, onEdit: onEdit, onDelete: onDelete }));
                    case 'DiagnosticReport':
                        return (React.createElement(DiagnosticReportTimelineItem, { key: key, resource: item, onDetails: onDetails, onEdit: onEdit, onDelete: onDelete }));
                    case 'Media':
                        return (React.createElement(MediaTimelineItem, { key: key, resource: item, onDetails: onDetails, onEdit: onEdit, onDelete: onDelete }));
                    default:
                        return (React.createElement(TimelineItem, { key: key, resource: item, padding: true },
                            React.createElement(ResourceTable, { value: item, ignoreMissingValues: true })));
                }
            })));
    }
    function TimelineItemPopupMenu(props) {
        return (React.createElement(core$1.Menu.Dropdown, null,
            React.createElement(core$1.Menu.Label, null, "Resource"),
            props.onPin && (React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconPin, { size: 14 }), onClick: () => props.onPin(props.resource), "aria-label": `Pin ${core.getReferenceString(props.resource)}` }, "Pin")),
            props.onUnpin && (React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconPinnedOff, { size: 14 }), onClick: () => props.onUnpin(props.resource), "aria-label": `Unpin ${core.getReferenceString(props.resource)}` }, "Unpin")),
            props.onDetails && (React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconListDetails, { size: 14 }), onClick: () => props.onDetails(props.resource), "aria-label": `Details ${core.getReferenceString(props.resource)}` }, "Details")),
            props.onEdit && (React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconEdit, { size: 14 }), onClick: () => props.onEdit(props.resource), "aria-label": `Edit ${core.getReferenceString(props.resource)}` }, "Edit")),
            props.onDelete && (React.createElement(React.Fragment, null,
                React.createElement(core$1.Menu.Divider, null),
                React.createElement(core$1.Menu.Label, null, "Danger zone"),
                React.createElement(core$1.Menu.Item, { color: "red", icon: React.createElement(icons.IconTrash, { size: 14 }), onClick: () => props.onDelete(props.resource), "aria-label": `Delete ${core.getReferenceString(props.resource)}` }, "Delete")))));
    }
    function HistoryTimelineItem(props) {
        const previous = getPrevious(props.history, props.resource);
        if (previous) {
            return (React.createElement(TimelineItem, { resource: props.resource, padding: true, popupMenuItems: React.createElement(TimelineItemPopupMenu, { ...props }) },
                React.createElement(ResourceDiffTable, { original: previous, revised: props.resource })));
        }
        else {
            return (React.createElement(TimelineItem, { resource: props.resource, padding: true, popupMenuItems: React.createElement(TimelineItemPopupMenu, { ...props }) },
                React.createElement("h3", null, "Created"),
                React.createElement(ResourceTable, { value: props.resource, ignoreMissingValues: true })));
        }
    }
    function getPrevious(history, version) {
        const entries = history.entry;
        const index = entries.findIndex((entry) => entry.resource?.meta?.versionId === version.meta?.versionId);
        if (index >= entries.length - 1) {
            return undefined;
        }
        return entries[index + 1].resource;
    }
    function CommunicationTimelineItem(props) {
        const { classes } = useStyles$7();
        const routine = !props.resource.priority || props.resource.priority === 'routine';
        const className = routine ? undefined : classes.pinnedComment;
        return (React.createElement(TimelineItem, { resource: props.resource, profile: props.resource.sender, padding: true, className: className, popupMenuItems: React.createElement(TimelineItemPopupMenu, { ...props }) },
            React.createElement("p", null, props.resource.payload?.[0]?.contentString)));
    }
    function MediaTimelineItem(props) {
        const contentType = props.resource.content?.contentType;
        const padding = contentType &&
            !contentType.startsWith('image/') &&
            !contentType.startsWith('video/') &&
            contentType !== 'application/pdf';
        return (React.createElement(TimelineItem, { resource: props.resource, padding: !!padding, popupMenuItems: React.createElement(TimelineItemPopupMenu, { ...props }) },
            React.createElement(AttachmentDisplay, { value: props.resource.content })));
    }
    function AuditEventTimelineItem(props) {
        return (React.createElement(TimelineItem, { resource: props.resource, padding: true, popupMenuItems: React.createElement(TimelineItemPopupMenu, { ...props }) },
            React.createElement(core$1.ScrollArea, null,
                React.createElement("pre", null, props.resource.outcomeDesc))));
    }
    function DiagnosticReportTimelineItem(props) {
        return (React.createElement(TimelineItem, { resource: props.resource, padding: true, popupMenuItems: React.createElement(TimelineItemPopupMenu, { ...props }) },
            React.createElement(DiagnosticReportDisplay, { value: props.resource })));
    }
    function getProgressMessage(e) {
        if (e.lengthComputable) {
            const percent = (100 * e.loaded) / e.total;
            return `Uploaded: ${formatFileSize(e.loaded)} / ${formatFileSize(e.total)} ${percent.toFixed(2)}%`;
        }
        return `Uploaded: ${formatFileSize(e.loaded)}`;
    }
    function formatFileSize(bytes) {
        if (bytes == 0) {
            return '0.00 B';
        }
        const e = Math.floor(Math.log(bytes) / Math.log(1024));
        return (bytes / Math.pow(1024, e)).toFixed(2) + ' ' + ' KMGTP'.charAt(e) + 'B';
    }

    function DefaultResourceTimeline(props) {
        return (React.createElement(ResourceTimeline, { value: props.resource, buildSearchRequests: (resource) => ({
                resourceType: 'Bundle',
                type: 'batch',
                entry: [
                    {
                        request: {
                            method: 'GET',
                            url: `${core.getReferenceString(resource)}/_history`,
                        },
                    },
                    {
                        request: {
                            method: 'GET',
                            url: `AuditEvent?entity=${core.getReferenceString(resource)}&_sort=-_lastUpdated`,
                        },
                    },
                ],
            }) }));
    }

    function EncounterTimeline(props) {
        return (React.createElement(ResourceTimeline, { value: props.encounter, buildSearchRequests: (resource) => ({
                resourceType: 'Bundle',
                type: 'batch',
                entry: [
                    {
                        request: {
                            method: 'GET',
                            url: `${core.getReferenceString(resource)}/_history`,
                        },
                    },
                    {
                        request: {
                            method: 'GET',
                            url: `Communication?encounter=${core.getReferenceString(resource)}`,
                        },
                    },
                    {
                        request: {
                            method: 'GET',
                            url: `Media?encounter=${core.getReferenceString(resource)}`,
                        },
                    },
                ],
            }), createCommunication: (resource, sender, text) => ({
                resourceType: 'Communication',
                status: 'completed',
                encounter: core.createReference(resource),
                subject: resource.subject,
                sender: core.createReference(sender),
                sent: new Date().toISOString(),
                payload: [{ contentString: text }],
            }), createMedia: (resource, operator, content) => ({
                resourceType: 'Media',
                status: 'completed',
                encounter: core.createReference(resource),
                subject: resource.subject,
                operator: core.createReference(operator),
                issued: new Date().toISOString(),
                content,
            }) }));
    }

    function FhirPathDisplay(props) {
        let value;
        try {
            value = core.evalFhirPath(props.path, props.resource);
        }
        catch (err) {
            console.warn('FhirPathDisplay:', err);
            return null;
        }
        if (value.length > 1) {
            throw new Error(`Component "path" for "FhirPathDisplay" must resolve to a single element. \
       Received ${value.length} elements \
       [${JSON.stringify(value, null, 2)}]`);
        }
        return React.createElement(ResourcePropertyDisplay, { value: value[0] || '', propertyType: props.propertyType });
    }

    const searchParamToOperators = {
        string: [core.Operator.EQUALS, core.Operator.NOT, core.Operator.CONTAINS, core.Operator.EXACT],
        fulltext: [core.Operator.EQUALS, core.Operator.NOT, core.Operator.CONTAINS, core.Operator.EXACT],
        token: [core.Operator.EQUALS, core.Operator.NOT],
        reference: [core.Operator.EQUALS, core.Operator.NOT],
        numeric: [
            core.Operator.EQUALS,
            core.Operator.NOT_EQUALS,
            core.Operator.GREATER_THAN,
            core.Operator.LESS_THAN,
            core.Operator.GREATER_THAN_OR_EQUALS,
            core.Operator.LESS_THAN_OR_EQUALS,
        ],
        quantity: [
            core.Operator.EQUALS,
            core.Operator.NOT_EQUALS,
            core.Operator.GREATER_THAN,
            core.Operator.LESS_THAN,
            core.Operator.GREATER_THAN_OR_EQUALS,
            core.Operator.LESS_THAN_OR_EQUALS,
        ],
        date: [
            core.Operator.EQUALS,
            core.Operator.NOT_EQUALS,
            core.Operator.GREATER_THAN,
            core.Operator.LESS_THAN,
            core.Operator.GREATER_THAN_OR_EQUALS,
            core.Operator.LESS_THAN_OR_EQUALS,
            core.Operator.STARTS_AFTER,
            core.Operator.ENDS_BEFORE,
            core.Operator.APPROXIMATELY,
        ],
        datetime: [
            core.Operator.EQUALS,
            core.Operator.NOT_EQUALS,
            core.Operator.GREATER_THAN,
            core.Operator.LESS_THAN,
            core.Operator.GREATER_THAN_OR_EQUALS,
            core.Operator.LESS_THAN_OR_EQUALS,
            core.Operator.STARTS_AFTER,
            core.Operator.ENDS_BEFORE,
            core.Operator.APPROXIMATELY,
        ],
    };
    const operatorNames = {
        eq: 'equals',
        ne: 'not equals',
        gt: 'greater than',
        lt: 'less than',
        ge: 'greater than or equals',
        le: 'less than or equals',
        sa: 'starts after',
        eb: 'ends before',
        ap: 'approximately',
        contains: 'contains',
        exact: 'exact',
        text: 'text',
        not: 'not',
        above: 'above',
        below: 'below',
        in: 'in',
        'not-in': 'not in',
        'of-type': 'of type',
        missing: 'missing',
    };
    /**
     * Sets the array of filters.
     *
     * @param {Array} filters The new filters.
     */
    function setFilters(definition, filters) {
        return {
            ...definition,
            filters: filters,
            offset: 0,
            name: undefined,
        };
    }
    /**
     * Clears all of the filters.
     */
    function clearFilters(definition) {
        return setFilters(definition, []);
    }
    /**
     * Clears all of the filters on a certain field.
     *
     * @param {string} code The field key name to clear filters.
     */
    function clearFiltersOnField(definition, code) {
        return setFilters(definition, (definition.filters || []).filter((f) => f.code !== code));
    }
    /**
     * Adds a filter.
     *
     * @param {string} field The field key name.
     * @param {Operator} op The operation key name.
     * @param {?string} value The filter value.
     * @param {boolean=} opt_clear Optional flag to clear filters on the field.
     */
    function addFilter(definition, field, op, value, opt_clear) {
        if (opt_clear) {
            definition = clearFiltersOnField(definition, field);
        }
        const nextFilters = [];
        if (definition.filters) {
            nextFilters.push(...definition.filters);
        }
        nextFilters.push({ code: field, operator: op, value: value || '' });
        return setFilters(definition, nextFilters);
    }
    /**
     * Adds a field.
     *
     * @param {string} field The field key name.
     */
    function addField(definition, field) {
        if (definition.fields && definition.fields.includes(field)) {
            return definition;
        }
        const newFields = [];
        if (definition.fields) {
            newFields.push(...definition.fields);
        }
        newFields.push(field);
        return {
            ...definition,
            fields: newFields,
            name: undefined,
        };
    }
    /**
     * Deletes a filter at the specified index.
     *
     * @param {number} index The filter index.
     */
    function deleteFilter(definition, index) {
        if (!definition.filters) {
            return definition;
        }
        const newFilters = [...definition.filters];
        newFilters.splice(index, 1);
        return {
            ...definition,
            filters: newFilters,
            name: undefined,
        };
    }
    /**
     * Adds a filter that constrains the specified field to "yesterday".
     *
     * @param {string} field The field key name.
     */
    function addYesterdayFilter(definition, field) {
        return addDayFilter(definition, field, -1);
    }
    /**
     * Adds a filter that constrains the specified field to "today".
     *
     * @param {string} field The field key name.
     */
    function addTodayFilter(definition, field) {
        return addDayFilter(definition, field, 0);
    }
    /**
     * Adds a filter that constrains the specified field to "tomorrow".
     *
     * @param {string} field The field key name.
     */
    function addTomorrowFilter(definition, field) {
        return addDayFilter(definition, field, 1);
    }
    /**
     * Adds a filter that constrains the specified field to a day.
     * The day is specified as a delta from the current day.
     * "Today" would be 0.
     * "Yesterday" would be -1.
     * "Tomorrow" would be 1.
     *
     * @param {string} field The field key name.
     * @param {number} delta The number of days from this day.
     */
    function addDayFilter(definition, field, delta) {
        const startTime = new Date();
        startTime.setDate(startTime.getDate() + delta);
        startTime.setHours(0, 0, 0, 0);
        const endTime = new Date(startTime.getTime());
        endTime.setDate(endTime.getDate() + 1);
        endTime.setTime(endTime.getTime() - 1);
        return addDateFilterBetween(definition, field, startTime, endTime);
    }
    /**
     * Adds a filter that constrains the specified field to "last month".
     *
     * @param {string} field The field key name.
     */
    function addLastMonthFilter(definition, field) {
        return addMonthFilter(definition, field, -1);
    }
    /**
     * Adds a filter that constrains the specified field to "this month".
     *
     * @param {string} field The field key name.
     */
    function addThisMonthFilter(definition, field) {
        return addMonthFilter(definition, field, 0);
    }
    /**
     * Adds a filter that constrains the specified field to "next month".
     *
     * @param {string} field The field key name.
     */
    function addNextMonthFilter(definition, field) {
        return addMonthFilter(definition, field, 1);
    }
    /**
     * Adds a filter that constrains the specified field to a month.
     * The month is specified as a delta from the current month.
     * "This month" would be 0.
     * "Last month" would be -1.
     * "Next month" would be 1.
     *
     * @param {string} field The field key name.
     * @param {number} delta The number of months from this month.
     */
    function addMonthFilter(definition, field, delta) {
        const startTime = new Date();
        startTime.setMonth(startTime.getMonth() + delta);
        startTime.setDate(1);
        startTime.setHours(0, 0, 0, 0);
        const endTime = new Date(startTime.getTime());
        endTime.setMonth(endTime.getMonth() + 1);
        endTime.setDate(1);
        endTime.setHours(0, 0, 0, 0);
        endTime.setTime(endTime.getTime() - 1);
        return addDateFilterBetween(definition, field, startTime, endTime);
    }
    /**
     * Adds a filter that constrains the specified field to the year to date.
     *
     * @param {string} field The field key name.
     */
    function addYearToDateFilter(definition, field) {
        const startTime = new Date();
        startTime.setMonth(0);
        startTime.setDate(1);
        startTime.setHours(0, 0, 0, 0);
        const endTime = new Date();
        return addDateFilterBetween(definition, field, startTime, endTime);
    }
    /**
     * Adds a filter for a date between two dates (inclusive of both dates).
     *
     * @param {string} field The field key name.
     * @param {Date} d1 The start date.
     * @param {Date} d2 The end date.
     */
    function addDateFilterBetween(definition, field, d1, d2) {
        definition = clearFiltersOnField(definition, field);
        definition = addDateFilterImpl(definition, field, core.Operator.GREATER_THAN_OR_EQUALS, d1);
        definition = addDateFilterImpl(definition, field, core.Operator.LESS_THAN_OR_EQUALS, d2);
        return definition;
    }
    /**
     * Adds a filter for a date before a certain date/time.
     *
     * @param {string} field The field key name.
     * @param {Operator} op The date/time operation.
     * @param {Date} value The date.
     */
    function addDateFilterImpl(definition, field, op, value) {
        return addFilter(definition, field, op, value.toISOString());
    }
    /**
     * Adds a filter that constrains the specified field to "missing".
     *
     * @param {string} field The field key name.
     */
    function addMissingFilter(definition, field, value = true) {
        return addFilter(definition, field, core.Operator.MISSING, value.toString());
    }
    /**
     * Sets the offset (starting at zero).
     *
     * @param {number} offset The offset number.
     */
    function setOffset(definition, offset) {
        if (definition.offset === offset) {
            return definition;
        }
        return {
            ...definition,
            offset,
            name: undefined,
        };
    }
    /**
     * Creates a new search request with the search offset at the specified page.
     * @param definition The search definition.
     * @param page The new page number
     * @return The new search definition.
     */
    function setPage(definition, page) {
        const count = definition.count ?? core.DEFAULT_SEARCH_COUNT;
        const newOffset = (page - 1) * count;
        return setOffset(definition, newOffset);
    }
    /**
     * Sorts the search by the specified key, and optional direction.
     * Direction defaults to ascending ('asc') if not specified.
     *
     * @param {string} sortField The sort key.
     */
    function setSort(definition, sort, desc) {
        if (sort === getSortField(definition) && desc !== undefined && desc === isSortDescending(definition)) {
            return definition;
        }
        return {
            ...definition,
            sortRules: [
                {
                    code: sort,
                    descending: !!desc,
                },
            ],
            name: undefined,
        };
    }
    /**
     * Toggles the sort of the search by key.
     * If the search is already sorted by the key, reverses the direction.
     * If the search is not sorted by the key, sort in ascending order.
     *
     * @param {string} key The field key name.
     */
    function toggleSort(definition, key) {
        let desc = false;
        if (getSortField(definition) === key) {
            desc = !isSortDescending(definition);
        }
        return setSort(definition, key, desc);
    }
    function getSortField(definition) {
        const sortRules = definition.sortRules;
        if (!sortRules || sortRules.length === 0) {
            return undefined;
        }
        const field = sortRules[0].code;
        return field.startsWith('-') ? field.substr(1) : field;
    }
    function isSortDescending(definition) {
        const sortRules = definition.sortRules;
        if (!sortRules || sortRules.length === 0) {
            return false;
        }
        return !!sortRules[0].descending;
    }
    /**
     * Returns a list of operators for a search parameter.
     * @param searchParam The search parameter.
     * @returns The list of operators that can be used for the search parameter.
     */
    function getSearchOperators(searchParam) {
        return searchParamToOperators[searchParam.type];
    }
    /**
     * Returns a string representing the operation.
     *
     * @param {string} op The operation code.
     * @return {string} A display string for the operation.
     */
    function getOpString(op) {
        return operatorNames[op] ?? '';
    }
    /**
     * Returns a field display name.
     * @param key The field key.
     * @returns The field display name.
     */
    function buildFieldNameString(key) {
        let tmp = key;
        // If dot separated, only the last part
        if (tmp.includes('.')) {
            tmp = tmp.split('.').pop();
        }
        // Special case for ID
        if (tmp === 'id') {
            return 'ID';
        }
        // Special case for Version ID
        if (tmp === 'versionId') {
            return 'Version ID';
        }
        // Remove choice of type
        tmp = tmp.replace('[x]', '');
        // Convert camel case to space separated
        tmp = tmp.replace(/([A-Z])/g, ' $1');
        // Convert dashes and underscores to spaces
        tmp = tmp.replace(/[-_]/g, ' ');
        // Normalize whitespace to single space character
        tmp = tmp.replace(/\s+/g, ' ');
        // Trim
        tmp = tmp.trim();
        // Capitalize the first letter of each word
        return tmp.split(/\s/).map(core.capitalize).join(' ');
    }
    /**
     * Returns a fragment to be displayed in the search table for the value.
     * @param resource The parent resource.
     * @param key The search code or FHIRPath expression.
     * @returns The fragment to display.
     */
    function renderValue(resource, field) {
        const key = field.name;
        if (key === 'id') {
            return resource.id;
        }
        if (key === 'meta.versionId') {
            return resource.meta?.versionId;
        }
        if (key === '_lastUpdated') {
            return core.formatDateTime(resource.meta?.lastUpdated);
        }
        // Priority 1: ElementDefinition by exact match
        if (field.elementDefinition && `${resource.resourceType}.${field.name}` === field.elementDefinition.path) {
            return renderPropertyValue(resource, field.elementDefinition);
        }
        // Priority 2: SearchParameter by exact match
        if (field.searchParams && field.searchParams.length === 1 && field.name === field.searchParams[0].code) {
            return renderSearchParameterValue(resource, field.searchParams[0], field.elementDefinition);
        }
        // We don't know how to render this field definition
        return null;
    }
    /**
     * Returns a fragment to be displayed in the search table for a resource property.
     * @param resource The parent resource.
     * @param elementDefinition The property element definition.
     * @returns A React element or null.
     */
    function renderPropertyValue(resource, elementDefinition) {
        const path = elementDefinition.path?.split('.')?.pop()?.replaceAll('[x]', '') || '';
        const [value, propertyType] = getValueAndType({ type: resource.resourceType, value: resource }, path);
        if (!value) {
            return null;
        }
        return (React.createElement(ResourcePropertyDisplay, { property: elementDefinition, propertyType: propertyType, value: value, maxWidth: 200, ignoreMissingValues: true, link: false }));
    }
    /**
     * Returns a fragment to be displayed in the search table for a search parameter.
     * @param resource The parent resource.
     * @param searchParam The search parameter.
     * @param elementDefinition Optional element definition.
     * @returns A React element or null.
     */
    function renderSearchParameterValue(resource, searchParam, elementDefinition) {
        const value = core.evalFhirPathTyped(searchParam.expression, [{ type: resource.resourceType, value: resource }]);
        if (!value || value.length === 0) {
            return null;
        }
        if (elementDefinition) {
            return (React.createElement(ResourcePropertyDisplay, { propertyType: value[0].type, value: value[0].value, maxWidth: 200, ignoreMissingValues: true, link: false }));
        }
        return (React.createElement(React.Fragment, null, value.map((v, index) => (React.createElement("span", { key: `${index}-${value.length}` }, typeof v === 'object' ? JSON.stringify(v) : v)))));
    }

    function SearchFieldEditor(props) {
        const [state, setState] = React.useState({
            search: JSON.parse(core.stringify(props.search)),
        });
        const availableRef = React.useRef(null);
        const selectedRef = React.useRef(null);
        React.useEffect(() => {
            setState({ search: props.search });
        }, [props.search]);
        /**
         * Handles a key down event on the "available" field.
         * If the user presses enter, it is a shortcut for the "Add" button.
         *
         * @param {KeyboardEvent} e The keyboard event.
         */
        function handleAvailableKeyDown(e) {
            if (e.key === 'Enter') {
                onAddField();
            }
        }
        /**
         * Handles a double click on the "available" field.
         * If the user double clicks an entry, it is a shortcut for the "Add" button.
         */
        function handleAvailableDoubleClick() {
            onAddField();
        }
        /**
         * Handles a key down event on the "available" field.
         * If the user presses enter, it is a shortcut for the "Add" button.
         *
         * @param {KeyboardEvent} e The keyboard event.
         */
        function handleSelectedKeyDown(e) {
            if (e.key === 'Enter') {
                onRemoveField();
            }
        }
        /**
         * Handles a double click on the "available" field.
         * If the user double clicks an entry, it is a shortcut for the "Add" button.
         */
        function handleSelectedDoubleClick() {
            onRemoveField();
        }
        /**
         * Handles a click on the "Add" button.
         * Moves the "available" selection into the "selected" list.
         */
        function onAddField() {
            const currentField = state.search.fields ?? [];
            const key = availableRef.current?.value;
            if (key) {
                const newFields = [...currentField, key];
                setState({
                    search: {
                        ...state.search,
                        fields: newFields,
                    },
                });
            }
        }
        /**
         * Handles a click on the "Remove" button.
         * Moves the "selected" selection into the "available" list.
         */
        function onRemoveField() {
            const currentField = state.search.fields ?? [];
            const key = selectedRef.current?.value;
            if (key) {
                const newFields = [...currentField];
                newFields.splice(newFields.indexOf(key), 1);
                setState({
                    search: {
                        ...state.search,
                        fields: newFields,
                    },
                });
            }
        }
        /**
         * Handles a click on the "Up" button.
         * Moves the selection up one position in the list.
         */
        function onMoveUp() {
            const currentField = state.search.fields ?? [];
            const field = selectedRef.current?.value;
            if (field) {
                const newFields = [...currentField];
                const index = newFields.indexOf(field);
                swapFields(newFields, index, index - 1);
                setState({
                    search: {
                        ...state.search,
                        fields: newFields,
                    },
                });
            }
        }
        /**
         * Handles a click on the "Down" button.
         * Moves the selection down one position in the list.
         */
        function onMoveDown() {
            const currentField = state.search.fields ?? [];
            const field = selectedRef.current?.value;
            if (field) {
                const newFields = [...currentField];
                const index = newFields.indexOf(field);
                swapFields(newFields, index, index + 1);
                setState({
                    search: {
                        ...state.search,
                        fields: newFields,
                    },
                });
            }
        }
        /**
         * Swaps two fields in the search.
         *
         * @param {number} i The index of the first field.
         * @param {number} j The index of the second field.
         */
        function swapFields(fields, i, j) {
            const temp = fields[i];
            fields[i] = fields[j];
            fields[j] = temp;
        }
        if (!props.visible) {
            return null;
        }
        const resourceType = props.search.resourceType;
        const typeDef = core.globalSchema.types[resourceType];
        const selected = state.search.fields ?? [];
        const available = getFieldsList(typeDef)
            .filter((field) => !selected?.includes(field))
            .sort();
        return (React.createElement(core$1.Modal, { title: "Fields", closeButtonLabel: "Close", opened: props.visible, onClose: props.onCancel },
            React.createElement("div", null,
                React.createElement("table", { style: { margin: 'auto' } },
                    React.createElement("thead", null,
                        React.createElement("tr", null,
                            React.createElement("th", { colSpan: 2, align: "center" }, "Available"),
                            React.createElement("th", { colSpan: 2, align: "center" }, "Selected"))),
                    React.createElement("tbody", null,
                        React.createElement("tr", null,
                            React.createElement("td", { colSpan: 2, align: "center" },
                                React.createElement("select", { ref: availableRef, size: 15, tabIndex: 1, style: { width: '200px' }, onKeyDown: (e) => handleAvailableKeyDown(e), onDoubleClick: () => handleAvailableDoubleClick(), "data-testid": "available" }, available.map((key) => (React.createElement("option", { key: key, value: key }, buildFieldNameString(key)))))),
                            React.createElement("td", { colSpan: 2, align: "center" },
                                React.createElement("select", { ref: selectedRef, size: 15, tabIndex: 4, style: { width: '200px' }, onKeyDown: (e) => handleSelectedKeyDown(e), onDoubleClick: () => handleSelectedDoubleClick(), "data-testid": "selected" }, selected.map((key) => (React.createElement("option", { key: key, value: key }, buildFieldNameString(key)))))))),
                    React.createElement("tfoot", null,
                        React.createElement("tr", null,
                            React.createElement("td", { align: "center" },
                                React.createElement(core$1.Button, { compact: true, variant: "outline", onClick: onAddField }, "Add")),
                            React.createElement("td", { align: "center" },
                                React.createElement(core$1.Button, { compact: true, variant: "outline", onClick: onRemoveField }, "Remove")),
                            React.createElement("td", { align: "center" },
                                React.createElement(core$1.Button, { compact: true, variant: "outline", onClick: onMoveUp }, "Up")),
                            React.createElement("td", { align: "center" },
                                React.createElement(core$1.Button, { compact: true, variant: "outline", onClick: onMoveDown }, "Down")))))),
            React.createElement(core$1.Button, { onClick: () => props.onOk(state.search) }, "OK")));
    }
    /**
     * Returns a list of fields/columns available for a type.
     * The result is the union of properties and search parameters.
     * @param typeSchema The type definition.
     */
    function getFieldsList(typeSchema) {
        const result = [];
        const keys = new Set();
        const names = new Set();
        // Add properties first
        for (const key of Object.keys(typeSchema.properties)) {
            result.push(key);
            keys.add(key.toLowerCase());
            names.add(buildFieldNameString(key));
        }
        // Add search parameters if unique
        if (typeSchema.searchParams) {
            for (const code of Object.keys(typeSchema.searchParams)) {
                const name = buildFieldNameString(code);
                if (!keys.has(code) && !names.has(name)) {
                    result.push(code);
                    keys.add(code);
                    names.add(buildFieldNameString(code));
                }
            }
        }
        return result;
    }

    function SearchFilterValueDisplay(props) {
        const { resourceType, filter } = props;
        const searchParam = core.globalSchema.types[resourceType]?.searchParams?.[filter.code];
        if (searchParam) {
            if (searchParam.type === 'reference') {
                return React.createElement(ResourceName, { value: { reference: filter.value } });
            }
            const searchParamDetails = core.getSearchParameterDetails(resourceType, searchParam);
            if (filter.code === '_lastUpdated' || searchParamDetails.type === core.SearchParameterType.DATETIME) {
                return React.createElement(React.Fragment, null, core.formatDateTime(filter.value));
            }
        }
        return React.createElement(React.Fragment, null, filter.value);
    }

    function SearchFilterValueInput(props) {
        const details = core.getSearchParameterDetails(props.resourceType, props.searchParam);
        const name = 'filter-value';
        switch (details.type) {
            case core.SearchParameterType.REFERENCE:
                return (React.createElement(ReferenceInput, { name: name, defaultValue: { reference: props.defaultValue }, targetTypes: props.searchParam?.target, onChange: (newReference) => {
                        if (newReference) {
                            props.onChange(newReference.reference);
                        }
                        else {
                            props.onChange('');
                        }
                    } }));
            case core.SearchParameterType.BOOLEAN:
                return (React.createElement(core$1.Checkbox, { name: name, "data-testid": name, defaultChecked: props.defaultValue === 'true', onChange: (e) => props.onChange(e.currentTarget.checked.toString()) }));
            case core.SearchParameterType.DATE:
                return (React.createElement(core$1.TextInput, { type: "date", name: name, "data-testid": name, defaultValue: props.defaultValue, onChange: (e) => props.onChange(e.currentTarget.value) }));
            case core.SearchParameterType.DATETIME:
                return React.createElement(DateTimeInput, { name: name, defaultValue: props.defaultValue, onChange: props.onChange });
            case core.SearchParameterType.NUMBER:
                return (React.createElement(core$1.TextInput, { type: "number", name: name, "data-testid": name, defaultValue: props.defaultValue, onChange: (e) => props.onChange(e.currentTarget.value) }));
            case core.SearchParameterType.QUANTITY:
                return (React.createElement(QuantityInput, { name: name, defaultValue: tryParseQuantity(props.defaultValue), onChange: (newQuantity) => {
                        if (newQuantity) {
                            props.onChange(`${newQuantity.value}`);
                        }
                        else {
                            props.onChange('');
                        }
                    } }));
            default:
                return (React.createElement(core$1.TextInput, { name: name, "data-testid": name, defaultValue: props.defaultValue, autoFocus: props.autoFocus, onChange: (e) => props.onChange(e.currentTarget.value), placeholder: "Search value" }));
        }
    }
    function tryParseQuantity(value) {
        if (value) {
            const [valueString, systemString, unitString] = value.split('|');
            if (valueString) {
                return {
                    value: parseFloat(valueString),
                    system: systemString,
                    unit: unitString,
                };
            }
        }
        return undefined;
    }

    function SearchFilterEditor(props) {
        const [search, setSearch] = React.useState(JSON.parse(core.stringify(props.search)));
        const [editingIndex, setEditingIndex] = React.useState(-1);
        const searchRef = React.useRef(search);
        searchRef.current = search;
        React.useEffect(() => {
            setSearch(JSON.parse(core.stringify(props.search)));
        }, [props.search]);
        function onAddFilter(filter) {
            setSearch(addFilter(searchRef.current, filter.code, filter.operator, filter.value));
        }
        if (!props.visible) {
            return null;
        }
        const resourceType = props.search.resourceType;
        const searchParams = core.globalSchema.types[resourceType].searchParams;
        const filters = search.filters || [];
        return (React.createElement(core$1.Modal, { title: "Filters", closeButtonLabel: "Close", size: 900, opened: props.visible, onClose: props.onCancel },
            React.createElement("div", null,
                React.createElement("table", null,
                    React.createElement("colgroup", null,
                        React.createElement("col", { style: { width: 200 } }),
                        React.createElement("col", { style: { width: 200 } }),
                        React.createElement("col", { style: { width: 380 } }),
                        React.createElement("col", { style: { width: 120 } })),
                    React.createElement("thead", null,
                        React.createElement("tr", null,
                            React.createElement("th", null, "Field"),
                            React.createElement("th", null, "Operation"),
                            React.createElement("th", null, "Value"),
                            React.createElement("th", null, "Actions"))),
                    React.createElement("tbody", null,
                        filters.map((filter, index) => {
                            if (index === editingIndex) {
                                return (React.createElement(FilterRowInput, { key: `filter-${index}-${filters.length}-input`, resourceType: resourceType, searchParams: searchParams, defaultValue: filter, okText: "Save", onOk: (newFilter) => {
                                        const newFilters = [...filters];
                                        newFilters[index] = newFilter;
                                        setSearch(setFilters(searchRef.current, newFilters));
                                        setEditingIndex(-1);
                                    }, onCancel: () => setEditingIndex(-1) }));
                            }
                            else {
                                return (React.createElement(FilterRowDisplay, { key: `filter-${index}-${filters.length}-display`, resourceType: resourceType, searchParams: searchParams, filter: filter, onEdit: () => setEditingIndex(index), onDelete: () => setSearch(deleteFilter(searchRef.current, index)) }));
                            }
                        }),
                        React.createElement(FilterRowInput, { resourceType: resourceType, searchParams: searchParams, okText: "Add", onOk: onAddFilter })))),
            React.createElement(core$1.Group, { position: "right", mt: "xl" },
                React.createElement(core$1.Button, { onClick: () => props.onOk(searchRef.current) }, "OK"))));
    }
    function FilterRowDisplay(props) {
        const { filter } = props;
        return (React.createElement("tr", null,
            React.createElement("td", null, buildFieldNameString(filter.code)),
            React.createElement("td", null, getOpString(filter.operator)),
            React.createElement("td", null,
                React.createElement(SearchFilterValueDisplay, { resourceType: props.resourceType, filter: filter })),
            React.createElement("td", null,
                React.createElement(core$1.Button, { compact: true, variant: "outline", onClick: props.onEdit }, "Edit"),
                React.createElement(core$1.Button, { compact: true, variant: "outline", onClick: props.onDelete }, "Delete"))));
    }
    function FilterRowInput(props) {
        const [value, setValue] = React.useState(props.defaultValue ?? {});
        const valueRef = React.useRef(value);
        valueRef.current = value;
        function setFilterCode(newCode) {
            setValue({ ...valueRef.current, code: newCode });
        }
        function setFilterOperator(newOperator) {
            setValue({ ...valueRef.current, operator: newOperator });
        }
        function setFilterValue(newFilterValue) {
            setValue({ ...valueRef.current, value: newFilterValue });
        }
        const searchParam = props.searchParams[value.code];
        const operators = searchParam && getSearchOperators(searchParam);
        return (React.createElement("tr", null,
            React.createElement("td", null,
                React.createElement(core$1.NativeSelect, { "data-testid": "filter-field", defaultValue: valueRef.current.code, onChange: (e) => setFilterCode(e.currentTarget.value), data: Object.keys(props.searchParams).map((param) => ({ value: param, label: buildFieldNameString(param) })) })),
            React.createElement("td", null, operators && (React.createElement(core$1.NativeSelect, { "data-testid": "filter-operation", defaultValue: value.operator, onChange: (e) => setFilterOperator(e.currentTarget.value), data: ['', ...operators.map((op) => ({ value: op, label: getOpString(op) }))] }))),
            React.createElement("td", null, searchParam && value.operator && (React.createElement(SearchFilterValueInput, { resourceType: props.resourceType, searchParam: searchParam, defaultValue: value.value, onChange: setFilterValue }))),
            React.createElement("td", null,
                value.code && value.operator && value.value && (React.createElement(core$1.Button, { compact: true, variant: "outline", onClick: () => {
                        props.onOk(valueRef.current);
                        setValue({});
                    } }, props.okText)),
                props.onCancel && (React.createElement(core$1.Button, { compact: true, variant: "outline", onClick: props.onCancel }, "Cancel")))));
    }

    function SearchFilterValueDialog(props) {
        const [value, setValue] = React.useState(props.defaultValue ?? '');
        if (!props.visible || !props.searchParam || !props.filter) {
            return null;
        }
        function onOk() {
            props.onOk({ ...props.filter, value });
        }
        return (React.createElement(core$1.Modal, { title: props.title, size: "xl", opened: props.visible, onClose: props.onCancel },
            React.createElement("div", { style: { width: 500 } },
                React.createElement(Form, { onSubmit: onOk },
                    React.createElement(SearchFilterValueInput, { resourceType: props.resourceType, searchParam: props.searchParam, defaultValue: value, autoFocus: true, onChange: setValue }))),
            React.createElement(core$1.Button, { onClick: onOk }, "OK")));
    }

    function SearchPopupMenu(props) {
        if (!props.searchParams) {
            return null;
        }
        function onSort(searchParam, desc) {
            onChange(setSort(props.search, searchParam.code, desc));
        }
        function onClear(searchParam) {
            onChange(clearFiltersOnField(props.search, searchParam.code));
        }
        function onPrompt(searchParam, operator) {
            props.onPrompt(searchParam, { code: searchParam.code, operator, value: '' });
        }
        function onChange(definition) {
            props.onChange(definition);
        }
        // If there is only one search parameter, then show it directly
        if (props.searchParams.length === 1) {
            return (React.createElement(SearchParameterSubMenu, { search: props.search, searchParam: props.searchParams[0], onSort: onSort, onPrompt: onPrompt, onChange: onChange, onClear: onClear }));
        }
        // Otherwise, show a menu, with each search parameter as a sub menu
        return (React.createElement(core$1.Menu.Dropdown, null, props.searchParams.map((searchParam) => (React.createElement(core$1.Menu.Item, { key: searchParam.code }, buildFieldNameString(searchParam.code))))));
    }
    function SearchParameterSubMenu(props) {
        switch (props.searchParam.type) {
            case 'date':
                return React.createElement(DateFilterSubMenu, { ...props });
            case 'number':
            case 'quantity':
                return React.createElement(NumericFilterSubMenu, { ...props });
            case 'reference':
                return React.createElement(ReferenceFilterSubMenu, { ...props });
            case 'string':
            case 'token':
            case 'uri':
                return React.createElement(TextFilterSubMenu, { ...props });
            default:
                return React.createElement(React.Fragment, null,
                    "Unknown search param type: ",
                    props.searchParam.type);
        }
    }
    function DateFilterSubMenu(props) {
        const { searchParam } = props;
        const code = searchParam.code;
        return (React.createElement(core$1.Menu.Dropdown, null,
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconSortAscending, { size: 14 }), onClick: () => props.onSort(searchParam, false) }, "Sort Oldest to Newest"),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconSortDescending, { size: 14 }), onClick: () => props.onSort(searchParam, true) }, "Sort Newest to Oldest"),
            React.createElement(core$1.Menu.Divider, null),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconEqual, { size: 14 }), onClick: () => props.onPrompt(searchParam, core.Operator.EQUALS) }, "Equals..."),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconEqualNot, { size: 14 }), onClick: () => props.onPrompt(searchParam, core.Operator.NOT_EQUALS) }, "Does not equal..."),
            React.createElement(core$1.Menu.Divider, null),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconMathLower, { size: 14 }), onClick: () => props.onPrompt(searchParam, core.Operator.ENDS_BEFORE) }, "Before..."),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconMathGreater, { size: 14 }), onClick: () => props.onPrompt(searchParam, core.Operator.STARTS_AFTER) }, "After..."),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconBracketsContain, { size: 14 }), onClick: () => props.onPrompt(searchParam, core.Operator.EQUALS) }, "Between..."),
            React.createElement(core$1.Menu.Divider, null),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconCalendar, { size: 14 }), onClick: () => props.onChange(addTomorrowFilter(props.search, code)) }, "Tomorrow"),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconCalendar, { size: 14 }), onClick: () => props.onChange(addTodayFilter(props.search, code)) }, "Today"),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconCalendar, { size: 14 }), onClick: () => props.onChange(addYesterdayFilter(props.search, code)) }, "Yesterday"),
            React.createElement(core$1.Menu.Divider, null),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconCalendar, { size: 14 }), onClick: () => props.onChange(addNextMonthFilter(props.search, code)) }, "Next Month"),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconCalendar, { size: 14 }), onClick: () => props.onChange(addThisMonthFilter(props.search, code)) }, "This Month"),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconCalendar, { size: 14 }), onClick: () => props.onChange(addLastMonthFilter(props.search, code)) }, "Last Month"),
            React.createElement(core$1.Menu.Divider, null),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconCalendar, { size: 14 }), onClick: () => props.onChange(addYearToDateFilter(props.search, code)) }, "Year to date"),
            React.createElement(CommonMenuItems, { ...props })));
    }
    function NumericFilterSubMenu(props) {
        const { searchParam } = props;
        return (React.createElement(core$1.Menu.Dropdown, null,
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconSortAscending, { size: 14 }), onClick: () => props.onSort(searchParam, false) }, "Sort Smallest to Largest"),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconSortDescending, { size: 14 }), onClick: () => props.onSort(searchParam, true) }, "Sort Largest to Smallest"),
            React.createElement(core$1.Menu.Divider, null),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconEqual, { size: 14 }), onClick: () => props.onPrompt(searchParam, core.Operator.EQUALS) }, "Equals..."),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconEqualNot, { size: 14 }), onClick: () => props.onPrompt(searchParam, core.Operator.NOT_EQUALS) }, "Does not equal..."),
            React.createElement(core$1.Menu.Divider, null),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconMathGreater, { size: 14 }), onClick: () => props.onPrompt(searchParam, core.Operator.GREATER_THAN) }, "Greater than..."),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconSettings, { size: 14 }), onClick: () => props.onPrompt(searchParam, core.Operator.GREATER_THAN_OR_EQUALS) }, "Greater than or equal to..."),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconMathLower, { size: 14 }), onClick: () => props.onPrompt(searchParam, core.Operator.LESS_THAN) }, "Less than..."),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconSettings, { size: 14 }), onClick: () => props.onPrompt(searchParam, core.Operator.LESS_THAN_OR_EQUALS) }, "Less than or equal to..."),
            React.createElement(CommonMenuItems, { ...props })));
    }
    function ReferenceFilterSubMenu(props) {
        const { searchParam } = props;
        return (React.createElement(core$1.Menu.Dropdown, null,
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconEqual, { size: 14 }), onClick: () => props.onPrompt(searchParam, core.Operator.EQUALS) }, "Equals..."),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconEqualNot, { size: 14 }), onClick: () => props.onPrompt(searchParam, core.Operator.NOT) }, "Does not equal..."),
            React.createElement(CommonMenuItems, { ...props })));
    }
    function TextFilterSubMenu(props) {
        const { searchParam } = props;
        return (React.createElement(core$1.Menu.Dropdown, null,
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconSortAscending, { size: 14 }), onClick: () => props.onSort(searchParam, false) }, "Sort A to Z"),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconSortDescending, { size: 14 }), onClick: () => props.onSort(searchParam, true) }, "Sort Z to A"),
            React.createElement(core$1.Menu.Divider, null),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconEqual, { size: 14 }), onClick: () => props.onPrompt(searchParam, core.Operator.EQUALS) }, "Equals..."),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconEqualNot, { size: 14 }), onClick: () => props.onPrompt(searchParam, core.Operator.NOT) }, "Does not equal..."),
            React.createElement(core$1.Menu.Divider, null),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconBucket, { size: 14 }), onClick: () => props.onPrompt(searchParam, core.Operator.CONTAINS) }, "Contains..."),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconBucketOff, { size: 14 }), onClick: () => props.onPrompt(searchParam, core.Operator.EQUALS) }, "Does not contain..."),
            React.createElement(CommonMenuItems, { ...props })));
    }
    function CommonMenuItems(props) {
        const { searchParam } = props;
        const code = searchParam.code;
        return (React.createElement(React.Fragment, null,
            React.createElement(core$1.Menu.Divider, null),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconBleach, { size: 14 }), onClick: () => props.onChange(addMissingFilter(props.search, code)) }, "Missing"),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconBleachOff, { size: 14 }), onClick: () => props.onChange(addMissingFilter(props.search, code, false)) }, "Not missing"),
            React.createElement(core$1.Menu.Divider, null),
            React.createElement(core$1.Menu.Item, { icon: React.createElement(icons.IconX, { size: 14 }), onClick: () => props.onClear(searchParam) }, "Clear filters")));
    }

    /**
     * Returns the collection of field definitions for the search request.
     * @param search The search request definition.
     * @returns An array of field definitions.
     */
    function getFieldDefinitions(search) {
        const resourceType = search.resourceType;
        const fields = [];
        for (const name of search.fields || ['id', '_lastUpdated']) {
            fields.push(getFieldDefinition(resourceType, name));
        }
        return fields;
    }
    /**
     * Return the field definition for a given field name.
     * Field names can be either property names or search parameter codes.
     * @param resourceType The resource type.
     * @param name The search field name (either property name or search parameter code).
     * @returns The field definition.
     */
    function getFieldDefinition(resourceType, name) {
        if (name === '_lastUpdated') {
            return {
                name: '_lastUpdated',
                searchParams: [
                    {
                        resourceType: 'SearchParameter',
                        base: ['Resource'],
                        code: '_lastUpdated',
                        name: '_lastUpdated',
                        type: 'date',
                        expression: 'Resource.meta.lastUpdated',
                    },
                ],
            };
        }
        if (name === 'meta.versionId') {
            return {
                name: 'meta.versionId',
                searchParams: [
                    {
                        resourceType: 'SearchParameter',
                        base: ['Resource'],
                        code: '_versionId',
                        name: '_versionId',
                        type: 'token',
                        expression: 'Resource.meta.versionId',
                    },
                ],
            };
        }
        const typeSchema = core.globalSchema.types[resourceType];
        const exactElementDefinition = typeSchema.properties[name];
        const exactSearchParam = typeSchema.searchParams?.[name.toLowerCase()];
        // Best case: Exact match of element definition or search parameter.
        // Examples: ServiceRequest.subject, Patient.name, Patient.birthDate
        // In this case, we only show the one search parameter.
        if (exactElementDefinition && exactSearchParam) {
            return { name, elementDefinition: exactElementDefinition, searchParams: [exactSearchParam] };
        }
        // Next best case: Exact match of element definition
        // Examples: Observation.value
        // In this case, there could be zero or more search parameters that are a function of the element definition.
        // So search for those search parameters.
        if (exactElementDefinition) {
            let searchParams = undefined;
            if (typeSchema.searchParams) {
                const path = `${resourceType}.${name.replaceAll('[x]', '')}`;
                searchParams = Object.values(typeSchema.searchParams).filter((p) => p.expression?.includes(path));
                if (searchParams.length === 0) {
                    searchParams = undefined;
                }
            }
            return { name, elementDefinition: exactElementDefinition, searchParams };
        }
        // Search parameter case: Exact match of search parameter
        // Examples: Observation.value-quantity, Patient.email
        // Here we have a search parameter, but no element definition.
        // Observation.value-quantity is a search parameter for the Observation.value element.
        // Patient.email is a search parameter for the Patient.telecom element.
        // So we need to walk backwards to find the element definition.
        if (exactSearchParam) {
            const details = core.getSearchParameterDetails(resourceType, exactSearchParam);
            return { name, elementDefinition: details.elementDefinition, searchParams: [exactSearchParam] };
        }
        // Worst case: no element definition and no search parameter.
        // This is probably a malformed URL that includes an unknown field.
        // We will render the column header, but all cells will be empty.
        return { name };
    }

    class SearchChangeEvent extends Event {
        constructor(definition) {
            super('change');
            this.definition = definition;
        }
    }
    class SearchLoadEvent extends Event {
        constructor(response) {
            super('load');
            this.response = response;
        }
    }
    class SearchClickEvent extends Event {
        constructor(resource, browserEvent) {
            super('click');
            this.resource = resource;
            this.browserEvent = browserEvent;
        }
    }
    const useStyles$6 = core$1.createStyles((theme) => ({
        root: {
            maxWidth: '100%',
            overflow: 'auto',
            textAlign: 'left',
            marginBottom: '20px',
        },
        table: {
            cursor: 'pointer',
        },
        tr: {
            '&:hover': {
                backgroundColor: theme.colorScheme === 'dark' ? theme.colors.dark[7] : theme.colors.gray[0],
            },
        },
        th: {
            padding: '0 !important',
        },
        control: {
            width: '100%',
            padding: `${theme.spacing.xs}px ${theme.spacing.md}px`,
            '&:hover': {
                backgroundColor: theme.colorScheme === 'dark' ? theme.colors.dark[6] : theme.colors.gray[0],
            },
        },
        icon: {
            width: 21,
            height: 21,
            borderRadius: 21,
        },
    }));
    /**
     * The SearchControl component represents the embeddable search table control.
     * It includes the table, rows, headers, sorting, etc.
     * It does not include the field editor, filter editor, pagination buttons.
     */
    function SearchControl(props) {
        const { classes } = useStyles$6();
        const medplum = useMedplum();
        const [schemaLoaded, setSchemaLoaded] = React.useState(false);
        const [outcome, setOutcome] = React.useState();
        const { search, onLoad } = props;
        const [state, setState] = React.useState({
            selected: {},
            fieldEditorVisible: false,
            filterEditorVisible: false,
            filterDialogVisible: false,
        });
        const stateRef = React.useRef(state);
        stateRef.current = state;
        React.useEffect(() => {
            setOutcome(undefined);
            medplum
                .search(search.resourceType, core.formatSearchQuery({ ...search, total: 'accurate', fields: undefined }))
                .then((response) => {
                setState({ ...stateRef.current, searchResponse: response });
                if (onLoad) {
                    onLoad(new SearchLoadEvent(response));
                }
            })
                .catch((reason) => {
                setState({ ...stateRef.current, searchResponse: undefined });
                setOutcome(reason);
            });
        }, [medplum, search, onLoad]);
        function handleSingleCheckboxClick(e, id) {
            e.stopPropagation();
            const el = e.target;
            const checked = el.checked;
            const newSelected = { ...stateRef.current.selected };
            if (checked) {
                newSelected[id] = true;
            }
            else {
                delete newSelected[id];
            }
            setState({ ...stateRef.current, selected: newSelected });
        }
        function handleAllCheckboxClick(e) {
            e.stopPropagation();
            const el = e.target;
            const checked = el.checked;
            const newSelected = {};
            const searchResponse = stateRef.current?.searchResponse;
            if (checked && searchResponse?.entry) {
                searchResponse.entry.forEach((entry) => {
                    if (entry.resource?.id) {
                        newSelected[entry.resource.id] = true;
                    }
                });
            }
            setState({ ...stateRef.current, selected: newSelected });
        }
        function isAllSelected() {
            const state = stateRef.current;
            if (!state.searchResponse?.entry || state.searchResponse.entry.length === 0) {
                return false;
            }
            for (const e of state.searchResponse.entry) {
                if (e.resource?.id && !state.selected[e.resource.id]) {
                    return false;
                }
            }
            return true;
        }
        /**
         * Emits a change event to the optional change listener.
         * @param newSearch The new search definition.
         */
        function emitSearchChange(newSearch) {
            if (props.onChange) {
                props.onChange(new SearchChangeEvent(newSearch));
            }
        }
        /**
         * Handles a click on a order row.
         *
         * @param e The click event.
         * @param resource The FHIR resource.
         */
        function handleRowClick(e, resource) {
            if (isCheckboxCell(e.target)) {
                // Ignore clicks on checkboxes
                return;
            }
            if (e.button === 2) {
                // Ignore right clicks
                return;
            }
            killEvent(e);
            if (e.button !== 1 && props.onClick) {
                props.onClick(new SearchClickEvent(resource, e));
            }
            if (e.button === 1 && props.onAuxClick) {
                props.onAuxClick(new SearchClickEvent(resource, e));
            }
        }
        React.useEffect(() => {
            setSchemaLoaded(false);
            medplum
                .requestSchema(props.search.resourceType)
                .then(() => setSchemaLoaded(true))
                .catch(console.log);
        }, [medplum, props.search.resourceType]);
        const typeSchema = schemaLoaded && core.globalSchema?.types?.[props.search.resourceType];
        if (!typeSchema) {
            return (React.createElement(core$1.Center, { style: { width: '100%', height: '100%' } },
                React.createElement(core$1.Loader, null)));
        }
        const checkboxColumn = props.checkboxesEnabled;
        const fields = getFieldDefinitions(search);
        const resourceType = search.resourceType;
        const lastResult = state.searchResponse;
        const entries = lastResult?.entry;
        const resources = entries?.map((e) => e.resource);
        const buttonVariant = 'subtle';
        const buttonColor = 'gray';
        const iconSize = 16;
        const isMobile = window.innerWidth < 768;
        return (React.createElement("div", { className: classes.root, "data-testid": "search-control" },
            !props.hideToolbar && (React.createElement(core$1.Group, { position: "apart", mb: "xl" },
                React.createElement(core$1.Group, { spacing: 2 },
                    React.createElement(core$1.Button, { compact: true, variant: buttonVariant, color: buttonColor, leftIcon: React.createElement(icons.IconFilter, { size: iconSize }), onClick: () => setState({ ...stateRef.current, fieldEditorVisible: true }) }, "Fields"),
                    React.createElement(core$1.Button, { compact: true, variant: buttonVariant, color: buttonColor, leftIcon: React.createElement(icons.IconColumns, { size: iconSize }), onClick: () => setState({ ...stateRef.current, filterEditorVisible: true }) }, "Filters"),
                    props.onNew && (React.createElement(core$1.Button, { compact: true, variant: buttonVariant, color: buttonColor, leftIcon: React.createElement(icons.IconFilePlus, { size: iconSize }), onClick: props.onNew }, "New...")),
                    !isMobile && props.onExport && (React.createElement(core$1.Button, { compact: true, variant: buttonVariant, color: buttonColor, leftIcon: React.createElement(icons.IconTableExport, { size: iconSize }), onClick: props.onExport }, "Export...")),
                    !isMobile && props.onDelete && (React.createElement(core$1.Button, { compact: true, variant: buttonVariant, color: buttonColor, leftIcon: React.createElement(icons.IconTrash, { size: iconSize }), onClick: () => props.onDelete(Object.keys(state.selected)) }, "Delete...")),
                    !isMobile && props.onBulk && (React.createElement(core$1.Button, { compact: true, variant: buttonVariant, color: buttonColor, leftIcon: React.createElement(icons.IconBoxMultiple, { size: iconSize }), onClick: () => props.onBulk(Object.keys(state.selected)) }, "Bulk..."))),
                lastResult && (React.createElement(core$1.Text, { size: "xs", color: "dimmed" },
                    getStart$1(search, lastResult.total),
                    "-",
                    getEnd$1(search, lastResult.total),
                    " of",
                    ' ',
                    lastResult.total?.toLocaleString())))),
            React.createElement(core$1.Table, { className: classes.table },
                React.createElement("thead", null,
                    React.createElement("tr", null,
                        checkboxColumn && (React.createElement("th", null,
                            React.createElement("input", { type: "checkbox", value: "checked", "aria-label": "all-checkbox", "data-testid": "all-checkbox", checked: isAllSelected(), onChange: (e) => handleAllCheckboxClick(e) }))),
                        fields.map((field) => (React.createElement("th", { key: field.name },
                            React.createElement(core$1.Menu, { shadow: "md", width: 240, position: "bottom-end" },
                                React.createElement(core$1.Menu.Target, null,
                                    React.createElement(core$1.UnstyledButton, { className: classes.control },
                                        React.createElement(core$1.Group, { position: "apart", noWrap: true },
                                            React.createElement(core$1.Text, { weight: 500, size: "sm" }, buildFieldNameString(field.name)),
                                            React.createElement(core$1.Center, { className: classes.icon },
                                                React.createElement(icons.IconAdjustmentsHorizontal, { size: 14, stroke: 1.5 }))))),
                                React.createElement(SearchPopupMenu, { search: props.search, searchParams: field.searchParams, onPrompt: (searchParam, filter) => {
                                        setState({
                                            ...stateRef.current,
                                            filterDialogVisible: true,
                                            filterDialogSearchParam: searchParam,
                                            filterDialogFilter: filter,
                                        });
                                    }, onChange: (result) => {
                                        emitSearchChange(result);
                                    } })))))),
                    !props.hideFilters && (React.createElement("tr", null,
                        checkboxColumn && React.createElement("th", null),
                        fields.map((field) => (React.createElement("th", { key: field.name }, field.searchParams && (React.createElement(FilterDescription, { resourceType: resourceType, searchParams: field.searchParams, filters: props.search.filters })))))))),
                React.createElement("tbody", null, resources?.map((resource) => resource && (React.createElement("tr", { key: resource.id, className: classes.tr, "data-testid": "search-control-row", onClick: (e) => handleRowClick(e, resource), onAuxClick: (e) => handleRowClick(e, resource) },
                    checkboxColumn && (React.createElement("td", null,
                        React.createElement("input", { type: "checkbox", value: "checked", "data-testid": "row-checkbox", "aria-label": `Checkbox for ${resource.id}`, checked: !!state.selected[resource.id], onChange: (e) => handleSingleCheckboxClick(e, resource.id) }))),
                    fields.map((field) => (React.createElement("td", { key: field.name }, renderValue(resource, field))))))))),
            resources?.length === 0 && (React.createElement(Container, null,
                React.createElement(core$1.Center, null,
                    React.createElement(core$1.Text, { size: "xl", color: "dimmed" }, "No results")))),
            lastResult?.total !== undefined && lastResult.total > 0 && (React.createElement(core$1.Center, { m: "md", p: "md" },
                React.createElement(core$1.Pagination, { page: getPage(search), total: getTotalPages(search, lastResult.total), onChange: (newPage) => emitSearchChange(setPage(search, newPage)), getItemAriaLabel: (page) => {
                        switch (page) {
                            case 'prev':
                                return 'Previous page';
                            case 'next':
                                return 'Next page';
                            default:
                                return undefined;
                        }
                    } }))),
            outcome && (React.createElement("div", { "data-testid": "search-error" },
                React.createElement("pre", { style: { textAlign: 'left' } }, JSON.stringify(outcome, undefined, 2)))),
            React.createElement(SearchFieldEditor, { search: props.search, visible: stateRef.current.fieldEditorVisible, onOk: (result) => {
                    emitSearchChange(result);
                    setState({
                        ...stateRef.current,
                        fieldEditorVisible: false,
                    });
                }, onCancel: () => {
                    setState({
                        ...stateRef.current,
                        fieldEditorVisible: false,
                    });
                } }),
            React.createElement(SearchFilterEditor, { search: props.search, visible: stateRef.current.filterEditorVisible, onOk: (result) => {
                    emitSearchChange(result);
                    setState({
                        ...stateRef.current,
                        filterEditorVisible: false,
                    });
                }, onCancel: () => {
                    setState({
                        ...stateRef.current,
                        filterEditorVisible: false,
                    });
                } }),
            React.createElement(SearchFilterValueDialog, { key: state.filterDialogSearchParam?.code, visible: stateRef.current.filterDialogVisible, title: 'Input', resourceType: resourceType, searchParam: state.filterDialogSearchParam, filter: state.filterDialogFilter, defaultValue: '', onOk: (filter) => {
                    emitSearchChange(addFilter(props.search, filter.code, filter.operator, filter.value));
                    setState({
                        ...stateRef.current,
                        filterDialogVisible: false,
                    });
                }, onCancel: () => {
                    setState({
                        ...stateRef.current,
                        filterDialogVisible: false,
                    });
                } })));
    }
    const MemoizedSearchControl = React.memo(SearchControl);
    function FilterDescription(props) {
        const filters = (props.filters ?? []).filter((f) => props.searchParams.find((p) => p.code === f.code));
        if (filters.length === 0) {
            return React.createElement("span", null, "no filters");
        }
        return (React.createElement(React.Fragment, null, filters.map((filter, index) => (React.createElement("div", { key: `filter-${index}-${filters.length}` },
            getOpString(filter.operator),
            "\u00A0",
            React.createElement(SearchFilterValueDisplay, { resourceType: props.resourceType, filter: filter }))))));
    }
    function getPage(search) {
        return Math.floor((search.offset || 0) / (search.count || core.DEFAULT_SEARCH_COUNT)) + 1;
    }
    function getTotalPages(search, total) {
        const pageSize = search.count || core.DEFAULT_SEARCH_COUNT;
        return Math.ceil(total / pageSize);
    }
    function getStart$1(search, total) {
        return Math.min(total, (search.offset ?? 0) + 1);
    }
    function getEnd$1(search, total) {
        return Math.min(total, ((search.offset ?? 0) + 1) * (search.count ?? core.DEFAULT_SEARCH_COUNT));
    }

    /**
     * The FhirPathTable component represents the embeddable search table control.
     */
    function FhirPathTable(props) {
        const medplum = useMedplum();
        const [schema, setSchema] = React.useState();
        const [outcome, setOutcome] = React.useState();
        const { query, fields } = props;
        const [response, setResponse] = React.useState();
        const [selected, setSelected] = React.useState({});
        const responseRef = React.useRef();
        responseRef.current = response;
        const selectedRef = React.useRef({});
        selectedRef.current = selected;
        React.useEffect(() => {
            setOutcome(undefined);
            medplum.graphql(query).then(setResponse).catch(setOutcome);
        }, [medplum, query]);
        function handleSingleCheckboxClick(e, id) {
            e.stopPropagation();
            const el = e.target;
            const checked = el.checked;
            const newSelected = { ...selectedRef.current };
            if (checked) {
                newSelected[id] = true;
            }
            else {
                delete newSelected[id];
            }
            setSelected(newSelected);
        }
        function handleAllCheckboxClick(e) {
            e.stopPropagation();
            const el = e.target;
            const checked = el.checked;
            const newSelected = {};
            const resources = responseRef.current?.data?.ResourceList;
            if (checked && resources) {
                resources.forEach((resource) => {
                    if (resource?.id) {
                        newSelected[resource.id] = true;
                    }
                });
            }
            setSelected(newSelected);
        }
        function isAllSelected() {
            const resources = responseRef.current?.data?.ResourceList;
            if (!resources || resources.length === 0) {
                return false;
            }
            for (const resource of resources) {
                if (resource?.id && !selectedRef.current[resource.id]) {
                    return false;
                }
            }
            return true;
        }
        function handleRowClick(e, resource) {
            if (isCheckboxCell(e.target)) {
                // Ignore clicks on checkboxes
                return;
            }
            killEvent(e);
            if (e.button !== 1 && props.onClick) {
                props.onClick(new SearchClickEvent(resource, e));
            }
            if (e.button === 1 && props.onAuxClick) {
                props.onAuxClick(new SearchClickEvent(resource, e));
            }
        }
        React.useEffect(() => {
            medplum
                .requestSchema(props.resourceType)
                .then((newSchema) => {
                // The schema could have the same object identity,
                // so need to use the spread operator to kick React re-render.
                setSchema({ ...newSchema });
            })
                .catch(console.log);
        }, [medplum, props.resourceType]);
        const typeSchema = schema?.types?.[props.resourceType];
        if (!typeSchema) {
            return React.createElement(core$1.Loader, null);
        }
        const checkboxColumn = props.checkboxesEnabled;
        return (React.createElement("div", { onContextMenu: (e) => killEvent(e), "data-testid": "search-control" },
            React.createElement(core$1.Table, null,
                React.createElement("thead", null,
                    React.createElement("tr", null,
                        checkboxColumn && (React.createElement("th", null,
                            React.createElement("input", { type: "checkbox", value: "checked", "aria-label": "all-checkbox", "data-testid": "all-checkbox", checked: isAllSelected(), onChange: (e) => handleAllCheckboxClick(e) }))),
                        fields.map((field) => (React.createElement("th", { key: field.name }, field.name))))),
                React.createElement("tbody", null, response?.data?.ResourceList?.map((resource) => resource && (React.createElement("tr", { key: resource.id, "data-testid": "search-control-row", onClick: (e) => handleRowClick(e, resource), onAuxClick: (e) => handleRowClick(e, resource) },
                    checkboxColumn && (React.createElement("td", null,
                        React.createElement("input", { type: "checkbox", value: "checked", "data-testid": "row-checkbox", "aria-label": `Checkbox for ${resource.id}`, checked: !!selected[resource.id], onChange: (e) => handleSingleCheckboxClick(e, resource.id) }))),
                    fields.map((field) => {
                        return (React.createElement("td", { key: field.name },
                            React.createElement(FhirPathDisplay, { propertyType: field.propertyType, path: field.fhirPath, resource: resource })));
                    })))))),
            response?.data?.ResourceList?.length === 0 && React.createElement("div", { "data-testid": "empty-search" }, "No results"),
            outcome && (React.createElement("div", { "data-testid": "search-error" },
                React.createElement("pre", { style: { textAlign: 'left' } }, JSON.stringify(outcome, undefined, 2)))),
            props.onBulk && (React.createElement(core$1.Button, { onClick: () => props.onBulk(Object.keys(selectedRef.current)) }, "Bulk..."))));
    }
    const MemoizedFhirPathTable = React.memo(FhirPathTable);

    const searches = [
        '$/_history',
        'Communication?subject=$',
        'Device?patient=$',
        'DeviceRequest?patient=$',
        'DiagnosticReport?subject=$',
        'Media?subject=$',
        'ServiceRequest?subject=$',
    ];
    function PatientTimeline(props) {
        return (React.createElement(ResourceTimeline, { value: props.patient, buildSearchRequests: (resource) => ({
                resourceType: 'Bundle',
                type: 'batch',
                entry: searches.map((search) => ({
                    request: {
                        method: 'GET',
                        url: search.replaceAll('$', core.getReferenceString(resource)),
                    },
                })),
            }), createCommunication: (resource, sender, text) => ({
                resourceType: 'Communication',
                status: 'completed',
                subject: core.createReference(resource),
                sender: core.createReference(sender),
                sent: new Date().toISOString(),
                payload: [{ contentString: text }],
            }), createMedia: (resource, operator, content) => ({
                resourceType: 'Media',
                status: 'completed',
                subject: core.createReference(resource),
                operator: core.createReference(operator),
                issued: new Date().toISOString(),
                content,
            }) }));
    }

    const useStyles$5 = core$1.createStyles((theme) => ({
        section: {
            position: 'relative',
            margin: '4px 4px 8px 0',
            padding: '6px 12px 16px 6px',
            border: `1.5px solid ${theme.colors.gray[1]}`,
            borderRadius: theme.radius.sm,
            transition: 'all 0.1s',
        },
        hovering: {
            border: `1.5px solid ${theme.colors.blue[5]}`,
        },
        editing: {
            border: `1.5px solid ${theme.colors.gray[1]}`,
            borderLeft: `4px solid ${theme.colors.blue[5]}`,
        },
        bottomActions: {
            position: 'absolute',
            right: 4,
            bottom: 0,
            fontSize: theme.fontSizes.xs,
            '& a': {
                marginLeft: 8,
            },
        },
    }));
    function PlanDefinitionBuilder(props) {
        const medplum = useMedplum();
        const defaultValue = useResource(props.value);
        const [schema, setSchema] = React.useState(undefined);
        const [selectedKey, setSelectedKey] = React.useState();
        const [hoverKey, setHoverKey] = React.useState();
        const [value, setValue] = React.useState();
        function handleDocumentMouseOver() {
            setHoverKey(undefined);
        }
        function handleDocumentClick() {
            setSelectedKey(undefined);
        }
        const valueRef = React.useRef();
        valueRef.current = value;
        React.useEffect(() => {
            medplum.requestSchema('PlanDefinition').then(setSchema).catch(console.log);
        }, [medplum]);
        React.useEffect(() => {
            setValue(ensurePlanDefinitionKeys(defaultValue ?? { resourceType: 'PlanDefinition' }));
            document.addEventListener('mouseover', handleDocumentMouseOver);
            document.addEventListener('click', handleDocumentClick);
            return () => {
                document.removeEventListener('mouseover', handleDocumentMouseOver);
                document.removeEventListener('click', handleDocumentClick);
            };
        }, [defaultValue]);
        if (!schema || !value) {
            return null;
        }
        function changeProperty(property, newValue) {
            setValue({
                ...valueRef.current,
                [property]: newValue,
            });
        }
        return (React.createElement("div", null,
            React.createElement(Form, { testid: "questionnaire-form", onSubmit: () => props.onSubmit(value) },
                React.createElement(core$1.TextInput, { label: "Plan Title", defaultValue: value.title, onChange: (e) => changeProperty('title', e.currentTarget.value) }),
                React.createElement(ActionArrayBuilder, { actions: value.action || [], selectedKey: selectedKey, setSelectedKey: setSelectedKey, hoverKey: hoverKey, setHoverKey: setHoverKey, onChange: (x) => changeProperty('action', x) }),
                React.createElement(core$1.Button, { type: "submit" }, "Save"))));
    }
    function ActionArrayBuilder(props) {
        const { classes } = useStyles$5();
        const actionsRef = React.useRef();
        actionsRef.current = props.actions;
        function changeAction(changedAction) {
            props.onChange(actionsRef.current.map((i) => (i.id === changedAction.id ? changedAction : i)));
        }
        function addAction(addedAction) {
            props.onChange([...actionsRef.current, addedAction]);
            props.setSelectedKey(addedAction.id);
        }
        function removeAction(removedAction) {
            props.onChange(actionsRef.current.filter((i) => i !== removedAction));
        }
        return (React.createElement("div", { className: classes.section },
            props.actions.map((action) => (React.createElement("div", { key: action.id },
                React.createElement(ActionBuilder, { action: action, selectedKey: props.selectedKey, setSelectedKey: props.setSelectedKey, hoverKey: props.hoverKey, setHoverKey: props.setHoverKey, onChange: changeAction, onRemove: () => removeAction(action) })))),
            React.createElement("div", { className: classes.bottomActions },
                React.createElement(core$1.Anchor, { href: "#", onClick: (e) => {
                        killEvent(e);
                        addAction({ id: generateId$1() });
                    } }, "Add action"))));
    }
    function ActionBuilder(props) {
        const { classes, cx } = useStyles$5();
        const { action } = props;
        const actionType = getInitialActionType(action);
        const editing = props.selectedKey === props.action.id;
        const hovering = props.hoverKey === props.action.id;
        function onClick(e) {
            e.stopPropagation();
            props.setSelectedKey(props.action.id);
        }
        function onHover(e) {
            killEvent(e);
            props.setHoverKey(props.action.id);
        }
        const className = cx(classes.section, {
            [classes.editing]: editing,
            [classes.hovering]: hovering && !editing,
        });
        return (React.createElement("div", { "data-testid": action.id, className: className, onClick: onClick, onMouseOver: onHover },
            editing ? (React.createElement(ActionEditor, { action: action, actionType: actionType, onChange: props.onChange, selectedKey: props.selectedKey, setSelectedKey: props.setSelectedKey, hoverKey: props.hoverKey, setHoverKey: props.setHoverKey, onRemove: props.onRemove })) : (React.createElement(ActionDisplay, { action: action, actionType: actionType })),
            React.createElement("div", { className: classes.bottomActions },
                React.createElement(core$1.Anchor, { href: "#", onClick: (e) => {
                        e.preventDefault();
                        props.onRemove();
                    } }, "Remove"))));
    }
    const timingProperty = {
        path: 'PlanDefinition.action.timing[x]',
        min: 0,
        max: '1',
        type: [{ code: 'dateTime' }, { code: 'Period' }, { code: 'Range' }, { code: 'Timing' }],
    };
    function ActionDisplay(props) {
        const { action, actionType } = props;
        const [propertyValue, propertyType] = getActionTiming(action);
        return (React.createElement("div", null,
            React.createElement("div", null,
                action.title || 'Untitled',
                " ",
                actionType && `(${actionType})`),
            action.definitionCanonical && (React.createElement("div", null,
                React.createElement(ReferenceDisplay, { value: { reference: action.definitionCanonical } }))),
            propertyValue && (React.createElement("div", null,
                React.createElement(ResourcePropertyDisplay, { property: timingProperty, propertyType: propertyType, value: propertyValue })))));
    }
    function ActionEditor(props) {
        const { action } = props;
        const [actionType, setActionType] = React.useState(props.actionType);
        function changeProperty(property, value) {
            props.onChange({
                ...action,
                [property]: value,
            });
        }
        return (React.createElement(core$1.Stack, { spacing: "xl" },
            React.createElement(core$1.TextInput, { name: `actionTitle-${action.id}`, label: "Title", defaultValue: action.title, onChange: (e) => changeProperty('title', e.currentTarget.value) }),
            React.createElement(core$1.TextInput, { name: `actionDescription-${action.id}`, label: "Description", defaultValue: action.description, onChange: (e) => changeProperty('description', e.currentTarget.value) }),
            React.createElement(core$1.NativeSelect, { label: "Type of Action", description: "The type of the action to be performed.", name: `actionType-${action.id}`, defaultValue: actionType, onChange: (e) => setActionType(e.currentTarget.value), data: ['', 'appointment', 'lab', 'questionnaire', 'task'] }),
            action.action && action.action.length > 0 && (React.createElement(ActionArrayBuilder, { actions: action.action, selectedKey: props.selectedKey, setSelectedKey: props.setSelectedKey, hoverKey: props.hoverKey, setHoverKey: props.setHoverKey, onChange: (x) => changeProperty('action', x) })),
            (() => {
                switch (actionType) {
                    case 'appointment':
                        return (React.createElement(ActionResourceTypeBuilder, { title: "Appointment", description: "The subject must schedule an appointment from the schedule.", resourceType: "Schedule", action: action, onChange: props.onChange }));
                    case 'lab':
                        return (React.createElement(ActionResourceTypeBuilder, { title: "Lab", description: "The subject must complete the following lab panel.", resourceType: "ActivityDefinition", action: action, onChange: props.onChange }));
                    case 'questionnaire':
                        return (React.createElement(ActionResourceTypeBuilder, { title: "Questionnaire", description: "The subject must complete the selected questionnaire.", resourceType: "Questionnaire", action: action, onChange: props.onChange }));
                    case 'task':
                        return (React.createElement(ActionResourceTypeBuilder, { title: "Task", description: "The subject must complete the following task.", resourceType: "ActivityDefinition", action: action, onChange: props.onChange }));
                    default:
                        return null;
                }
            })(),
            React.createElement(FormSection, { title: "Timing", description: "When the action should take place." },
                React.createElement(ActionTimingInput, { name: 'timing-' + action.id, action: action, onChange: props.onChange }))));
    }
    function ActionResourceTypeBuilder(props) {
        const { id, definitionCanonical } = props.action;
        const reference = definitionCanonical?.startsWith(props.resourceType + '/')
            ? { reference: definitionCanonical }
            : undefined;
        return (React.createElement(ResourceInput, { name: id, resourceType: props.resourceType, defaultValue: reference, loadOnFocus: true, onChange: (newValue) => {
                if (newValue) {
                    props.onChange({ ...props.action, definitionCanonical: core.getReferenceString(newValue) });
                }
                else {
                    props.onChange({ ...props.action, definitionCanonical: undefined });
                }
            } }));
    }
    function ActionTimingInput(props) {
        const value = props.action;
        const key = 'timing';
        const [propertyValue, propertyType] = getActionTiming(value);
        return (React.createElement(ResourcePropertyInput, { property: timingProperty, name: "timing[x]", defaultValue: propertyValue, defaultPropertyType: propertyType, onChange: (newValue, propName) => {
                props.onChange(setPropertyValue(value, key, propName ?? key, timingProperty, newValue));
            } }));
    }
    function getInitialActionType(action) {
        if (action.definitionCanonical?.startsWith('Schedule')) {
            return 'appointment';
        }
        if (action.definitionCanonical?.startsWith('Questionnaire/')) {
            return 'questionnaire';
        }
        if (action.definitionCanonical?.startsWith('ActivityDefinition/')) {
            return 'task';
        }
        return undefined;
    }
    function getActionTiming(action) {
        return getValueAndType({ type: 'PlanDefinitionAction', value: action }, 'timing');
    }
    let nextId$1 = 1;
    /**
     * Generates a unique ID.
     * React needs unique IDs for components for rendering performance.
     * All of the important components in the questionnaire builder have id properties for this:
     * Questionnaire, QuestionnaireItem, and QuestionnaireItemAnswerOption.
     * @return A unique key.
     */
    function generateId$1(existing) {
        if (existing) {
            if (existing.startsWith('id-')) {
                const existingNum = parseInt(existing.substring(3));
                if (!isNaN(existingNum)) {
                    nextId$1 = Math.max(nextId$1, existingNum + 1);
                }
            }
            return existing;
        }
        return 'id-' + nextId$1++;
    }
    function ensurePlanDefinitionKeys(planDefinition) {
        return {
            ...planDefinition,
            action: ensurePlanDefinitionActionKeys(planDefinition.action),
        };
    }
    function ensurePlanDefinitionActionKeys(actions) {
        if (!actions) {
            return undefined;
        }
        return actions.map((action) => ({
            ...action,
            id: generateId$1(action.id),
            action: ensurePlanDefinitionActionKeys(action.action),
        }));
    }

    exports.QuestionnaireItemType = void 0;
    (function (QuestionnaireItemType) {
        QuestionnaireItemType["group"] = "group";
        QuestionnaireItemType["display"] = "display";
        QuestionnaireItemType["question"] = "question";
        QuestionnaireItemType["boolean"] = "boolean";
        QuestionnaireItemType["decimal"] = "decimal";
        QuestionnaireItemType["integer"] = "integer";
        QuestionnaireItemType["date"] = "date";
        QuestionnaireItemType["dateTime"] = "dateTime";
        QuestionnaireItemType["time"] = "time";
        QuestionnaireItemType["string"] = "string";
        QuestionnaireItemType["text"] = "text";
        QuestionnaireItemType["url"] = "url";
        QuestionnaireItemType["choice"] = "choice";
        QuestionnaireItemType["openChoice"] = "open-choice";
        QuestionnaireItemType["attachment"] = "attachment";
        QuestionnaireItemType["reference"] = "reference";
        QuestionnaireItemType["quantity"] = "quantity";
    })(exports.QuestionnaireItemType || (exports.QuestionnaireItemType = {}));
    function isChoiceQuestion(item) {
        return item.type === 'choice' || item.type === 'open-choice';
    }

    function QuestionnaireForm(props) {
        const medplum = useMedplum();
        const source = medplum.getProfile();
        const [schema, setSchema] = React.useState();
        const questionnaire = useResource(props.questionnaire);
        const [response, setResponse] = React.useState();
        const [answers, setAnswers] = React.useState({});
        React.useEffect(() => {
            medplum
                .requestSchema('Questionnaire')
                .then(() => medplum.requestSchema('QuestionnaireResponse'))
                .then(setSchema)
                .catch(console.log);
        }, [medplum]);
        React.useEffect(() => {
            setResponse(questionnaire ? buildInitialResponse(questionnaire) : undefined);
        }, [questionnaire]);
        function setItems(newResponseItems) {
            const newResponse = {
                resourceType: 'QuestionnaireResponse',
                status: 'completed',
                item: newResponseItems,
            };
            setResponse(newResponse);
            setAnswers(core.getQuestionnaireAnswers(newResponse));
        }
        if (!schema || !questionnaire) {
            return null;
        }
        return (React.createElement(Form, { testid: "questionnaire-form", onSubmit: () => {
                if (props.onSubmit && response) {
                    props.onSubmit({
                        ...response,
                        questionnaire: core.getReferenceString(questionnaire),
                        subject: props.subject,
                        source: core.createReference(source),
                        authored: new Date().toISOString(),
                    });
                }
            } },
            questionnaire.title && React.createElement(core$1.Title, null, questionnaire.title),
            questionnaire.item && (React.createElement(QuestionnaireFormItemArray, { items: questionnaire.item, answers: answers, onChange: setItems })),
            React.createElement(core$1.Group, { position: "right", mt: "xl" },
                React.createElement(core$1.Button, { type: "submit" }, props.submitButtonText || 'OK'))));
    }
    function QuestionnaireFormItemArray(props) {
        const [responseItems, setResponseItems] = React.useState(buildInitialResponseItems(props.items));
        function setResponseItem(index, newResponseItem) {
            const newResponseItems = responseItems.slice();
            newResponseItems[index] = newResponseItem;
            setResponseItems(newResponseItems);
            props.onChange(newResponseItems);
        }
        return (React.createElement(core$1.Stack, null, props.items.map((item, index) => {
            if (!isQuestionEnabled(item, props.answers)) {
                return null;
            }
            if (item.type === exports.QuestionnaireItemType.display) {
                return React.createElement("p", { key: item.linkId }, item.text);
            }
            if (item.type === exports.QuestionnaireItemType.group) {
                return (React.createElement(QuestionnaireFormItem, { key: item.linkId, item: item, answers: props.answers, onChange: (newResponseItem) => setResponseItem(index, newResponseItem) }));
            }
            if (item.type === exports.QuestionnaireItemType.boolean) {
                const initial = item.initial && item.initial.length > 0 ? item.initial[0] : undefined;
                return (React.createElement(CheckboxFormSection, { key: item.linkId, title: item.text, htmlFor: item.linkId },
                    React.createElement(core$1.Checkbox, { id: item.linkId, name: item.linkId, defaultChecked: initial?.valueBoolean, onChange: (e) => setResponseItem(index, {
                            linkId: item.linkId,
                            text: item.text,
                            answer: [{ valueBoolean: e.currentTarget.checked }],
                        }) })));
            }
            return (React.createElement(FormSection, { key: item.linkId, htmlFor: item.linkId, title: item.text || '' },
                React.createElement(QuestionnaireFormItem, { item: item, answers: props.answers, onChange: (newResponseItem) => setResponseItem(index, newResponseItem) })));
        })));
    }
    function QuestionnaireFormItem(props) {
        const item = props.item;
        const type = item.type;
        if (!type) {
            return null;
        }
        const name = item.linkId;
        if (!name) {
            return null;
        }
        const initial = item.initial && item.initial.length > 0 ? item.initial[0] : undefined;
        function onChangeItem(newResponseItems) {
            props.onChange({
                linkId: item.linkId,
                text: item.text,
                item: newResponseItems,
            });
        }
        function onChangeAnswer(newResponseAnswer) {
            props.onChange({
                linkId: item.linkId,
                text: item.text,
                answer: [newResponseAnswer],
            });
        }
        switch (type) {
            case exports.QuestionnaireItemType.group:
                return (React.createElement("div", null,
                    React.createElement("h3", null, item.text),
                    item.item && (React.createElement(QuestionnaireFormItemArray, { items: item.item, answers: props.answers, onChange: onChangeItem }))));
            case exports.QuestionnaireItemType.boolean:
                return (React.createElement(core$1.Checkbox, { id: name, name: name, defaultChecked: initial?.valueBoolean, onChange: (e) => onChangeAnswer({ valueBoolean: e.currentTarget.checked }) }));
            case exports.QuestionnaireItemType.decimal:
                return (React.createElement(core$1.TextInput, { type: "number", step: "any", id: name, name: name, defaultValue: initial?.valueDecimal, onChange: (e) => onChangeAnswer({ valueDecimal: e.currentTarget.valueAsNumber }) }));
            case exports.QuestionnaireItemType.integer:
                return (React.createElement(core$1.TextInput, { type: "number", step: 1, id: name, name: name, defaultValue: initial?.valueInteger, onChange: (e) => onChangeAnswer({ valueInteger: e.currentTarget.valueAsNumber }) }));
            case exports.QuestionnaireItemType.date:
                return (React.createElement(core$1.TextInput, { type: "date", id: name, name: name, defaultValue: initial?.valueDate, onChange: (e) => onChangeAnswer({ valueDate: e.currentTarget.value }) }));
            case exports.QuestionnaireItemType.dateTime:
                return (React.createElement(DateTimeInput, { name: name, defaultValue: initial?.valueDateTime, onChange: (newValue) => onChangeAnswer({ valueDateTime: newValue }) }));
            case exports.QuestionnaireItemType.time:
                return (React.createElement(core$1.TextInput, { type: "time", id: name, name: name, defaultValue: initial?.valueTime, onChange: (e) => onChangeAnswer({ valueTime: e.currentTarget.value }) }));
            case exports.QuestionnaireItemType.string:
            case exports.QuestionnaireItemType.url:
                return (React.createElement(core$1.TextInput, { id: name, name: name, defaultValue: initial?.valueString, onChange: (e) => onChangeAnswer({ valueString: e.currentTarget.value }) }));
            case exports.QuestionnaireItemType.text:
                return (React.createElement(core$1.Textarea, { id: name, name: name, defaultValue: initial?.valueString, onChange: (e) => onChangeAnswer({ valueString: e.currentTarget.value }) }));
            case exports.QuestionnaireItemType.attachment:
                return (React.createElement(AttachmentInput, { name: name, defaultValue: initial?.valueAttachment, onChange: (newValue) => onChangeAnswer({ valueAttachment: newValue }) }));
            case exports.QuestionnaireItemType.reference:
                return (React.createElement(ReferenceInput, { name: name, defaultValue: initial?.valueReference, onChange: (newValue) => onChangeAnswer({ valueReference: newValue }) }));
            case exports.QuestionnaireItemType.quantity:
                return (React.createElement(QuantityInput, { name: name, defaultValue: initial?.valueQuantity, onChange: (newValue) => onChangeAnswer({ valueQuantity: newValue }) }));
            case exports.QuestionnaireItemType.choice:
            case exports.QuestionnaireItemType.openChoice:
                if (isDropDownChoice(item)) {
                    return (React.createElement(QuestionnaireChoiceDropDownInput, { name: name, item: item, initial: initial, onChangeAnswer: onChangeAnswer }));
                }
                else {
                    return (React.createElement(QuestionnaireChoiceRadioInput, { name: name, item: item, initial: initial, onChangeAnswer: onChangeAnswer }));
                }
        }
        return null;
    }
    function QuestionnaireChoiceDropDownInput(props) {
        const { name, item, initial } = props;
        const initialValue = core.getTypedPropertyValue({ type: 'QuestionnaireItemInitial', value: initial }, 'value');
        const data = [''];
        if (item.answerOption) {
            for (const option of item.answerOption) {
                const optionValue = core.getTypedPropertyValue({ type: 'QuestionnaireItemAnswerOption', value: option }, 'value');
                data.push(typedValueToString(optionValue));
            }
        }
        return (React.createElement(core$1.NativeSelect, { id: name, name: name, onChange: (e) => {
                const index = e.currentTarget.selectedIndex;
                if (index === 0) {
                    props.onChangeAnswer({});
                    return;
                }
                const option = item.answerOption[index - 1];
                const optionValue = core.getTypedPropertyValue({ type: 'QuestionnaireItemAnswerOption', value: option }, 'value');
                const propertyName = 'value' + core.capitalize(optionValue.type);
                props.onChangeAnswer({ [propertyName]: optionValue.value });
            }, defaultValue: typedValueToString(initialValue), data: data }));
    }
    function typedValueToString(typedValue) {
        if (!typedValue) {
            return undefined;
        }
        if (typedValue.type === 'CodeableConcept') {
            return typedValue.value.coding[0].display;
        }
        if (typedValue.type === 'Coding') {
            return typedValue.value.display;
        }
        return typedValue.value.toString();
    }
    function QuestionnaireChoiceRadioInput(props) {
        const { name, item, initial, onChangeAnswer } = props;
        const valueElementDefinition = core.globalSchema.types['QuestionnaireItemAnswerOption'].properties['value[x]'];
        const initialValue = core.getTypedPropertyValue({ type: 'QuestionnaireItemInitial', value: initial }, 'value');
        const options = [];
        let defaultValue = undefined;
        if (item.answerOption) {
            for (let i = 0; i < item.answerOption.length; i++) {
                const option = item.answerOption[i];
                const optionName = `${name}-option-${i}`;
                const optionValue = core.getTypedPropertyValue({ type: 'QuestionnaireItemAnswerOption', value: option }, 'value');
                if (initialValue && core.stringify(optionValue) === core.stringify(initialValue)) {
                    defaultValue = optionName;
                }
                options.push([optionName, optionValue]);
            }
        }
        return (React.createElement(core$1.Radio.Group, { name: name, orientation: "vertical", defaultValue: defaultValue, onChange: (newValue) => {
                const option = options.find((option) => option[0] === newValue);
                if (option) {
                    const optionValue = option[1];
                    const propertyName = 'value' + core.capitalize(optionValue.type);
                    onChangeAnswer({ [propertyName]: optionValue.value });
                }
            } }, options.map(([optionName, optionValue]) => (React.createElement(core$1.Radio, { key: optionName, id: optionName, value: optionName, label: React.createElement(ResourcePropertyDisplay, { property: valueElementDefinition, propertyType: optionValue.type, value: optionValue.value }) })))));
    }
    function buildInitialResponse(questionnaire) {
        const response = {
            resourceType: 'QuestionnaireResponse',
            questionnaire: core.getReferenceString(questionnaire),
            item: buildInitialResponseItems(questionnaire.item),
        };
        return response;
    }
    function buildInitialResponseItems(items) {
        return items?.map(buildInitialResponseItem) ?? [];
    }
    function buildInitialResponseItem(item) {
        return {
            linkId: item.linkId,
            text: item.text,
            item: buildInitialResponseItems(item.item),
            answer: item.initial?.map(buildInitialResponseAnswer) ?? [],
        };
    }
    function buildInitialResponseAnswer(answer) {
        // This works because QuestionnaireItemInitial and QuestionnaireResponseItemAnswer
        // have the same properties.
        return { ...answer };
    }
    function isDropDownChoice(item) {
        return !!item.extension?.some((e) => e.url === 'http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl' &&
            e.valueCodeableConcept?.coding?.[0]?.code === 'drop-down');
    }
    function isQuestionEnabled(item, answers) {
        if (!item.enableWhen) {
            return true;
        }
        const enableBehavior = item.enableBehavior || 'any';
        for (const enableWhen of item.enableWhen) {
            const expectedAnswer = core.getTypedPropertyValue({
                type: 'QuestionnaireItemEnableWhen',
                value: enableWhen,
            }, 'answer[x]');
            const actualAnswer = core.getTypedPropertyValue({
                type: 'QuestionnaireResponseItemAnswer',
                value: answers[enableWhen.question],
            }, 'value[x]');
            const match = core.deepEquals(expectedAnswer, actualAnswer);
            if (enableBehavior === 'any' && match) {
                return true;
            }
            if (enableBehavior === 'all' && !match) {
                return false;
            }
        }
        if (enableBehavior === 'any') {
            return false;
        }
        else {
            return true;
        }
    }

    const useStyles$4 = core$1.createStyles((theme) => ({
        section: {
            position: 'relative',
            margin: '4px 4px 8px 0',
            padding: '6px 12px 16px 6px',
            border: `1.5px solid ${theme.colors.gray[1]}`,
            borderRadius: theme.radius.sm,
            transition: 'all 0.1s',
        },
        hovering: {
            border: `1.5px solid ${theme.colors.blue[5]}`,
        },
        editing: {
            border: `1.5px solid ${theme.colors.gray[1]}`,
            borderLeft: `4px solid ${theme.colors.blue[5]}`,
        },
        questionBody: {
            maxWidth: 600,
        },
        topActions: {
            position: 'absolute',
            right: 4,
            top: 1,
            padding: 4,
            color: theme.colors.gray[5],
            fontSize: theme.fontSizes.xs,
        },
        bottomActions: {
            position: 'absolute',
            right: 4,
            bottom: 0,
            fontSize: theme.fontSizes.xs,
            '& a': {
                marginLeft: 8,
            },
        },
        linkIdInput: {
            width: 100,
            marginBottom: 4,
        },
        typeSelect: {
            width: 100,
        },
    }));
    function QuestionnaireBuilder(props) {
        const medplum = useMedplum();
        const defaultValue = useResource(props.questionnaire);
        const [schema, setSchema] = React.useState();
        const [value, setValue] = React.useState();
        const [selectedKey, setSelectedKey] = React.useState();
        const [hoverKey, setHoverKey] = React.useState();
        function handleDocumentMouseOver() {
            setHoverKey(undefined);
        }
        function handleDocumentClick() {
            setSelectedKey(undefined);
        }
        React.useEffect(() => {
            medplum.requestSchema('Questionnaire').then(setSchema).catch(console.log);
        }, [medplum]);
        React.useEffect(() => {
            setValue(ensureQuestionnaireKeys(defaultValue ?? { resourceType: 'Questionnaire' }));
            document.addEventListener('mouseover', handleDocumentMouseOver);
            document.addEventListener('click', handleDocumentClick);
            return () => {
                document.removeEventListener('mouseover', handleDocumentMouseOver);
                document.removeEventListener('click', handleDocumentClick);
            };
        }, [defaultValue]);
        if (!schema || !value) {
            return null;
        }
        return (React.createElement("div", null,
            React.createElement(Form, { testid: "questionnaire-form", onSubmit: () => props.onSubmit(value) },
                React.createElement(ItemBuilder, { item: value, selectedKey: selectedKey, setSelectedKey: setSelectedKey, hoverKey: hoverKey, setHoverKey: setHoverKey, onChange: setValue }),
                React.createElement(core$1.Button, { type: "submit" }, "Save"))));
    }
    function ItemBuilder(props) {
        const { classes, cx } = useStyles$4();
        const resource = props.item;
        const item = props.item;
        const isResource = 'resourceType' in props.item;
        const isContainer = isResource || item.type === exports.QuestionnaireItemType.group;
        const linkId = item.linkId ?? '[untitled]';
        const editing = props.selectedKey === props.item.id;
        const hovering = props.hoverKey === props.item.id;
        const itemRef = React.useRef();
        itemRef.current = props.item;
        function onClick(e) {
            killEvent(e);
            props.setSelectedKey(props.item.id);
        }
        function onHover(e) {
            killEvent(e);
            props.setHoverKey(props.item.id);
        }
        function changeItem(changedItem) {
            const curr = itemRef.current;
            props.onChange({
                ...curr,
                item: curr.item?.map((i) => (i.id === changedItem.id ? changedItem : i)),
            });
        }
        function addItem(addedItem) {
            props.onChange({
                ...props.item,
                item: [...(props.item?.item ?? []), addedItem],
            });
        }
        function removeItem(removedItem) {
            props.onChange({
                ...props.item,
                item: props.item?.item?.filter((i) => i !== removedItem),
            });
        }
        function changeProperty(property, value) {
            props.onChange({
                ...itemRef.current,
                [property]: value,
            });
        }
        const className = cx(classes.section, {
            [classes.editing]: editing,
            [classes.hovering]: hovering && !editing,
        });
        return (React.createElement("div", { "data-testid": item.linkId, className: className, onClick: onClick, onMouseOver: onHover },
            React.createElement("div", { className: classes.questionBody }, editing ? (React.createElement(React.Fragment, null,
                isResource && (React.createElement(core$1.TextInput, { size: "xl", defaultValue: resource.title, onChange: (e) => changeProperty('title', e.currentTarget.value) })),
                !isResource && (React.createElement(core$1.Textarea, { autosize: true, minRows: 2, defaultValue: item.text, onChange: (e) => changeProperty('text', e.currentTarget.value) })),
                isChoiceQuestion(item) && (React.createElement(AnswerBuilder, { options: item.answerOption, onChange: (newOptions) => changeProperty('answerOption', newOptions) })))) : (React.createElement(React.Fragment, null,
                resource.title && React.createElement(core$1.Title, null, resource.title),
                item.text && React.createElement("div", null, item.text),
                !isContainer && React.createElement(QuestionnaireFormItem, { item: item, answers: {}, onChange: () => undefined })))),
            item.item &&
                item.item.map((i) => (React.createElement("div", { key: i.id },
                    React.createElement(ItemBuilder, { item: i, selectedKey: props.selectedKey, setSelectedKey: props.setSelectedKey, hoverKey: props.hoverKey, setHoverKey: props.setHoverKey, onChange: changeItem, onRemove: () => removeItem(i) })))),
            !isContainer && (React.createElement("div", { className: classes.topActions }, editing ? (React.createElement(React.Fragment, null,
                React.createElement(core$1.TextInput, { size: "xs", className: classes.linkIdInput, defaultValue: item.linkId, onChange: (e) => changeProperty('linkId', e.currentTarget.value) }),
                !isContainer && (React.createElement(core$1.NativeSelect, { size: "xs", className: classes.typeSelect, defaultValue: item.type, onChange: (e) => changeProperty('type', e.currentTarget.value), data: [
                        { value: 'display', label: 'Display' },
                        { value: 'boolean', label: 'Boolean' },
                        { value: 'decimal', label: 'Decimal' },
                        { value: 'integer', label: 'Integer' },
                        { value: 'date', label: 'Date' },
                        { value: 'dateTime', label: 'Date/Time' },
                        { value: 'time', label: 'Time' },
                        { value: 'string', label: 'String' },
                        { value: 'text', label: 'Text' },
                        { value: 'url', label: 'URL' },
                        { value: 'choice', label: 'Choice' },
                        { value: 'open-choice', label: 'Open Choice' },
                        { value: 'attachment', label: 'Attachment' },
                        { value: 'reference', label: 'Reference' },
                        { value: 'quantity', label: 'Quantity' },
                    ] })))) : (React.createElement("div", null, linkId)))),
            React.createElement("div", { className: classes.bottomActions },
                isContainer && (React.createElement(React.Fragment, null,
                    React.createElement(core$1.Anchor, { href: "#", onClick: (e) => {
                            e.preventDefault();
                            addItem({
                                id: generateId(),
                                linkId: generateLinkId('q'),
                                type: 'string',
                                text: 'Question',
                            });
                        } }, "Add item"),
                    React.createElement(core$1.Anchor, { href: "#", onClick: (e) => {
                            e.preventDefault();
                            addItem({
                                id: generateId(),
                                linkId: generateLinkId('g'),
                                type: 'group',
                                text: 'Group',
                            });
                        } }, "Add group"))),
                editing && !isResource && (React.createElement(core$1.Anchor, { href: "#", onClick: (e) => {
                        e.preventDefault();
                        if (props.onRemove) {
                            props.onRemove();
                        }
                    } }, "Remove")))));
    }
    function AnswerBuilder(props) {
        const property = core.globalSchema.types['QuestionnaireItemAnswerOption'].properties['value[x]'];
        const options = props.options ?? [];
        return (React.createElement("div", null,
            options.map((option) => {
                const [propertyValue, propertyType] = getValueAndType({ type: 'QuestionnaireItemAnswerOption', value: option }, 'value');
                return (React.createElement("div", { key: option.id, style: {
                        display: 'flex',
                        flexDirection: 'row',
                        justifyContent: 'space-between',
                        alignItems: 'center',
                        width: '80%',
                    } },
                    React.createElement("div", null,
                        React.createElement(ResourcePropertyInput, { key: option.id, name: "value[x]", property: property, defaultPropertyType: propertyType, defaultValue: propertyValue, onChange: (newValue, propName) => {
                                const newOptions = [...options];
                                const index = newOptions.findIndex((o) => o.id === option.id);
                                newOptions[index] = { id: option.id, [propName]: newValue };
                                props.onChange(newOptions);
                            } })),
                    React.createElement("div", null,
                        React.createElement(core$1.Anchor, { href: "#", onClick: (e) => {
                                killEvent(e);
                                props.onChange(options.filter((o) => o.id !== option.id));
                            } }, "Remove"))));
            }),
            React.createElement(core$1.Anchor, { href: "#", onClick: (e) => {
                    killEvent(e);
                    props.onChange([
                        ...options,
                        {
                            id: generateId(),
                        },
                    ]);
                } }, "Add choice")));
    }
    let nextLinkId = 1;
    let nextId = 1;
    /**
     * Generates a link ID for an item.
     * Link IDs are required properties on QuestionnaireItem objects.
     * @return A unique link ID.
     */
    function generateLinkId(prefix) {
        return prefix + nextLinkId++;
    }
    /**
     * Generates a unique ID.
     * React needs unique IDs for components for rendering performance.
     * All of the important components in the questionnaire builder have id properties for this:
     * Questionnaire, QuestionnaireItem, and QuestionnaireItemAnswerOption.
     * @return A unique key.
     */
    function generateId() {
        return 'id-' + nextId++;
    }
    function ensureQuestionnaireKeys(questionnaire) {
        return {
            ...questionnaire,
            id: questionnaire.id || generateId(),
            item: ensureQuestionnaireItemKeys(questionnaire.item),
        };
    }
    function ensureQuestionnaireItemKeys(items) {
        if (!items) {
            return undefined;
        }
        items.forEach((item) => {
            if (item.id?.match(/^id-\d+$/)) {
                nextId = Math.max(nextId, parseInt(item.id.substring(3)) + 1);
            }
            if (item.linkId?.match(/^q\d+$/)) {
                nextLinkId = Math.max(nextLinkId, parseInt(item.linkId.substring(1)) + 1);
            }
        });
        return items.map((item) => ({
            ...item,
            id: item.id || generateId(),
            item: ensureQuestionnaireItemKeys(item.item),
            answerOption: ensureQuestionnaireOptionKeys(item.answerOption),
        }));
    }
    function ensureQuestionnaireOptionKeys(options) {
        if (!options) {
            return undefined;
        }
        return options.map((option) => ({
            ...option,
            id: option.id || generateId(),
        }));
    }

    const useStyles$3 = core$1.createStyles((theme) => ({
        section: {
            position: 'relative',
            margin: '4px 4px 8px 0',
            padding: '6px 12px 16px 6px',
            border: `1.5px solid ${theme.colors.gray[3]}`,
            borderRadius: theme.radius.sm,
            transition: 'all 0.1s',
        },
    }));
    // Properties of qualified intervals used for grouping
    const intervalFilters = ['gender', 'age', 'gestationalAge', 'context', 'appliesTo'];
    const defaultProps = {
        definition: { resourceType: 'ObservationDefinition' },
        onSubmit: () => {
            return;
        },
    };
    function ReferenceRangeEditor(props) {
        props = Object.assign(defaultProps, props);
        const defaultDefinition = props.definition;
        const [intervalGroups, setIntervalGroups] = React.useState([]);
        const [groupId, setGroupId] = React.useState(1);
        const [intervalId, setIntervalId] = React.useState(1);
        React.useEffect(() => {
            const definition = ensureQualifiedIntervalKeys(defaultDefinition, setIntervalId);
            setIntervalGroups(groupQualifiedIntervals(definition.qualifiedInterval || [], setGroupId));
        }, [defaultDefinition]);
        return (React.createElement(Form, { testid: "reference-range-editor", onSubmit: submitDefinition },
            React.createElement(core$1.Stack, null, intervalGroups.map((intervalGroup) => (React.createElement(ReferenceRangeGroupEditor, { unit: getUnitString(defaultDefinition.quantitativeDetails?.unit), onChange: changeInterval, onAdd: addInterval, onRemove: removeInterval, onRemoveGroup: removeGroup, key: `group-${intervalGroup.id}`, intervalGroup: intervalGroup })))),
            React.createElement(core$1.ActionIcon, { title: "Add Group", size: "sm", onClick: (e) => {
                    killEvent(e);
                    addGroup({ id: `group-id-${groupId}`, filters: {}, intervals: [] });
                    setGroupId((id) => id + 1);
                } },
                React.createElement(icons.IconCirclePlus, null)),
            React.createElement(core$1.Group, { position: "right" },
                React.createElement(core$1.Button, { type: "submit" }, "Save"))));
        /**
         * Submit qualified intervals
         */
        function submitDefinition() {
            const qualifiedInterval = intervalGroups
                .flatMap((group) => group.intervals)
                .filter((interval) => !isEmptyInterval(interval));
            props.onSubmit({ ...defaultDefinition, qualifiedInterval });
        }
        /**
         * Add Remove Interval Groups
         */
        function addGroup(addedGroup) {
            setIntervalGroups((currentGroups) => [...currentGroups, addedGroup]);
        }
        function removeGroup(removedGroup) {
            setIntervalGroups((currentGroups) => currentGroups.filter((group) => group.id !== removedGroup.id));
        }
        /**
         * Add/Remove/Update specific Qualified Intervals
         */
        function changeInterval(groupId, changedInterval) {
            setIntervalGroups((groups) => {
                groups = [...groups];
                const currentGroup = groups.find((g) => g.id === groupId);
                const index = currentGroup?.intervals?.findIndex((interval) => interval.id === changedInterval.id);
                if (index !== undefined && currentGroup?.intervals?.[index]) {
                    currentGroup.intervals[index] = changedInterval;
                }
                return groups;
            });
        }
        function addInterval(groupId, addedInterval) {
            if (addedInterval.id === undefined) {
                addedInterval.id = `id-${intervalId}`;
                setIntervalId((id) => id + 1);
            }
            setIntervalGroups((groups) => {
                groups = [...groups];
                const currentGroupIndex = groups.findIndex((g) => g.id === groupId);
                if (currentGroupIndex != -1) {
                    const currentGroup = { ...groups[currentGroupIndex] };
                    addedInterval = { ...addedInterval, ...currentGroup.filters };
                    currentGroup.intervals = [...currentGroup.intervals, addedInterval];
                    groups[currentGroupIndex] = currentGroup;
                }
                return groups;
            });
        }
        function removeInterval(groupId, removedInterval) {
            setIntervalGroups((groups) => {
                groups = [...groups];
                const currentGroup = groups.find((g) => g.id === groupId);
                if (currentGroup) {
                    currentGroup.intervals = currentGroup.intervals.filter((interval) => interval.id !== removedInterval.id);
                }
                return groups;
            });
        }
    }
    function ReferenceRangeGroupEditor(props) {
        const { intervalGroup, unit } = props;
        const { classes } = useStyles$3();
        return (React.createElement(Container, { "data-testid": intervalGroup.id, className: classes.section },
            React.createElement(core$1.Stack, { spacing: 'lg' },
                React.createElement(core$1.Group, { position: "right" },
                    React.createElement(core$1.ActionIcon, { title: "Remove Group", "data-testid": `remove-group-button-${intervalGroup.id}`, key: `remove-group-button-${intervalGroup.id}`, size: "sm", onClick: (e) => {
                            killEvent(e);
                            props.onRemoveGroup(intervalGroup);
                        } },
                        React.createElement(icons.IconCircleMinus, null))),
                React.createElement(ReferenceRangeGroupFilters, { intervalGroup: intervalGroup, onChange: props.onChange }),
                React.createElement(core$1.Divider, null),
                intervalGroup.intervals.map((interval) => (React.createElement(core$1.Stack, { key: `interval-${interval.id}`, spacing: 'xs' },
                    React.createElement(core$1.Group, null,
                        React.createElement(core$1.TextInput, { key: `condition-${interval.id}`, "data-testid": `condition-${interval.id}`, defaultValue: interval.condition, label: 'Condition: ', size: 'sm', onChange: (e) => {
                                killEvent(e);
                                props.onChange(intervalGroup.id, { ...interval, condition: e.currentTarget.value.trim() });
                            } }),
                        React.createElement(core$1.ActionIcon, { title: "Remove Interval", size: "sm", key: `remove-interval-${interval.id}`, "data-testid": `remove-interval-${interval.id}`, onClick: (e) => {
                                killEvent(e);
                                props.onRemove(intervalGroup.id, interval);
                            } },
                            React.createElement(icons.IconCircleMinus, null))),
                    React.createElement(RangeInput, { onChange: (range) => {
                            props.onChange(intervalGroup.id, { ...interval, range });
                        }, key: `range-${interval.id}`, name: `range-${interval.id}`, defaultValue: interval.range })))),
                React.createElement(core$1.ActionIcon, { title: "Add Interval", size: "sm", onClick: (e) => {
                        killEvent(e);
                        props.onAdd(intervalGroup.id, {
                            range: {
                                low: { unit },
                                high: { unit },
                            },
                        });
                    } },
                    React.createElement(icons.IconCirclePlus, null)))));
    }
    /**
     * Render the "filters" section of the IntervalGroup. Also populates some initial
     */
    function ReferenceRangeGroupFilters(props) {
        const { intervalGroup, onChange } = props;
        // Pre-populate the units of the age filter
        if (!intervalGroup.filters.age) {
            intervalGroup.filters.age = {};
        }
        for (const key of ['low', 'high']) {
            if (!intervalGroup.filters.age[key]?.unit) {
                intervalGroup.filters.age[key] = {
                    ...intervalGroup.filters.age[key],
                    unit: 'years',
                    system: 'http://unitsofmeasure.org',
                };
            }
        }
        return (React.createElement(core$1.Stack, { style: { maxWidth: '50%' } },
            React.createElement(core$1.Group, null,
                React.createElement(core$1.NativeSelect, { data: ['', 'male', 'female'], label: "Gender:", defaultValue: intervalGroup.filters.gender || '', onChange: (e) => {
                        for (const interval of intervalGroup.intervals) {
                            let newGender = e.currentTarget?.value;
                            if (newGender === '') {
                                newGender = undefined;
                            }
                            onChange(intervalGroup.id, {
                                ...interval,
                                gender: newGender,
                            });
                        }
                    } })),
            React.createElement(core$1.Group, { spacing: 'xs' },
                React.createElement(core$1.Text, { component: "label", htmlFor: `div-age-${intervalGroup.id}` }, "Age:"),
                React.createElement("div", { id: `div-age-${intervalGroup.id}` },
                    React.createElement(RangeInput, { key: `age-${intervalGroup.id}`, name: `age-${intervalGroup.id}`, defaultValue: intervalGroup.filters['age'], onChange: (ageRange) => {
                            for (const interval of intervalGroup.intervals) {
                                onChange(intervalGroup.id, { ...interval, age: ageRange });
                            }
                        } }))),
            React.createElement(core$1.NativeSelect, { data: ['', 'pre-puberty', 'follicular', 'midcycle', 'luteal', 'postmenopausal'], label: "Endocrine:", defaultValue: intervalGroup.filters.context?.text || '', onChange: (e) => {
                    for (const interval of intervalGroup.intervals) {
                        let newEndocrine = e.currentTarget?.value;
                        if (newEndocrine === '') {
                            newEndocrine = undefined;
                            onChange(intervalGroup.id, { ...interval, context: undefined });
                        }
                        else {
                            onChange(intervalGroup.id, {
                                ...interval,
                                context: {
                                    text: newEndocrine,
                                    coding: [
                                        { code: newEndocrine, system: 'http://terminology.hl7.org/CodeSystem/referencerange-meaning' },
                                    ],
                                },
                            });
                        }
                    }
                } })));
    }
    /**
     * Helper function that assigns ids to each qualifiedInterval of an ObservationDefinition
     * @param definition An ObservationDefinition
     * @param setIntervalId React setState function for the intervalId
     * @returns
     */
    function ensureQualifiedIntervalKeys(definition, setIntervalId) {
        const intervals = definition.qualifiedInterval || [];
        // Set the nextId to the max of any existing numeric id
        let nextId = Math.max(...intervals.map((interval) => {
            const existingNum = parseInt(interval.id?.substring(3) || '');
            return !isNaN(existingNum) ? existingNum : Number.NEGATIVE_INFINITY;
        })) + 1;
        if (!Number.isFinite(nextId)) {
            nextId = 1;
        }
        // If an interval doesn't have an id, set it to the nextId
        definition = {
            ...definition,
            qualifiedInterval: intervals.map((interval) => ({
                ...interval,
                id: interval.id || `id-${nextId++}`,
            })),
        };
        setIntervalId(nextId);
        return definition;
    }
    /**
     * Group all ObservationDefinitionQualifiedIntervals based on the values of their "filter" properties,
     * so that similar ranges can be grouped together
     */
    function groupQualifiedIntervals(intervals, setGroupId) {
        let groupId = 1;
        const groups = {};
        for (const interval of intervals) {
            const groupKey = generateGroupKey(interval);
            if (!(groupKey in groups)) {
                groups[groupKey] = {
                    id: `group-id-${groupId++}`,
                    filters: Object.fromEntries(intervalFilters.map((f) => [f, interval[f]])),
                    intervals: [],
                };
            }
            groups[groupKey].intervals.push(interval);
        }
        setGroupId(groupId);
        return Object.values(groups);
    }
    /**
     * Generates a unique string for each set of filter values, so that similarly filtered intervals can be grouped together
     * @return A "group key" that corresponds to the value of the interval filter properties.
     */
    function generateGroupKey(interval) {
        const results = [
            `gender=${interval.gender}`,
            `age=${core.formatRange(interval.age)}`,
            `gestationalAge=${core.formatRange(interval.gestationalAge)}`,
            `context=${interval.context?.text}`,
            `appliesTo=${interval.appliesTo?.map((c) => c.text).join('+')}`,
        ];
        return results.join(':');
    }
    function getUnitString(unit) {
        return unit && (core.getCodeBySystem(unit, 'http://unitsofmeasure.org') || unit.text);
    }
    function isEmptyInterval(interval) {
        return interval.range?.low?.value === undefined && interval.range?.high?.value === undefined;
    }

    function RequestGroupDisplay(props) {
        const medplum = useMedplum();
        const requestGroup = useResource(props.value);
        const [startedLoading, setStartedLoading] = React.useState(false);
        const [responseBundle, setResponseBundle] = React.useState();
        React.useEffect(() => {
            if (requestGroup && !startedLoading) {
                medplum.executeBatch(buildBatchRequest(requestGroup)).then(setResponseBundle).catch(console.log);
                setStartedLoading(true);
            }
        }, [medplum, requestGroup, startedLoading]);
        if (!requestGroup || !responseBundle) {
            return null;
        }
        return (React.createElement(core$1.Grid, null, requestGroup.action?.map((action, index) => {
            const task = action.resource && findBundleEntry(action.resource);
            const taskInput = task?.input?.[0]?.valueReference;
            const taskOutput = task?.output?.[0]?.valueReference;
            return (React.createElement(React.Fragment, { key: `action-${index}` },
                React.createElement(core$1.Grid.Col, { span: 1, p: "md" }, task?.status === 'completed' ? React.createElement(icons.IconCheckbox, null) : React.createElement(icons.IconSquare, { color: "gray" })),
                React.createElement(core$1.Grid.Col, { span: 9, p: "xs" },
                    React.createElement(core$1.Text, { weight: 500 }, action.title),
                    action.description && React.createElement("div", null, action.description),
                    React.createElement("div", null,
                        "Last edited by\u00A0",
                        React.createElement(ResourceName, { value: task?.meta?.author }),
                        "\u00A0on\u00A0",
                        core.formatDateTime(task?.meta?.lastUpdated)),
                    React.createElement("div", null,
                        "Status: ",
                        React.createElement(StatusBadge, { status: task?.status || 'unknown' }))),
                React.createElement(core$1.Grid.Col, { span: 2, p: "md" },
                    taskInput && !taskOutput && React.createElement(core$1.Button, { onClick: () => props.onStart(task, taskInput) }, "Start"),
                    taskInput && taskOutput && (React.createElement(core$1.Button, { onClick: () => props.onEdit(task, taskInput, taskOutput) }, "Edit")))));
        })));
        function buildBatchRequest(request) {
            const batchEntries = [];
            if (request.action) {
                for (const action of request.action) {
                    if (action.resource?.reference) {
                        batchEntries.push({ request: { method: 'GET', url: action.resource.reference } });
                    }
                }
            }
            return {
                resourceType: 'Bundle',
                type: 'batch',
                entry: batchEntries,
            };
        }
        function findBundleEntry(reference) {
            for (const entry of responseBundle?.entry) {
                if (entry.resource && reference.reference === core.getReferenceString(entry.resource)) {
                    return entry.resource;
                }
            }
            return undefined;
        }
    }

    /*
     * Myers Diff algorithm
     * Based on: https://github.com/KengoTODA/java-diff-utils/blob/master/src/main/java/difflib/myers/MyersDiff.java
     * Apache Software License, Version 1.1
     */
    function diff(original, revised) {
        const path = buildPath(original, revised);
        return buildRevisions(path, original, revised);
    }
    function buildPath(orig, rev) {
        const N = orig.length;
        const M = rev.length;
        const MAX = N + M + 1;
        const size = 1 + 2 * MAX;
        const middle = (size / 2) | 0;
        const diagonal = new Array(size);
        diagonal[middle + 1] = {
            i: 0,
            j: -1,
            prev: undefined,
            snake: true,
        };
        for (let d = 0; d < MAX; d++) {
            for (let k = -d; k <= d; k += 2) {
                const kmiddle = middle + k;
                const kplus = kmiddle + 1;
                const kminus = kmiddle - 1;
                const kplusNode = diagonal[kplus];
                const kminusNode = diagonal[kminus];
                let prev = undefined;
                let i = 0;
                if (k === -d || (k !== d && kminusNode.i < kplusNode.i)) {
                    i = kplusNode.i;
                    prev = kplusNode;
                }
                else {
                    i = kminusNode.i + 1;
                    prev = kminusNode;
                }
                diagonal[kminus] = undefined; // no longer used
                let j = i - k;
                let node = {
                    i,
                    j,
                    prev: previousSnake(prev),
                    snake: false,
                };
                // orig and rev are zero-based
                // but the algorithm is one-based
                // that's why there's no +1 when indexing the sequences
                while (i < N && j < M && orig[i] === rev[j]) {
                    i++;
                    j++;
                }
                if (i > node.i) {
                    node = {
                        i,
                        j,
                        prev: node,
                        snake: true,
                    };
                }
                diagonal[kmiddle] = node;
                if (i >= N && j >= M) {
                    return diagonal[kmiddle];
                }
            }
            diagonal[middle + d - 1] = undefined;
        }
        // According to Myers, this cannot happen
        return undefined;
    }
    function buildRevisions(startNode, orig, rev) {
        const deltas = [];
        let path = startNode;
        if (path.snake) {
            path = path.prev;
        }
        while (path && path.prev && path.prev.j >= 0) {
            const i = path.i;
            const j = path.j;
            path = path.prev;
            const ianchor = path.i;
            const janchor = path.j;
            const original = {
                position: ianchor,
                lines: orig.slice(ianchor, i),
            };
            const revised = {
                position: janchor,
                lines: rev.slice(janchor, j),
            };
            let type;
            if (original.lines.length === 0 && revised.lines.length > 0) {
                type = 'insert';
            }
            else if (original.lines.length > 0 && revised.lines.length === 0) {
                type = 'delete';
            }
            else {
                type = 'change';
            }
            deltas.push({ original, revised, type });
            if (path.snake) {
                path = path.prev;
            }
        }
        return deltas;
    }
    function previousSnake(node) {
        if (node && !node.snake && node.prev) {
            return node.prev;
        }
        return node;
    }

    function blame(history) {
        // Convert to array of array of lines
        const versions = history.entry
            .filter((entry) => !!entry.resource)
            .map((entry) => ({
            meta: entry.resource?.meta,
            lines: core.stringify(entry.resource, true).match(/[^\r\n]+/g),
        }))
            .sort((a, b) => a.meta.lastUpdated.localeCompare(b.meta.lastUpdated));
        // Start with array of lines from the first version
        const table = versions[0].lines.map((line) => ({
            id: versions[0].meta.versionId,
            meta: versions[0].meta,
            value: line,
            span: 1,
        }));
        compareVersions(table, versions);
        combineSpans(table);
        return table;
    }
    /**
     * For each version, update the blame table with revisions.
     * @param table The output blame table.
     * @param versions The array of versions.
     */
    function compareVersions(table, versions) {
        for (let i = 1; i < versions.length; i++) {
            const revisions = diff(versions[i - 1].lines, versions[i].lines);
            for (const revision of revisions) {
                const position = revision.original.position;
                const oldLines = revision.original.lines;
                const newLines = revision.revised.lines;
                if (revision.type === 'delete' || revision.type === 'change') {
                    // Remove the old rows
                    table.splice(position, oldLines.length);
                }
                if (revision.type === 'insert' || revision.type === 'change') {
                    // Add the new lines
                    for (let k = 0; k < revision.revised.lines.length; k++) {
                        table.splice(position + k, 0, {
                            id: versions[i].meta.versionId,
                            meta: versions[i].meta,
                            value: newLines[k],
                            span: 1,
                        });
                    }
                }
            }
        }
    }
    /**
     * Combine adjacent rows into spans.
     * @param table The output blame table.
     */
    function combineSpans(table) {
        let start = 0;
        while (start < table.length) {
            let curr = start;
            while (curr < table.length && table[curr].id === table[start].id) {
                table[curr].span = -1;
                curr++;
            }
            table[start].span = curr - start;
            start = curr;
        }
    }

    const useStyles$2 = core$1.createStyles((theme) => ({
        container: {
            overflowX: 'auto',
        },
        root: {
            border: `0.1px solid ${theme.colors.gray[3]}`,
            borderCollapse: 'collapse',
            borderRadius: theme.radius.sm,
            borderSpacing: 0,
            fontSize: theme.fontSizes.xs,
            width: '100%',
            '& td': {
                padding: '2px 4px 0 4px',
                verticalAlign: 'top',
                whiteSpace: 'nowrap',
            },
        },
        startRow: {
            borderTop: `0.1px solid ${theme.colors.gray[3]}`,
        },
        normalRow: {
            borderTop: 0,
        },
        author: {
            lineHeight: '10px',
        },
        dateTime: {
            borderRight: `0.1px solid ${theme.colors.gray[3]}`,
            lineHeight: '20px',
        },
        lineNumber: {
            backgroundColor: theme.colors.gray[1],
            border: 0,
            color: theme.colors.gray[5],
            fontFamily: theme.fontFamilyMonospace,
            padding: `${theme.spacing.xs}px ${theme.spacing.sm}px`,
            textAlign: 'right',
        },
        line: {
            fontFamily: theme.fontFamilyMonospace,
            fontSize: theme.fontSizes.sm,
            padding: `${theme.spacing.xs}px ${theme.spacing.sm}px`,
        },
        pre: {
            margin: 0,
        },
    }));
    function ResourceBlame(props) {
        const { classes } = useStyles$2();
        const medplum = useMedplum();
        const [value, setValue] = React.useState(props.history);
        React.useEffect(() => {
            if (!props.history && props.resourceType && props.id) {
                medplum.readHistory(props.resourceType, props.id).then(setValue).catch(console.log);
            }
        }, [medplum, props.history, props.resourceType, props.id]);
        if (!value) {
            return React.createElement("div", null, "Loading...");
        }
        const resource = value.entry?.[0]?.resource;
        const table = blame(value);
        return (React.createElement("div", { className: classes.container },
            React.createElement("table", { className: classes.root },
                React.createElement("tbody", null, table.map((row, index) => (React.createElement("tr", { key: 'row-' + index, className: row.span > 0 ? classes.startRow : classes.normalRow },
                    row.span > 0 && (React.createElement(React.Fragment, null,
                        React.createElement("td", { className: classes.author, rowSpan: row.span },
                            React.createElement(ResourceBadge, { value: row.meta.author, link: true })),
                        React.createElement("td", { className: classes.dateTime, rowSpan: row.span },
                            React.createElement(MedplumLink, { to: getVersionUrl$1(resource, row.meta.versionId) }, getTimeString(row.meta.lastUpdated))))),
                    React.createElement("td", { className: classes.lineNumber }, index + 1),
                    React.createElement("td", { className: classes.line },
                        React.createElement("pre", { className: classes.pre }, row.value)))))))));
    }
    function getVersionUrl$1(resource, versionId) {
        return `/${resource.resourceType}/${resource.id}/_history/${versionId}`;
    }
    function getTimeString(lastUpdated) {
        const seconds = Math.floor((Date.now() - Date.parse(lastUpdated)) / 1000);
        const years = Math.floor(seconds / 31536000);
        if (years > 0) {
            return pluralizeTime(years, 'year');
        }
        const months = Math.floor(seconds / 2592000);
        if (months > 0) {
            return pluralizeTime(months, 'month');
        }
        const days = Math.floor(seconds / 86400);
        if (days > 0) {
            return pluralizeTime(days, 'day');
        }
        const hours = Math.floor(seconds / 3600);
        if (hours > 0) {
            return pluralizeTime(hours, 'hour');
        }
        const minutes = Math.floor(seconds / 60);
        if (minutes > 0) {
            return pluralizeTime(minutes, 'minute');
        }
        return pluralizeTime(seconds, 'second');
    }
    function pluralizeTime(count, noun) {
        return `${count} ${count === 1 ? noun : noun + 's'} ago`;
    }

    const useStyles$1 = core$1.createStyles((theme) => ({
        removed: {
            color: theme.colors.red[7],
            textDecoration: 'line-through',
        },
        added: {
            color: theme.colors.green[7],
        },
    }));
    function ResourceDiff(props) {
        let originalResource = props.original;
        let revisedResource = props.revised;
        if (props.ignoreMeta) {
            originalResource = { ...originalResource, meta: undefined };
            revisedResource = { ...revisedResource, meta: undefined };
        }
        const original = core.stringify(originalResource, true).match(/[^\r\n]+/g);
        const revised = core.stringify(revisedResource, true).match(/[^\r\n]+/g);
        const deltas = diff(original, revised);
        return (React.createElement("pre", { style: { color: 'gray' } }, deltas.map((delta, index) => (React.createElement(ChangeDiff, { key: 'delta' + index, delta: delta })))));
    }
    function ChangeDiff(props) {
        const { classes } = useStyles$1();
        return (React.createElement(React.Fragment, null,
            "...",
            React.createElement("br", null),
            props.delta.original.lines.length > 0 && (React.createElement("div", { className: classes.removed }, props.delta.original.lines.join('\n'))),
            props.delta.revised.lines.length > 0 && (React.createElement("div", { className: classes.added }, props.delta.revised.lines.join('\n'))),
            "...",
            React.createElement("br", null)));
    }

    function ResourceHistoryTable(props) {
        const medplum = useMedplum();
        const [value, setValue] = React.useState(props.history);
        React.useEffect(() => {
            if (!props.history && props.resourceType && props.id) {
                medplum
                    .readHistory(props.resourceType, props.id)
                    .then(setValue)
                    .catch(console.log);
            }
        }, [medplum, props.history, props.resourceType, props.id]);
        if (!value) {
            return React.createElement("div", null, "Loading...");
        }
        return (React.createElement(core$1.Table, { withBorder: true, withColumnBorders: true },
            React.createElement("thead", null,
                React.createElement("tr", null,
                    React.createElement("th", null, "Author"),
                    React.createElement("th", null, "Date"),
                    React.createElement("th", null, "Version"))),
            React.createElement("tbody", null, value.entry?.map((entry, index) => (React.createElement(HistoryRow, { key: 'entry-' + index, entry: entry }))))));
    }
    function HistoryRow(props) {
        const { response, resource } = props.entry;
        if (resource) {
            return (React.createElement("tr", null,
                React.createElement("td", null,
                    React.createElement(ResourceBadge, { value: resource.meta?.author, link: true })),
                React.createElement("td", null, core.formatDateTime(resource.meta?.lastUpdated)),
                React.createElement("td", null,
                    React.createElement(MedplumLink, { to: getVersionUrl(resource) }, resource.meta?.versionId))));
        }
        else {
            return (React.createElement("tr", null,
                React.createElement("td", { colSpan: 3 }, core.normalizeErrorString(response?.outcome))));
        }
    }
    function getVersionUrl(resource) {
        return `/${resource.resourceType}/${resource.id}/_history/${resource.meta?.versionId}`;
    }

    const useStyles = core$1.createStyles((theme) => ({
        container: {
            display: 'flex',
            minHeight: 400,
        },
        info: {
            minWidth: 300,
            padding: 20,
            borderRight: `1px solid ${theme.colors.gray[3]}`,
        },
        selection: {
            minWidth: 300,
            padding: 20,
        },
    }));
    function Scheduler(props) {
        const { classes } = useStyles();
        const medplum = useMedplum();
        const schedule = useResource(props.schedule);
        const questionnaire = useResource(props.questionnaire);
        const [slots, setSlots] = React.useState();
        const slotsRef = React.useRef();
        slotsRef.current = slots;
        const [month, setMonth] = React.useState(getStartMonth());
        const [date, setDate] = React.useState();
        const [slot, setSlot] = React.useState();
        const [response, setResponse] = React.useState();
        React.useEffect(() => {
            if (schedule) {
                setSlots([]);
                medplum
                    .searchResources('Slot', new URLSearchParams([
                    ['_count', (30 * 24).toString()],
                    ['schedule', core.getReferenceString(schedule)],
                    ['start', 'gt' + getStart(month)],
                    ['start', 'lt' + getEnd(month)],
                ]))
                    .then(setSlots)
                    .catch(console.log);
            }
            else {
                setSlots(undefined);
            }
        }, [medplum, schedule, month]);
        if (!schedule || !slots || !questionnaire) {
            return null;
        }
        const actor = schedule.actor?.[0];
        return (React.createElement("div", { className: classes.container, "data-testid": "scheduler" },
            React.createElement("div", { className: classes.info },
                actor && React.createElement(ResourceAvatar, { value: actor, size: "xl" }),
                actor && (React.createElement(core$1.Text, { size: "xl", weight: 500 },
                    React.createElement(ResourceName, { value: actor }))),
                React.createElement("p", null, "1 hour"),
                date && React.createElement("p", null, date.toLocaleDateString()),
                slot && React.createElement("p", null, formatTime(new Date(slot.start)))),
            React.createElement("div", { className: classes.selection },
                !date && (React.createElement("div", null,
                    React.createElement("h3", null, "Select date"),
                    React.createElement(CalendarInput, { slots: slots, onChangeMonth: setMonth, onClick: setDate }))),
                date && !slot && (React.createElement("div", null,
                    React.createElement("h3", null, "Select time"),
                    React.createElement(core$1.Stack, null, slots.map((s) => {
                        const slotStart = new Date(s.start);
                        return (slotStart.getTime() > date.getTime() &&
                            slotStart.getTime() < date.getTime() + 24 * 3600 * 1000 && (React.createElement("div", { key: s.id },
                            React.createElement(core$1.Button, { variant: "outline", style: { width: 150 }, onClick: () => setSlot(s) }, formatTime(slotStart)))));
                    })))),
                date && slot && !response && (React.createElement(QuestionnaireForm, { questionnaire: questionnaire, submitButtonText: 'Next', onSubmit: setResponse })),
                date && slot && response && (React.createElement("div", null,
                    React.createElement("h3", null, "You're all set!"),
                    React.createElement("p", null, "Check your email for a calendar invite."))))));
    }
    function getStart(month) {
        return formatSlotInstant(month.getTime());
    }
    function getEnd(month) {
        return formatSlotInstant(month.getTime() + 31 * 24 * 60 * 60 * 1000);
    }
    function formatSlotInstant(time) {
        return new Date(Math.max(Date.now(), time)).toISOString();
    }
    function formatTime(date) {
        return date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
    }

    function ServiceRequestTimeline(props) {
        return (React.createElement(ResourceTimeline, { value: props.serviceRequest, buildSearchRequests: (resource) => ({
                resourceType: 'Bundle',
                type: 'batch',
                entry: [
                    {
                        request: {
                            method: 'GET',
                            url: `${core.getReferenceString(resource)}/_history`,
                        },
                    },
                    {
                        request: {
                            method: 'GET',
                            url: `Communication?based-on=${core.getReferenceString(resource)}&_sort=-_lastUpdated`,
                        },
                    },
                    {
                        request: {
                            method: 'GET',
                            url: `Media?_count=100&based-on=${core.getReferenceString(resource)}&_sort=-_lastUpdated`,
                        },
                    },
                    {
                        request: {
                            method: 'GET',
                            url: `DiagnosticReport?based-on=${core.getReferenceString(resource)}&_sort=-_lastUpdated`,
                        },
                    },
                ],
            }), createCommunication: (resource, sender, text) => ({
                resourceType: 'Communication',
                status: 'completed',
                basedOn: [core.createReference(resource)],
                subject: resource.subject,
                sender: core.createReference(sender),
                sent: new Date().toISOString(),
                payload: [{ contentString: text }],
            }), createMedia: (resource, operator, content) => ({
                resourceType: 'Media',
                status: 'completed',
                basedOn: [core.createReference(resource)],
                subject: resource.subject,
                operator: core.createReference(operator),
                issued: new Date().toISOString(),
                content,
            }) }));
    }

    exports.AddressDisplay = AddressDisplay;
    exports.AddressInput = AddressInput;
    exports.AnnotationInput = AnnotationInput;
    exports.AsyncAutocomplete = AsyncAutocomplete;
    exports.AttachmentArrayDisplay = AttachmentArrayDisplay;
    exports.AttachmentArrayInput = AttachmentArrayInput;
    exports.AttachmentButton = AttachmentButton;
    exports.AttachmentDisplay = AttachmentDisplay;
    exports.AttachmentInput = AttachmentInput;
    exports.BackboneElementDisplay = BackboneElementDisplay;
    exports.BackboneElementInput = BackboneElementInput;
    exports.CalendarInput = CalendarInput;
    exports.CheckboxFormSection = CheckboxFormSection;
    exports.CodeInput = CodeInput;
    exports.CodeableConceptDisplay = CodeableConceptDisplay;
    exports.CodeableConceptInput = CodeableConceptInput;
    exports.CodingDisplay = CodingDisplay;
    exports.CodingInput = CodingInput;
    exports.ContactDetailDisplay = ContactDetailDisplay;
    exports.ContactDetailInput = ContactDetailInput;
    exports.ContactPointDisplay = ContactPointDisplay;
    exports.ContactPointInput = ContactPointInput;
    exports.Container = Container;
    exports.DateTimeInput = DateTimeInput;
    exports.DefaultResourceTimeline = DefaultResourceTimeline;
    exports.DescriptionList = DescriptionList;
    exports.DescriptionListEntry = DescriptionListEntry;
    exports.DiagnosticReportDisplay = DiagnosticReportDisplay;
    exports.Document = Document;
    exports.ElementDefinitionInputSelector = ElementDefinitionInputSelector;
    exports.ElementDefinitionTypeInput = ElementDefinitionTypeInput;
    exports.EncounterTimeline = EncounterTimeline;
    exports.ErrorBoundary = ErrorBoundary;
    exports.FhirPathTable = FhirPathTable;
    exports.Form = Form;
    exports.FormSection = FormSection;
    exports.HumanNameDisplay = HumanNameDisplay;
    exports.HumanNameInput = HumanNameInput;
    exports.IdentifierDisplay = IdentifierDisplay;
    exports.IdentifierInput = IdentifierInput;
    exports.Logo = Logo;
    exports.MedplumLink = MedplumLink;
    exports.MedplumProvider = MedplumProvider;
    exports.MemoizedFhirPathTable = MemoizedFhirPathTable;
    exports.MemoizedSearchControl = MemoizedSearchControl;
    exports.MoneyDisplay = MoneyDisplay;
    exports.MoneyInput = MoneyInput;
    exports.ObservationTable = ObservationTable;
    exports.Panel = Panel;
    exports.PatientTimeline = PatientTimeline;
    exports.PlanDefinitionBuilder = PlanDefinitionBuilder;
    exports.QuantityDisplay = QuantityDisplay;
    exports.QuantityInput = QuantityInput;
    exports.QuestionnaireBuilder = QuestionnaireBuilder;
    exports.QuestionnaireForm = QuestionnaireForm;
    exports.QuestionnaireFormItem = QuestionnaireFormItem;
    exports.RangeDisplay = RangeDisplay;
    exports.RangeInput = RangeInput;
    exports.ReferenceDisplay = ReferenceDisplay;
    exports.ReferenceInput = ReferenceInput;
    exports.ReferenceRangeEditor = ReferenceRangeEditor;
    exports.ReferenceRangeGroupEditor = ReferenceRangeGroupEditor;
    exports.RegisterForm = RegisterForm;
    exports.RequestGroupDisplay = RequestGroupDisplay;
    exports.ResourceArrayDisplay = ResourceArrayDisplay;
    exports.ResourceArrayInput = ResourceArrayInput;
    exports.ResourceAvatar = ResourceAvatar;
    exports.ResourceBadge = ResourceBadge;
    exports.ResourceBlame = ResourceBlame;
    exports.ResourceDiff = ResourceDiff;
    exports.ResourceForm = ResourceForm;
    exports.ResourceHistoryTable = ResourceHistoryTable;
    exports.ResourceInput = ResourceInput;
    exports.ResourceName = ResourceName;
    exports.ResourcePropertyDisplay = ResourcePropertyDisplay;
    exports.ResourcePropertyInput = ResourcePropertyInput;
    exports.ResourceTable = ResourceTable;
    exports.ResourceTimeline = ResourceTimeline;
    exports.Scheduler = Scheduler;
    exports.SearchChangeEvent = SearchChangeEvent;
    exports.SearchClickEvent = SearchClickEvent;
    exports.SearchControl = SearchControl;
    exports.SearchFieldEditor = SearchFieldEditor;
    exports.SearchFilterEditor = SearchFilterEditor;
    exports.SearchLoadEvent = SearchLoadEvent;
    exports.ServiceRequestTimeline = ServiceRequestTimeline;
    exports.SignInForm = SignInForm;
    exports.StatusBadge = StatusBadge;
    exports.Timeline = Timeline;
    exports.TimelineItem = TimelineItem;
    exports.TimingInput = TimingInput;
    exports.addDateFilterBetween = addDateFilterBetween;
    exports.addField = addField;
    exports.addFilter = addFilter;
    exports.addLastMonthFilter = addLastMonthFilter;
    exports.addMissingFilter = addMissingFilter;
    exports.addNextMonthFilter = addNextMonthFilter;
    exports.addThisMonthFilter = addThisMonthFilter;
    exports.addTodayFilter = addTodayFilter;
    exports.addTomorrowFilter = addTomorrowFilter;
    exports.addYearToDateFilter = addYearToDateFilter;
    exports.addYesterdayFilter = addYesterdayFilter;
    exports.buildFieldNameString = buildFieldNameString;
    exports.clearFilters = clearFilters;
    exports.clearFiltersOnField = clearFiltersOnField;
    exports.convertIsoToLocal = convertIsoToLocal;
    exports.convertLocalToIso = convertLocalToIso;
    exports.createScriptTag = createScriptTag;
    exports.deleteFilter = deleteFilter;
    exports.getErrorsForInput = getErrorsForInput;
    exports.getIssuesForExpression = getIssuesForExpression;
    exports.getMonthString = getMonthString;
    exports.getOpString = getOpString;
    exports.getRecaptcha = getRecaptcha;
    exports.getSearchOperators = getSearchOperators;
    exports.getSortField = getSortField;
    exports.getStartMonth = getStartMonth;
    exports.getTimeString = getTimeString;
    exports.getValueAndType = getValueAndType;
    exports.initRecaptcha = initRecaptcha;
    exports.isChoiceQuestion = isChoiceQuestion;
    exports.isQuestionEnabled = isQuestionEnabled;
    exports.isSortDescending = isSortDescending;
    exports.parseForm = parseForm;
    exports.renderValue = renderValue;
    exports.setFilters = setFilters;
    exports.setOffset = setOffset;
    exports.setPage = setPage;
    exports.setPropertyValue = setPropertyValue;
    exports.setSort = setSort;
    exports.sortByDateAndPriority = sortByDateAndPriority;
    exports.toggleSort = toggleSort;
    exports.useMedplum = useMedplum;
    exports.useMedplumContext = useMedplumContext;
    exports.useMedplumProfile = useMedplumProfile;
    exports.useResource = useResource;

}));
//# sourceMappingURL=index.cjs.map
